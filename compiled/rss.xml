<?xml version="1.0"?>
<rss version="2.0">
  <channel>
    <title>顽固的卡夫卡</title>
    <link>http://defworld.com</link>
    <pubDate>2015-04-29 09:57:39 +0800</pubDate>
    <item>
      <title>sequel pro 快捷键</title>
      <link>http://defworld.com/2015/02/12/sequel-pro-shortcuts.html</link>
      <pubDate>2015-02-12 12:00:00 +0800</pubDate>
      <description>&lt;ul&gt;
&lt;li&gt;&lt;code&gt;⇧ ⌘ D&lt;/code&gt;Choose Database&lt;/li&gt;
&lt;li&gt;&lt;code&gt;⌃ W&lt;/code&gt; select current word&lt;/li&gt;
&lt;li&gt;&lt;code&gt;⌃ L&lt;/code&gt; select current line&lt;/li&gt;
&lt;li&gt;&lt;code&gt;⌃ Y&lt;/code&gt; select current sql statement&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;table-content-tab&#34; href=&#34;#table-content-tab&#34;&gt;&lt;/a&gt;Table Content Tab&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;⌦&lt;/code&gt; delete selected row(s)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;⌥ ⌘ A&lt;/code&gt; add a new row&lt;/li&gt;
&lt;li&gt;&lt;code&gt;⌘ D&lt;/code&gt; duplicate selected row&lt;/li&gt;
&lt;li&gt;&lt;code&gt;⌘ R&lt;/code&gt; refresh tabble contents&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;custom-query-tab&#34; href=&#34;#custom-query-tab&#34;&gt;&lt;/a&gt;Custom Query Tab&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;⌘ R&lt;/code&gt; Run current query or selection&lt;/li&gt;
&lt;li&gt;&lt;code&gt;⌘ /&lt;/code&gt; (Un)Comment line or selection&lt;/li&gt;
&lt;li&gt;&lt;code&gt;⌃ H&lt;/code&gt; Show MySQL help for current word or selection&lt;/li&gt;
&lt;li&gt;&lt;code&gt;⌥ ⌘ 1&lt;/code&gt; Show all database names as completion list&lt;/li&gt;
&lt;li&gt;&lt;code&gt;⌥ ⌘ 2&lt;/code&gt; Show all table and view names as completion list&lt;/li&gt;
&lt;li&gt;&lt;code&gt;⌥ ⌘ 3&lt;/code&gt; Show all table names from current database as completion list&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    <item>
      <title>一句话表达设计模式</title>
      <link>http://defworld.com/2015/01/16/java-design-pattern.html</link>
      <pubDate>2015-01-16 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;&lt;a href=&#34;http://ifeve.com/java-example-of-observer-pattern/&#34;&gt;观察者模式&lt;/a&gt;：分订阅者、发布者，发布者发布消息给多个订阅者&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://ifeve.com/java-example-of-strategy-pattern/&#34;&gt;策略模式&lt;/a&gt;：只有运行时才知道会走哪个策略。if-else也能实现，建议将策略抽象出一个接口，运行时决定走哪个实现。&lt;br /&gt;
&lt;a href=&#34;http://ifeve.com/state-design-pattern-in-java-example-tutorial/&#34;&gt;状态模式&lt;/a&gt;：将一段逻辑委托给另一个对象处理，但是在代码编写时就确定走哪个对象处理，建议抽象一个接口。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://ifeve.com/template-method-design-pattern/&#34;&gt;模板模式&lt;/a&gt;：定义做一件事情的步骤，但不具体实现。一般在父类定义做一件事情需要调用哪几个步骤。&lt;br /&gt;
&lt;a href=&#34;http://ifeve.com/java-example-of-decorator-pattern/&#34;&gt;装饰者模式&lt;/a&gt;：因为多个因素构成了一个类，这些因素自由组合时个数比较多，需要将其中一部分因素抽出来作为一个类，抽出来的类和原来的类组合构成一个综合类。典型例子java IO库。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://ifeve.com/memento-design-pattern-in-java-example-tutorial/&#34;&gt;备忘录模式&lt;/a&gt;：&lt;/p&gt;
</description>
    </item>
    <item>
      <title>java小贴士-1</title>
      <link>http://defworld.com/2015/01/06/note-java-tips-1.html</link>
      <pubDate>2015-01-06 12:00:00 +0800</pubDate>
      <description>&lt;h1&gt;&lt;a style=&#34;display: block;&#34; name=&#34;java中的双括号反模式（double-curly-braces-anti-pattern）&#34; href=&#34;#java中的双括号反模式（double-curly-braces-anti-pattern）&#34;&gt;&lt;/a&gt;java中的双括号反模式（Double Curly Braces Anti Pattern）&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;Map map = new HashMap() {{
    put(&amp;quot;&amp;quot;, &amp;quot;&amp;quot;)
}};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这种双括号反模式会创建一个HashMap的匿名子类，然后用双括号里的内容初始化这个子类。并且每次都是新的子类。有两个问题：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;如果有大量的这种用法，会产生大量的匿名内部类&lt;/li&gt;
&lt;li&gt;匿名内部类对应对象，会持有对外部对象的引用，如果处理不好，加上外部对象比较中，容易造成内存泄露。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;结论：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;内部类是一头野兽。它已经造成过许多的问题以及认知失衡。匿名内部类则更为严重&lt;/li&gt;
&lt;li&gt;不要自作聪明了，别使用双括号来进行初始化&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;参考:&lt;/p&gt;

&lt;p&gt;《切勿自作聪明，慎用双括号反模式》http://it.deepinmind.com/java/&lt;sup&gt;2014&lt;/sup&gt;&amp;frasl;&lt;sub&gt;12&lt;/sub&gt;/12/dont-be-clever-the-double-curly-braces-anti-pattern.html&lt;/p&gt;

&lt;h1&gt;&lt;a style=&#34;display: block;&#34; name=&#34;java中完美的单例&#34; href=&#34;#java中完美的单例&#34;&gt;&lt;/a&gt;java中完美的单例&lt;/h1&gt;
</description>
    </item>
    <item>
      <title>计算机、编程术语解释</title>
      <link>http://defworld.com/2014/12/19/computer-noun-explanation.html</link>
      <pubDate>2014-12-19 12:00:00 +0800</pubDate>
      <description>&lt;h1&gt;&lt;a style=&#34;display: block;&#34; name=&#34;soa&#34; href=&#34;#soa&#34;&gt;&lt;/a&gt;SOA&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;“取乎其上，得乎其中；取乎其中，得乎其下；取乎其下，则无所得矣” —— 孔子&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;参考：&lt;/p&gt;

&lt;p&gt;SOA wiki : &lt;a href=&#34;http://zh.wikipedia.org/wiki/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%9E%B6%E6%9E%84&#34;&gt;http://zh.wikipedia.org/wiki/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%9E%B6%E6%9E%84&lt;/a&gt;&lt;br /&gt;
微观SOA：服务设计原则及其实践方式（上篇）: &lt;a href=&#34;http://www.infoq.com/cn/articles/micro-soa-1&#34;&gt;http://www.infoq.com/cn/articles/micro-soa-1&lt;/a&gt;&lt;br /&gt;
微观SOA：服务设计原则及其实践方式（下篇）：http://www.infoq.com/cn/articles/micro-soa-2?utm_source=infoq&amp;amp;utm_medium=related_content_link&amp;amp;utm_campaign=relatedContent_articles_clk&lt;/p&gt;

&lt;p&gt;面向服务的体系结构（Service-oriented architecture）是构造分布式计算的应用程序的方法。它将应用程序功能作为服务发送给最终用户或者其他服务。&lt;br /&gt;
当当网架构师沈理把SOA分为“宏观SOA”、“微观SOA”，宏观SOA考虑的东西比较大，而微观的比较容易实施落地。至于微观SOA的原则可能需要在实践中总结，沈理给出了他的最佳实践原则：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;服务设计原则1：优化远程调用&lt;/li&gt;
&lt;li&gt;服务设计原则2：消除冗余数据&lt;/li&gt;
&lt;li&gt;服务设计原则3：粗粒度契约&lt;/li&gt;
&lt;li&gt;服务设计原则4：通用契约&lt;/li&gt;
&lt;li&gt;服务设计原则5：隔离变化&lt;/li&gt;
&lt;li&gt;服务设计原则6：契约先行&lt;/li&gt;
&lt;li&gt;服务设计原则7：稳定和兼容的契约&lt;/li&gt;
&lt;li&gt;服务设计原则8：契约包装&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    <item>
      <title>并发编程 - 锁</title>
      <link>http://defworld.com/2014/12/18/concurrent-programming-lock.html</link>
      <pubDate>2014-12-18 12:00:00 +0800</pubDate>
      <description>&lt;h1&gt;&lt;a style=&#34;display: block;&#34; name=&#34;饥饿和公平&#34; href=&#34;#饥饿和公平&#34;&gt;&lt;/a&gt;饥饿和公平&lt;/h1&gt;

&lt;p&gt;饥饿是说某个线程总是被其他线程抢走CPU运行时间，而公平指所有的线程都能公平的获得运行机会。&lt;br /&gt;
如果是使用synchronized同步块，不能保证某个线程一定获得运行机会，所以需要使用锁。锁的实现里可以自己控制唤醒时的机会分配。理论上Java不能实现100%公平。&lt;/p&gt;

&lt;h1&gt;&lt;a style=&#34;display: block;&#34; name=&#34;自旋锁&#34; href=&#34;#自旋锁&#34;&gt;&lt;/a&gt;自旋锁&lt;/h1&gt;

&lt;p&gt;自旋锁是采用让当前线程不停地在循环体内执行实现的。&lt;/p&gt;

&lt;h1&gt;&lt;a style=&#34;display: block;&#34; name=&#34;阻塞锁&#34; href=&#34;#阻塞锁&#34;&gt;&lt;/a&gt;阻塞锁&lt;/h1&gt;

&lt;p&gt;阻塞锁，与自旋锁不同，改变了线程的运行状态。&lt;br /&gt;
阻塞锁的优势在于，阻塞的线程不会占用cpu时间，不会导致。CPU占用率过高，但进入时间以及恢复时间都要比自旋锁略慢。在竞争激烈的情况下 阻塞锁的性能要明显高于 自旋锁。&lt;br /&gt;
理想的情况则是; 在线程竞争不激烈的情况下，使用自旋锁，竞争激烈的情况下使用，阻塞锁。&lt;/p&gt;

&lt;h1&gt;&lt;a style=&#34;display: block;&#34; name=&#34;可重入锁&#34; href=&#34;#可重入锁&#34;&gt;&lt;/a&gt;可重入锁&lt;/h1&gt;

&lt;p&gt;可重入锁，也叫做递归锁，指的是同一线程外层函数获得锁之后，内层递归函数仍然有获取该锁的代码，等到其他线程unlock时，这个线程能够从这个锁里出来。&lt;/p&gt;

&lt;p&gt;参考：&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://ifeve.com/starvation-and-fairness/&#34;&gt;饥饿和公平&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://ifeve.com/java_lock_see1/&#34;&gt;java锁的种类以及辨析（一）：自旋锁&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://ifeve.com/java_lock_see2/&#34;&gt;Java锁的种类以及辨析（二）：自旋锁的其他种类&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://ifeve.com/java_lock_see3/&#34;&gt;Java锁的种类以及辨析（三）：阻塞锁&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://ifeve.com/java_lock_see4/&#34;&gt;Java锁的种类以及辨析（四）：可重入锁&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>笔记 - java annotation</title>
      <link>http://defworld.com/2014/12/18/java-annotation.html</link>
      <pubDate>2014-12-18 12:00:00 +0800</pubDate>
      <description>&lt;h1&gt;&lt;a style=&#34;display: block;&#34; name=&#34;分类&#34; href=&#34;#分类&#34;&gt;&lt;/a&gt;分类&lt;/h1&gt;

&lt;p&gt;java annotation主要分为以下几类：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Compiler instructions&lt;/li&gt;
&lt;li&gt;Build-time instructions&lt;/li&gt;
&lt;li&gt;Runtime instructions&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Compiler instructions比如Java&amp;rsquo;s Builtin Annotations，give instructions to the Java compiler：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;@Deprecated&lt;/li&gt;
&lt;li&gt;@Override&lt;/li&gt;
&lt;li&gt;@SuppressWarnings&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The build process includes generating source code, compiling the source, generating XML files (e.g. deployment descriptors), packaging the compiled code and files into a JAR file etc. Building the software is typically done by an automatic build tool like Apache Ant or Apache Maven. Build tools may scan your Java code for specific annotations and generate source code or other files based on these annotations. Build-time instructions比如&lt;/p&gt;

&lt;h1&gt;&lt;a style=&#34;display: block;&#34; name=&#34;构成&#34; href=&#34;#构成&#34;&gt;&lt;/a&gt;构成&lt;/h1&gt;

&lt;p&gt;java annotation主要构成：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Annotation Elements&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;You can use all primitive data types as element data types. You can 
also use arrays as data type. You cannot use complex objects as data type.
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Annotation Placement,@Target:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;You can put Java annotations above classes, interfaces, methods, 
method parameters, fields and local variables.
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Java Annotation Purposes,@Retention:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * Annotations are to be discarded by the compiler.
 * (If you create your own annotations for use with build tools that scan the code, you can use this retention policy.)
 */
SOURCE,


/**
* Annotations are to be recorded in the class file by the compiler
* but need not be retained by the VM at run time.  This is the default
* behavior.
*/
CLASS,


/**
* Annotations are to be recorded in the class file by the compiler and
* retained by the VM at run time, so they may be read reflectively.
*
* @see java.lang.reflect.AnnotatedElement
*/
RUNTIME
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;@Inherited 可以被subclasses继承，只能用在class上&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;@Documented 标识javaDoc中可以见这个annotation&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1&gt;&lt;a style=&#34;display: block;&#34; name=&#34;难点：理解class、runtime区别&#34; href=&#34;#难点：理解class、runtime区别&#34;&gt;&lt;/a&gt;难点：理解CLASS、RUNTIME区别&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://stackoverflow.com/questions/3107970/annotations-retention-policy&#34;&gt;这个stackoverflow&lt;/a&gt;提到RetentionPolicy.CLASS实际上 &amp;ldquo;Discard during class load.Useful when doing bytecode-level post-processing. &amp;ldquo;，而RetentionPolicy.RUNTIME: Do not discard. 我们进一步看什么叫做bytecode-level post-processing。&lt;a href=&#34;http://stackoverflow.com/questions/15268057/where-does-bytecode-injection-happen&#34;&gt;这个stackoverflow&lt;/a&gt;提到，我们可以借助一些工具在多个阶段对bytecode进行处理。例如 Javassist / ASM这两个工具可以做到的。可以参考fastjson的源码，来理解这两个个工具如何使用。&lt;/p&gt;

&lt;p&gt;但是，似乎还是不能解释，因为我遇到过一个case，用CLASS级别，同样可以通过反射库拿到这些标签。&lt;a href=&#34;http://stackoverflow.com/questions/21167610/does-reflections-library-ignore-the-retentionpolicy?rq=1&#34;&gt;这个stackoverflow&lt;/a&gt;解释这个事情是&amp;rdquo;Though “need not be retained” does not sound like a strong requirement.&amp;ldquo;，说明并不是严格限制，如果你用第三方反射库或者自定义annotation，结果不一定如此。&lt;/p&gt;

&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;fastjson如何使用反射&#34; href=&#34;#fastjson如何使用反射&#34;&gt;&lt;/a&gt;fastjson如何使用反射&lt;/h2&gt;

&lt;p&gt;待续&lt;/p&gt;

&lt;p&gt;参考：&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://ifeve.com/java-reflection-8-annotation/&#34;&gt;Java Reflection(八):注解&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://tutorials.jenkov.com/java/annotations.html&#34;&gt;Java Annotations&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://docs.oracle.com/javase/tutorial/java/annotations/&#34;&gt;Lesson: Annotations&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://en.wikipedia.org/wiki/Java_annotation#Processing&#34;&gt;Java annotation wiki&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>关系型数据库笔记</title>
      <link>http://defworld.com/2014/12/05/r-db.html</link>
      <pubDate>2014-12-05 12:00:00 +0800</pubDate>
      <description>&lt;h1&gt;&lt;a style=&#34;display: block;&#34; name=&#34;1nf-2nf-3nf-...&#34; href=&#34;#1nf-2nf-3nf-...&#34;&gt;&lt;/a&gt;1NF 2NF 3NF &amp;hellip;&lt;/h1&gt;

&lt;p&gt;范式（NF）：一张数据表的表结构所符合的某种设计标准的级别。要求逐级提高，而高级的同时满足低级的。&lt;/p&gt;

&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;1nf&#34; href=&#34;#1nf&#34;&gt;&lt;/a&gt;1NF&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://farm9.staticflickr.com/8616/15925324316_09846f9765_z.jpg&#34; alt=&#34;1NF&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;如上图进货和销售又细分了属性，不满足1NF。&lt;br /&gt;
每个属性都不可再分。因为真实的DB每列都不可再分的，所以能存到真实DB里就说明满足1NF。&lt;/p&gt;

&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;2nf&#34; href=&#34;#2nf&#34;&gt;&lt;/a&gt;2NF&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://farm8.staticflickr.com/7495/15786427597_96178e86ab.jpg&#34; alt=&#34;2NF&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;如上图，满足1NF，但存在以下问题：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;每一名学生的学号、姓名、系名、系主任这些数据重复多次。每个系与对应的系主任的数据也重复多次——&lt;strong&gt;数据冗余过大&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;新建一个系，无法将系名与系主任的数据单独添加到数据库——&lt;strong&gt;插入异常&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;删除某个系所欲学生记录，这个系的数据被删除掉 —— &lt;strong&gt;删除异常&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;某同学转系，需要修改三条记录 —— &lt;strong&gt;修改异常&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;先介绍几个概念:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;码：K为某表的一个属性或属性组，它是唯一的，即其他属性完全函数依赖于K，称K为候选码，简称码。选择其中一个作为主码&lt;/li&gt;
&lt;li&gt;函数依赖：一张表中，在属性（或属性组）X值确定的情况下，必能能确定属性Y的值，那么就可以说Y函数依赖于X&lt;/li&gt;

&lt;li&gt;&lt;p&gt;完全函数依赖：若Y函数依赖X，且对于X的任何一个真子集X&amp;rsquo;（假如属性组X包含超过一个属性的话），Y函数依赖于X&amp;rsquo;不成立，称Y对X完全函数依赖。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;（学号，课名） F→ 分数 （注：因为同一个的学号对应的分数不确定，同一个课名对应的分数也不确定）
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;部分函数依赖：不完全函数依赖时反过来就是部分函数依赖。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;传递函数依赖：假如 Z 函数依赖于 Y，且 Y 函数依赖于 X （严格来说还有一个X 不包含于Y，且 Y 不函数依赖于Z的前提条件），那么我们就称 Z 传递函数依赖于 X&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;非主属性：包含在任何一个码中的属性成为主属性&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;2NF定义：2NF在1NF的基础之上，消除了非主属性对于码的部分函数依赖。判断步骤：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;第一步：找出数据表中所有的码。&lt;/li&gt;
&lt;li&gt;第二步：根据第一步所得到的码，找出所有的主属性。&lt;/li&gt;
&lt;li&gt;第三步：数据表中，除去所有的主属性，剩下的就都是非主属性了。&lt;/li&gt;
&lt;li&gt;第四步：查看是否存在非主属性对码的部分函数依赖。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://farm9.staticflickr.com/8619/15784930058_d21ff87fe3.jpg&#34; alt=&#34;2NF-2&#34; /&gt;
&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;码：（学号、课名）
主属性有两个：学号 与 课名
非主属性有四个：姓名、系名、系主任、分数

对于（学号，课名） → 姓名，有 学号 → 姓名，存在非主属性 姓名 对码（学号，课名）的部分函数依赖。
对于（学号，课名） → 系名，有 学号 → 系名，存在非主属性 系名 对码（学号，课名）的部分函数依赖。
对于（学号，课名） → 系主任，有 学号 → 系主任，存在非主属性 对码（学号，课名）的部分函数依赖。

所以表3存在非主属性对于码的部分函数依赖，最高只符合1NF的要求，不符合2NF的要求。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那就要进行模式分解，分解成下面两个表：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;选课（学号，课名，分数）
学生（学号，姓名，系名，系主任）
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;新的函数依赖图：&lt;/p&gt;

&lt;p&gt;![2NF-3]()&lt;/p&gt;

&lt;p&gt;满足了2NF，还是存在一些问题：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;删除某个系中所有的学生记录：该系的信息仍然全部丢失。——无改进&lt;/li&gt;
&lt;li&gt;插入一个尚无学生的新系的信息：因为学生表的码是学号，不能为空，所以此操作不被允许。——无改进&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;3nf&#34; href=&#34;#3nf&#34;&gt;&lt;/a&gt;3NF&lt;/h2&gt;

&lt;p&gt;3NF在2NF的基础之上，消除了非主属性对于码的传递函数依赖。&lt;/p&gt;

&lt;p&gt;对于选课表，主码为（学号，课名），主属性为学号和课名，非主属性只有一个，为分数，不可能存在传递函数依赖，所以选课表的设计，符合3NF的要求。&lt;/p&gt;

&lt;p&gt;对于学生表，主码为学号，主属性为学号，非主属性为姓名、系名和系主任。因为 学号 → 系名，同时 系名 → 系主任，所以存在非主属性系主任对于码学号的传递函数依赖，所以学生表的设计，不符合3NF的要求。。&lt;/p&gt;

&lt;p&gt;进一步模式分解：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;选课（学号，课名，分数）
学生（学号，姓名，系名）
系（系名，系主任）
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;&lt;a style=&#34;display: block;&#34; name=&#34;how-to-store-a-tree?&#34; href=&#34;#how-to-store-a-tree?&#34;&gt;&lt;/a&gt;How to Store a Tree?&lt;/h1&gt;

&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;邻接表&#34; href=&#34;#邻接表&#34;&gt;&lt;/a&gt;邻接表&lt;/h2&gt;

&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;枚举路径&#34; href=&#34;#枚举路径&#34;&gt;&lt;/a&gt;枚举路径&lt;/h2&gt;

&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;嵌套集&#34; href=&#34;#嵌套集&#34;&gt;&lt;/a&gt;嵌套集&lt;/h2&gt;

&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;闭包表&#34; href=&#34;#闭包表&#34;&gt;&lt;/a&gt;闭包表&lt;/h2&gt;

&lt;h1&gt;&lt;a style=&#34;display: block;&#34; name=&#34;几种操作db工具&#34; href=&#34;#几种操作db工具&#34;&gt;&lt;/a&gt;几种操作DB工具&lt;/h1&gt;

&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;java的jdbc&#34; href=&#34;#java的jdbc&#34;&gt;&lt;/a&gt;java的jdbc&lt;/h2&gt;

&lt;p&gt;jdbc这边包括几个概念，如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://farm8.staticflickr.com/7488/15839289920_b67e7d5e88.jpg&#34; alt=&#34;jdbc&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;写代码时面对的是jdbc api，统一的，而怎么连接具体类型的db由具体的JDBC Driver实现，方便在程序切换DB。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class JDBCDemo {
    public staic void main(String args[]) {
        /* get conn */
        Class.forName(&amp;quot;com.mysql.jdbc.Driver&amp;quot;).newInstance();
        String url = &amp;quot;jdbc:mysql://localhost/coffeebreak&amp;quot;;
        Connection conn = DriverManager.getConnection(url, &amp;quot;username&amp;quot;, &amp;quot;password&amp;quot;);

        /* query db */
        String query = &amp;quot;SELECT COF_NAME, PRICE FROM COFFEES&amp;quot;;
        Statement st = conn.createStatement();
        ResultSet rs = st.executeQuery(query);
        while (rs.next()) {
            String s = rs.getString(&amp;quot;COF_NAME&amp;quot;);
            float n = rs.getFloat(&amp;quot;PRICE&amp;quot;);
            System.out.println(s + &amp;quot;   &amp;quot; + n);
        }

        /* close conn */
        conn.close();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;java的ibatis&#34; href=&#34;#java的ibatis&#34;&gt;&lt;/a&gt;java的ibatis&lt;/h2&gt;

&lt;p&gt;DB列名和Do对象的映射，通过sql.xml配置文件配置，不需要像jdbc代码手写。&lt;/p&gt;

&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;java的hibernate&#34; href=&#34;#java的hibernate&#34;&gt;&lt;/a&gt;java的hibernate&lt;/h2&gt;

&lt;p&gt;略&lt;/p&gt;

&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;ror&#34; href=&#34;#ror&#34;&gt;&lt;/a&gt;RoR&lt;/h2&gt;

&lt;h1&gt;&lt;a style=&#34;display: block;&#34; name=&#34;事务&#34; href=&#34;#事务&#34;&gt;&lt;/a&gt;事务&lt;/h1&gt;

&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;mysql事务&#34; href=&#34;#mysql事务&#34;&gt;&lt;/a&gt;mysql事务&lt;/h2&gt;

&lt;p&gt;上层的封装其实依赖底层DB支持，mysql如何支持，后续再展开。&lt;/p&gt;

&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;jdbc事务&#34; href=&#34;#jdbc事务&#34;&gt;&lt;/a&gt;jdbc事务&lt;/h2&gt;

&lt;h3&gt;JDBC事务隔离级别&lt;/h3&gt;

&lt;p&gt;JDBC定义了五种事务隔离级别：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;TRANSACTION_NONE JDBC驱动不支持事务&lt;/li&gt;
&lt;li&gt;TRANSACTION_READ_UNCOMMITTED 允许脏读、不可重复读和幻读。&lt;/li&gt;
&lt;li&gt;TRANSACTION_READ_COMMITTED 禁止脏读，但允许不可重复读和幻读。&lt;/li&gt;
&lt;li&gt;TRANSACTION_REPEATABLE_READ 禁止脏读和不可重复读，但允许幻读。&lt;/li&gt;
&lt;li&gt;TRANSACTION_SERIALIZABLE 禁止脏读、不可重复读和幻读&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;JDBC定义了SavePoint接口，提供在一个更细粒度的事务控制机制。当设置了一个保存点后，可以rollback到该保存点处的状态，而不是rollback整个事务。&lt;br /&gt;
JDBC规范虽然定义了事务的以上支持行为，但是各个JDBC驱动，数据库厂商对事务的支持程度可能各不相同。为此，JDBC提供了DatabaseMetaData接口，提供了一系列JDBC特性支持情况的获取方法。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;脏读(dirty read)：一个事物读取了另一个事务尚未提交的数据
不可重复读(non-repeatable read) ：解决了脏读问题，一个事务的操作导致另一个事务前后两次读取到不同的数据
幻读(phantom read) ：解决了不可重复读问题。保证了同一个事务里，查询的结果都是事务开始时的状态（一致性）。但是，如果另一个事务同时提交了新数据，本事务再更新时，就会“惊奇的”发现了这些新数据。

脏读和不可重复读的区别是，脏读是读到未提交的数据，不可重复读读到的确实是已经提交的数据。  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;jdbc savepoint&lt;/h3&gt;

&lt;p&gt;将一个事务再细分，不是整个事务都要回滚。&lt;/p&gt;

&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;spring事务支持&#34; href=&#34;#spring事务支持&#34;&gt;&lt;/a&gt;spring事务支持&lt;/h2&gt;

&lt;h3&gt;隔离级别（isolation level）&lt;/h3&gt;

&lt;p&gt;参考jdbc事务隔离&lt;/p&gt;

&lt;h3&gt;事务只读（transaction readonly）&lt;/h3&gt;

&lt;p&gt;Spring只是提供设置入口，最终起作用是在ORM框架和JDBC impl层，这里&lt;a href=&#34;http://www.codeinstructions.com/2009/04/read-only-transactions-with-spring-and.html&#34;&gt;有篇文章&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;事务传播（transaction propagation）&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;outer transaction : 外部methodA对应的transaction
inner transaction : methodA调用的methodB对ing的transaction
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以下说明，相似的实现带扣Spring源码。&lt;/p&gt;

&lt;h4&gt;Required&lt;/h4&gt;

&lt;p&gt;outer transaction和inner transaction公用一个physical transaction（对应DB transaction），但其实是两个独立的logical transaction。methodB失败，会在physical tranaction身上mark roolback only，然后methodB methodA都需要回滚。&lt;/p&gt;

&lt;h4&gt;RequiresNew&lt;/h4&gt;

&lt;p&gt;outer transaction和inner transaction各自一个physical transaction，commit / rollback都是独立的。&lt;/p&gt;

&lt;h4&gt;Nested&lt;/h4&gt;

&lt;p&gt;跟RequiresNew不同的是，用transaction的savapoint概念来实现，methodB开始之前启动一个savapoint，methodB失败，只是这个savapoint回滚，而整个transaction可以不回滚。&lt;/p&gt;

&lt;p&gt;参考:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.zhihu.com/question/24696366&#34;&gt;知乎：解释一下关系数据库的第一第二第三范式？&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://www3.ntu.edu.sg/home/ehchua/programming/index.html&#34;&gt;一个教程&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://docs.oracle.com/javase/tutorial/jdbc/overview/index.html&#34;&gt;oracle官方jdbc教程&lt;/a&gt;&lt;br /&gt;
《Mysql技术内幕-InnoDB存储引擎》&lt;br /&gt;
《Marking Rollback Only》https://docs.oracle.com/cd/E23095_01/Platform.93/ATGProgGuide/html/s1204markingrollbackonly01.html&lt;br /&gt;
《spring-reference-3.2x Transaction propagation》&lt;br /&gt;
《Spring声明式事务管理与配置详解》http://www.cnblogs.com/hellojava/archive/&lt;sup&gt;2012&lt;/sup&gt;&amp;frasl;&lt;sub&gt;11&lt;/sub&gt;/&lt;sup&gt;21&lt;/sup&gt;&amp;frasl;&lt;sub&gt;2780694&lt;/sub&gt;.html&lt;br /&gt;
《HTTP幂等性概念和应用》http://coolshell.cn/articles/4787.html&lt;/p&gt;
</description>
    </item>
    <item>
      <title>url encode</title>
      <link>http://defworld.com/2014/11/16/url-encode.html</link>
      <pubDate>2014-11-16 12:00:00 +0800</pubDate>
      <description>&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;bitset&#34; href=&#34;#bitset&#34;&gt;&lt;/a&gt;BitSet&lt;/h2&gt;

&lt;p&gt;{[0],[0],[0],[0],[0],[0],[0],[0]} * 4&lt;/p&gt;

&lt;p&gt;java用long[]存储（取名word），而bitset可以理解为一个bit[]，这里就需要有一个映射bitIndex -&amp;gt; wordIndex。需要注意的是，例如7并不是直接换成bit形式，而是位于bit[]的第七位。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;private long[] words; // 真实的用来存储bitIndex的内存空间
private final static int ADDRESS_BITS_PER_WORD = 6;
private final static int BITS_PER_WORD = 1 &amp;lt;&amp;lt; ADDRESS_BITS_PER_WORD; // 1 &amp;lt;&amp;lt; 2 = 2^6 = 64，每个long存储存64个bitIndex

private static int wordIndex(int bitIndex) {
    return bitIndex &amp;gt;&amp;gt; ADDRESS_BITS_PER_WORD; 
}

private void expandTo(int wordIndex) {
    int wordsRequired = wordIndex+1;
    if (wordsInUse &amp;lt; wordsRequired) {
        ensureCapacity(wordsRequired);
        wordsInUse = wordsRequired;
    }
}

 public void set(int bitIndex) {
    if (bitIndex &amp;lt; 0)
        throw new IndexOutOfBoundsException(&amp;quot;bitIndex &amp;lt; 0: &amp;quot; + bitIndex);

        int wordIndex = wordIndex(bitIndex);
    expandTo(wordIndex);

    // 1L &amp;lt;&amp;lt; bitIndex， 1L &amp;lt;&amp;lt; 64是一个循环，实际上等于 1L &amp;lt;&amp;lt; (bitIndex % 64)
    // 把bitIndex插入到合适的bit位
    words[wordIndex] |= (1L &amp;lt;&amp;lt; bitIndex); // Restores invariants

    checkInvariants();
}

// 判断是否存在
public boolean get(int bitIndex) {
    if (bitIndex &amp;lt; 0)
        throw new IndexOutOfBoundsException(&amp;quot;bitIndex &amp;lt; 0: &amp;quot; + bitIndex);

    checkInvariants();

    int wordIndex = wordIndex(bitIndex);
    return (wordIndex &amp;lt; wordsInUse)
        &amp;amp;&amp;amp; ((words[wordIndex] &amp;amp; (1L &amp;lt;&amp;lt; bitIndex)) != 0);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;urlencode&#34; href=&#34;#urlencode&#34;&gt;&lt;/a&gt;UrlEncode&lt;/h2&gt;

&lt;p&gt;见:http://www.w3.org/TR/html40/appendix/notes.html#non-ascii-chars&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public static String encode(String s, String enc) 
    throws UnsupportedEncodingException {

    boolean needToChange = false;
    StringBuffer out = new StringBuffer(s.length());
    Charset charset;
    CharArrayWriter charArrayWriter = new CharArrayWriter();

    if (enc == null)
        throw new NullPointerException(&amp;quot;charsetName&amp;quot;);

    try {
        charset = Charset.forName(enc);
    } catch (IllegalCharsetNameException e) {
        throw new UnsupportedEncodingException(enc);
    } catch (UnsupportedCharsetException e) {
        throw new UnsupportedEncodingException(enc);
    }

    for (int i = 0; i &amp;lt; s.length();) {
        int c = (int) s.charAt(i);
        //System.out.println(&amp;quot;Examining character: &amp;quot; + c);
        // dontNeedEncoding包含：[a-zA-Z0-9 -_.*]
        if (dontNeedEncoding.get(c)) {
            if (c == &#39; &#39;) {
                c = &#39;+&#39;;
                needToChange = true;
            }
            //System.out.println(&amp;quot;Storing: &amp;quot; + c);
            out.append((char)c);
            i++;
        } else {
        // convert to external encoding before hex conversion
        do {
            charArrayWriter.write(c);
            /*
             * If this character represents the start of a Unicode
             * surrogate pair, then pass in two characters. It&#39;s not
             * clear what should be done if a bytes reserved in the 
             * surrogate pairs range occurs outside of a legal
             * surrogate pair. For now, just treat it as if it were 
             * any other character.
             */
            // 处理一些UTF-16的字符：http://en.wikipedia.org/wiki/UTF-16
            if (c &amp;gt;= 0xD800 &amp;amp;&amp;amp; c &amp;lt;= 0xDBFF) {
            /*
              System.out.println(Integer.toHexString(c) 
              + &amp;quot; is high surrogate&amp;quot;);
            */
            if ( (i+1) &amp;lt; s.length()) {
                int d = (int) s.charAt(i+1);
                /*
                  System.out.println(&amp;quot;\tExamining &amp;quot; 
                  + Integer.toHexString(d));
                */
                if (d &amp;gt;= 0xDC00 &amp;amp;&amp;amp; d &amp;lt;= 0xDFFF) {
                /*
                  System.out.println(&amp;quot;\t&amp;quot; 
                  + Integer.toHexString(d) 
                  + &amp;quot; is low surrogate&amp;quot;);
                */
                    charArrayWriter.write(d);
                i++;
                }
            }
            } 
            i++;
        } while (i &amp;lt; s.length() &amp;amp;&amp;amp; !dontNeedEncoding.get((c = (int) s.charAt(i))));

        charArrayWriter.flush();
        String str = new String(charArrayWriter.toCharArray());
        byte[] ba = str.getBytes(charset);
        for (int j = 0; j &amp;lt; ba.length; j++) {
            out.append(&#39;%&#39;);
            char ch = Character.forDigit((ba[j] &amp;gt;&amp;gt; 4) &amp;amp; 0xF, 16);
            // converting to use uppercase letter as part of
            // the hex value if ch is a letter.
            if (Character.isLetter(ch)) {
            ch -= caseDiff;
            }
            out.append(ch);
            ch = Character.forDigit(ba[j] &amp;amp; 0xF, 16);
            if (Character.isLetter(ch)) {
            ch -= caseDiff;
            }
            out.append(ch);
        }
        charArrayWriter.reset();
        needToChange = true;
        }
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    <item>
      <title>node相关文章积累</title>
      <link>http://defworld.com/2014/11/05/node-articles.html</link>
      <pubDate>2014-11-05 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;node.js某个文件foo.js，直接执行node foo.js会执行main方法，而require(&amp;lsquo;foo&amp;rsquo;)时不会执行：&lt;br /&gt;
&lt;a href=&#34;http://stackoverflow.com/questions/4981891/node-js-equivalent-of-pythons-if-name-main&#34;&gt;《node.js equivalent of python&amp;rsquo;s if &lt;strong&gt;name&lt;/strong&gt; == &amp;lsquo;&lt;strong&gt;main&lt;/strong&gt;&amp;lsquo;》&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>系统环境准备</title>
      <link>http://defworld.com/2014/11/03/system-evn-prepare.html</link>
      <pubDate>2014-11-03 12:00:00 +0800</pubDate>
      <description>&lt;h1&gt;&lt;a style=&#34;display: block;&#34; name=&#34;redhat&#34; href=&#34;#redhat&#34;&gt;&lt;/a&gt;Redhat&lt;/h1&gt;

&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;ruby&#34; href=&#34;#ruby&#34;&gt;&lt;/a&gt;ruby&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;wget &#39;http://curl.haxx.se/ca/cacert.pem&#39;
curl --cacert cacert.pem -sSLk https://get.rvm.io | bash -s stable
source ~/.profile
source ~/.rvm/scripts/rvm
rvm install 1.9.2
rvm use 1.9.2 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;img src=&#34;http://www.cnblogs.com/ainiaa/archive/2011/11/08/2241385.html&#34; alt=&#34;http 使用curl发起https请求&#34; /&gt;&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://ruby-china.org/wiki/install_ruby_guide&#34; alt=&#34;如何快速正确的安装 Ruby, Rails 运行环境&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1&gt;&lt;a style=&#34;display: block;&#34; name=&#34;mac&#34; href=&#34;#mac&#34;&gt;&lt;/a&gt;Mac&lt;/h1&gt;
</description>
    </item>
    <item>
      <title>Node.js Promise/Deferred入门</title>
      <link>http://defworld.com/2014/10/16/node-js-prmoise.html</link>
      <pubDate>2014-10-16 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;Promise/Deffered模式只是解决异步编程的一个模式，我这里一个一个来说吧。&lt;/p&gt;

&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;回调/高阶函数/函数编程&#34; href=&#34;#回调/高阶函数/函数编程&#34;&gt;&lt;/a&gt;回调/高阶函数/函数编程&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;高阶函数&lt;/strong&gt;编程是指，函数可作为参数或返回值。其中&lt;strong&gt;偏函数&lt;/strong&gt;是其中一种应用，举个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;javascript&#34;&gt;// Underscore库提供
// 生成一个需要调用多次才真正执行的函数
_.after = function(times, func) {
    if (times &amp;lt;= 0) return func();
    return function() {
        if (--times &amp;lt; 1) {
            return func.apply(this, arguments);
        }
    } 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;优点&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;多线程编程模型的问题&lt;/li&gt;
&lt;li&gt;很好的处理 I/O 密集型问题&lt;/li&gt;
&lt;li&gt;V8&lt;/li&gt;
&lt;li&gt;调用C/C++扩展模块&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;缺点&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;难点一：异常处理&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;javascript&#34;&gt;// 只能捕获调用async方法的异常，实际执行callback的异常因为是异步执行无法捕获
try {
    async(callback);
} catch (e) {
    // TODO
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Node在处理异常时形成一种约定，将异常作为回调函数的第一个实参传回：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;javascript&#34;&gt;// 如果发生了异常，async方法的实现需要在调用callback时讲err传回
async(function (err, result) {
    // TODO
});
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;难点二：函数嵌套过深&lt;/p&gt;

&lt;p&gt;难点三：阻塞代码&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;因为是单进程，不能像java一样阻塞后续代码的执行。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;难点四：多线程编程&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;浏览器中最终JavaScript执行线程与UI渲染公用一个，为了更好利用多核CPU，提出Web Workders，将JavaScript执行与UI渲染分离，但并没有形成一个标准。Node可以编写多进程代码，充分利用多核CPU。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;异步转同步&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;无法很好的支持需要同步编程的场景。&lt;/p&gt;

&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;事件发布/订阅模式&#34; href=&#34;#事件发布/订阅模式&#34;&gt;&lt;/a&gt;事件发布/订阅模式&lt;/h2&gt;

&lt;p&gt;即回调函数的事件化。&lt;br /&gt;
Node自身提供的events模块，是发布/订阅模式的一个简单实现，Node中部分模块继承自它。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;javascript&#34;&gt;// 下面是Node中Stream对象继承EventEmitter例子。
// Node提供的核心模块中有近半数都继承自EventEmitter。
var events = require(&#39;events&#39;);

function Stream() {
    events.EventEmitter.call(this); // 继承属性
}

util.inherits(Stream, events.EventEmitter); // 继承方法
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;利用事件队列解决雪崩问题&lt;/h3&gt;

&lt;p&gt;比如缓存是失效时，高并发将压力打到后方数据源。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;javascript&#34;&gt;var select = function (callback) {
    db.select(&amp;quot;SQL&amp;quot;, function (result) {
        callback(results);
    });
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;加上状态锁：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;javascript&#34;&gt;var status = &amp;quot;ready&amp;quot;;
var select = function (callback) {
    if (status ==== &#39;ready&#39;) {
        status = &amp;quot;pending&amp;quot;;
        db.select(&amp;quot;SQL&amp;quot;, function (results) {
            status = &amp;quot;ready&amp;quot;;
            callback(results);
        });
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样的调用只有第一次石油结果返回的，其他的调用没有结果。改进下，利用once：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;javascript&#34;&gt;var proxy = new evnets.EvnetEmitter();
vat status = &amp;quot;ready&amp;quot;;
var select = function (callback) {
    // 将请求的事件压入事件队列中，执行一次这个listner就会被移除
    proxy.once(&amp;quot;selected&amp;quot;, callback);
    if (status === &#39;ready&#39;) {
        stauts = &#39;pending&#39;;
        db.select(&amp;quot;SQL&amp;quot;, function (result) {
            proxy.emit(&amp;quot;selected&amp;quot;, results);
            status = &amp;quot;ready&amp;quot;;
        });
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;多异步之间的写作方案（一对多，多对一，多对多）&lt;/h3&gt;

&lt;h3&gt;EventProxy&lt;/h3&gt;

&lt;p&gt;对事件订阅/发布模型的扩充。&lt;/p&gt;

&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;promise/deffered模式&#34; href=&#34;#promise/deffered模式&#34;&gt;&lt;/a&gt;Promise/Deffered模式&lt;/h2&gt;

&lt;p&gt;Prmoise/A提议对单个异步操作做了这样的抽象定义：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Prmoise操作只会处在3中状态的一种：未完成态、完成态何失败态&lt;/li&gt;
&lt;li&gt;Prmoise的状态只会从未完成态向完成态或失败态转化，不能逆反。完成态和失败态不能互相转化。&lt;/li&gt;
&lt;li&gt;Prmoise的状态一旦转化，将不能被更改。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在API的定义上，Prmoise/A提议是比较简单的。一个Prmoise对象只要具备then()方法即可。Deferred对象主要是用于内部，用于维护异步模型的状态;Prmoise则作用域外部，通过then()方法暴露给外部以添加自定义逻辑。将业务不可变的部分封装在Deferred中，将可变的部分交给了Promise。Prmoise是高级接口，事件是低级接口，低级接口可以构成更多复杂的场景。&lt;br /&gt;
下面看一个Node的events模块实现的版本。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;javascript&#34;&gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;流程控制库&#34; href=&#34;#流程控制库&#34;&gt;&lt;/a&gt;流程控制库&lt;/h2&gt;
</description>
    </item>
    <item>
      <title>Node的异步代码怎么写</title>
      <link>http://defworld.com/2014/09/19/node-how-to-write-node-async-code.html</link>
      <pubDate>2014-09-19 12:00:00 +0800</pubDate>
      <description>&lt;h1&gt;&lt;a style=&#34;display: block;&#34; name=&#34;函数式编程&#34; href=&#34;#函数式编程&#34;&gt;&lt;/a&gt;函数式编程&lt;/h1&gt;

&lt;p&gt;函数作为js中的一等公民，可以作为参数或返回值传递，此谓高阶函数。偏函数也是基于此，返回一个函数，但是这个返回的函数一部分已经预置了，举个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;// 一个调用多次才会执行的函数
_.after = function(times, func) {
    if (times &amp;lt;= 0)return func();
    return function() {
        if (--times &amp;lt; 1) {
            return func.apply(this, arguments);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;&lt;a style=&#34;display: block;&#34; name=&#34;异步编程难点&#34; href=&#34;#异步编程难点&#34;&gt;&lt;/a&gt;异步编程难点&lt;/h1&gt;

&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;异常处理&#34; href=&#34;#异常处理&#34;&gt;&lt;/a&gt;异常处理&lt;/h2&gt;

&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;函数嵌套过深&#34; href=&#34;#函数嵌套过深&#34;&gt;&lt;/a&gt;函数嵌套过深&lt;/h2&gt;

&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;阻塞代码&#34; href=&#34;#阻塞代码&#34;&gt;&lt;/a&gt;阻塞代码&lt;/h2&gt;

&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;多线程编程&#34; href=&#34;#多线程编程&#34;&gt;&lt;/a&gt;多线程编程&lt;/h2&gt;

&lt;h1&gt;&lt;a style=&#34;display: block;&#34; name=&#34;异步编程解决方案&#34; href=&#34;#异步编程解决方案&#34;&gt;&lt;/a&gt;异步编程解决方案&lt;/h1&gt;

&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;事件发布订阅模式&#34; href=&#34;#事件发布订阅模式&#34;&gt;&lt;/a&gt;事件发布订阅模式&lt;/h2&gt;

&lt;p&gt;Node自身提供的events模块。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;// 订阅
emitter.on(&amp;quot;event1&amp;quot;, function (message) {
    console.log(message);
});

// 发布
emitter.emit(&#39;event1&#39;, &amp;quot;I am message!&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将事件与具体的处理逻辑解耦，一个时间与多个回调函数关联。从某种角度来说事件的设计就是组件的接口设计。&lt;/p&gt;
</description>
    </item>
    <item>
      <title>聊聊Node.js的异步I/O</title>
      <link>http://defworld.com/2014/09/19/node-js-async-i-o.html</link>
      <pubDate>2014-09-19 12:00:00 +0800</pubDate>
      <description>&lt;h1&gt;&lt;a style=&#34;display: block;&#34; name=&#34;阻塞vs非阻塞，同步vs异步&#34; href=&#34;#阻塞vs非阻塞，同步vs异步&#34;&gt;&lt;/a&gt;阻塞vs非阻塞，同步vs异步&lt;/h1&gt;

&lt;p&gt;阻塞是你做一件事不能立即得到返回，否则是非阻塞。同步是做完一件事，做下一件事，反之异步。&lt;br /&gt;
阻塞非阻塞都是同步，异步就无所谓阻塞非阻塞了。&lt;/p&gt;

&lt;h1&gt;&lt;a style=&#34;display: block;&#34; name=&#34;各种i/o模型&#34; href=&#34;#各种i/o模型&#34;&gt;&lt;/a&gt;各种I/O模型&lt;/h1&gt;

&lt;p&gt;一个输入主要包括两个阶段：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;等待数据到达&lt;/li&gt;
&lt;li&gt;将数据从内核空间拷贝到用户空间&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Blocking I/O model:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://farm6.staticflickr.com/5574/15261520936_c092d571bd.jpg&#34; alt=&#34;Blocking I/O model&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;这里以UDP为例，因为UDP的datagram ready只要一个datagram到了就行了，TCP相对复杂很多。这里我们发现系统层面一个系统调用需要等待1，2都完成后才能返回。&lt;/p&gt;

&lt;p&gt;Nonblocking I/O model:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://farm4.staticflickr.com/3902/15284612605_bc8f5d4653.jpg&#34; alt=&#34;Nonblocking I/O model&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;当我们把一个socket设置为NonBlocking时，recvfrom系统调用就不会使得调用程序sleep，而是立即返回一个EWOULDBLOCK的错误。应用程序需要重复调用recvfrom，直到某次调用datagram ready，然后等待data copy完成再返回。&lt;/p&gt;

&lt;p&gt;I/O multiplexing model:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://farm6.staticflickr.com/5594/15261591366_8e44175e2e.jpg&#34; alt=&#34;I/O multiplexing model&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;跟Blocking I/O不同的是，I/O multiplexing model调用select等待多个socket句柄上，知道其中一个到达datagram ready的状态，程序拿到socket句柄再去调用一次recvfrom做一次copy然后返回。&lt;br /&gt;
多线程加上Blocking I/O也能模拟这种模式，只是一个这种方式是多个线程分别阻塞调用recvfrom，分别等待在一个socket句柄上。&lt;/p&gt;

&lt;p&gt;Signal-Driven I/O model：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://farm4.staticflickr.com/3894/15284215892_56e035732c.jpg&#34; alt=&#34;Signal-Driven I/O model&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;先将socket设置成signal-driven I/O，然后使用系统调用sigaction绑定一个signal handler。然后main loop可以干别的事，一直到datagram ready状态，kernel发出一个信号告知signal handler,可以由signal handler调用recvfrom copy完毕后再通知main loop处理，也可以让main loop调用recvfrom。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://farm3.staticflickr.com/2941/15098054478_83da95610f.jpg&#34; alt=&#34;Asynchronous I/O model&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;等到copy做完了signal才会生成传递给signal hanlder，这是不同于Signal-Driven I/O model的地方。&lt;/p&gt;

&lt;p&gt;最后也可以看出，前四种I/O模式都是阻塞的，因为recvfrom系统调用都被阻塞了，有的两个阶段都被阻塞了，有的只有copy阶段被阻塞了。最后，来看下总的对比图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://farm3.staticflickr.com/2941/15098149637_2a1664950a.jpg&#34; alt=&#34;Comparison of the five I/O models.&#34; /&gt;
&lt;/p&gt;

&lt;h1&gt;&lt;a style=&#34;display: block;&#34; name=&#34;node.js里如何实现async-i/o&#34; href=&#34;#node.js里如何实现async-i/o&#34;&gt;&lt;/a&gt;Node.js里如何实现Async I/O&lt;/h1&gt;

&lt;p&gt;操作系统层面有几种多路复用的api:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;read ： 最原始、性能最低的一种，重复调用来检查I/O的状态&lt;/li&gt;
&lt;li&gt;select：在read基础上的改进方案，通过对文件描述符桑冕的事件状态进行判断。但它此阿勇1024长度的数组来存储状态，最多而已同时检查1024个文件描述符。&lt;/li&gt;
&lt;li&gt;poll：较select有所改进，采用链表方式避免长度限制，避免不需要的检查，但是当文件描述符较多时，性能还是十分低下。&lt;/li&gt;
&lt;li&gt;epoll：Linux下效率最高的I/O事件通知机制，进入轮询时如果么有检查到I/O事件，将会休眠，直到时间发生将它唤醒，它是真实利用了时间通知、执行回调的方式，而不是遍历查询，所以不会兰妃CPU，执行效率高。&lt;/li&gt;
&lt;li&gt;kqueu，与epoll类似，不错仅存在于FreeBSD系统下。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当以上几种方式，应用程序仍需要等待I/O完全返回，等待期间CPU要么遍历文件描述符，要不休眠。&lt;/p&gt;

&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;理想的异步i/o&#34; href=&#34;#理想的异步i/o&#34;&gt;&lt;/a&gt;理想的异步I/O&lt;/h2&gt;

&lt;p&gt;CPU无需轮询何休眠，应用程序可以直接处理下一个任务，直到I/O完成后通过信号或者回调将数据传递给应用程序。&lt;br /&gt;
Linux下的AIO就是这样的模式，通过信号或者回调来传递数据，但仅支持内核I/O中的O_DIRECT方式读取，导致无法利用系统缓存。&lt;/p&gt;

&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;现实的异步i/o&#34; href=&#34;#现实的异步i/o&#34;&gt;&lt;/a&gt;现实的异步I/O&lt;/h2&gt;

&lt;p&gt;通过将逻辑处理和I/O放在不同线程中，可以模拟异步I/O。glibc的AIO是典型的线程池模拟Async I/O，然而有些bug。libev作者实现了一个异步I/O库libeio，也是用线程池与阻塞I/O模拟Async I/O，最初Node在*nix平台下采用了libeio配合libev实现Async I/O，Node v0.0.3中，自行实现了线程池来实现Async I/O。&lt;br /&gt;
Windows下的IOCP也是一个Async I/O，不过内部也是线程池实现的，不同之处在于这些线程池由系统内核接受管理。Node在windos平台下用IOCP实现。&lt;br /&gt;
Node.js -&amp;gt; libuv（抽象层） -&amp;gt; (*nix自定义线程池，Windows IOCP）。&lt;/p&gt;

&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;简单说说node架构的一些概念&#34; href=&#34;#简单说说node架构的一些概念&#34;&gt;&lt;/a&gt;简单说说Node架构的一些概念&lt;/h2&gt;

&lt;p&gt;我们写的js代码实际上是在注册一些事件，Node的单线程实际上就指的是事件循环线程，它向各类事件观察者询问是否有待处理事件，而处理I/O的线程池就是制造事件源。这些观察者被询问的先后顺序是idel观察者，I/O观察者，check观察者。&lt;br /&gt;
Node提供的几个异步调用都是绑定在这些观察者身上的：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;setTimeout()&lt;/code&gt;绑定在定时观察者，不过因为一个Tick(一个事件循环)会占用一定事件，所以不一定准确，加上红黑树去存储定时器对象，资源和性能上不是最好。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;setInterval()&lt;/code&gt;也是绑定在定时观察者，跟setTimeout类似，只是会多次调用&lt;/li&gt;
&lt;li&gt;&lt;code&gt;process.nextTick()&lt;/code&gt;绑定在idel观察者身上，比setTimeout轻量级，存在数组里。每个Tick执行数组里所有的。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;setImmediate()&lt;/code&gt;绑定在check观察者身上，存在链表里，每个Tick只执行第一个。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考：&lt;/p&gt;

&lt;p&gt;《Unix Network Programming Vol1 1002003, 3Ed 6.2 I/O Models》http://english.tebyan.net/newindex.aspx?pid=31159&amp;amp;BookID=23760&amp;amp;PageIndex=92&amp;amp;Language=3&lt;br /&gt;
《怎样理解阻塞非阻塞与同步异步的区别？》http://www.zhihu.com/question/19732473&lt;br /&gt;
《深入浅出Node.js》作者：朴灵&lt;/p&gt;
</description>
    </item>
    <item>
      <title>spring DispatcherServlet &amp; ContextLoaderListener</title>
      <link>http://defworld.com/2014/09/13/spring-dispatcherservlet-and-contextloaderlistener.html</link>
      <pubDate>2014-09-13 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;实际上我们只要知道了servlet config和servlet conext的区别就能清楚spring中的DispatcherServlet和ContextLoaderListener有啥区别了。servlet config是单个servlet维度的，而servlet conext是整个application维度的，一个application可能有多个servlet。&lt;/p&gt;

&lt;p&gt;spring是基于servlet标准的serlvet为中心扩展的一个MVC框架（&lt;a href=&#34;http://webx.github.io/&#34;&gt;webx&lt;/a&gt;以filter为中心扩展的），DispatcherServlet正是这个中心。如下图，Front Controller就是指的DispatchServlet。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://farm4.staticflickr.com/3851/15218580671_18437fa8a9.jpg&#34; alt=&#34;spring mvc&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;所以我们用类似这样的方式指定的实际是DispatchServlet范围内的context:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;xml&#34;&gt;&amp;lt;servlet&amp;gt;
        &amp;lt;servlet-name&amp;gt;dispatcher&amp;lt;/servlet-name&amp;gt;
        &amp;lt;servlet-class&amp;gt;org.springframework.web.servlet.DispatcherServlet&amp;lt;/servlet-class&amp;gt;
        &amp;lt;init-param&amp;gt;
            &amp;lt;param-name&amp;gt;contextConfigLocation&amp;lt;/param-name&amp;gt;
            &amp;lt;param-value&amp;gt;classpath:spring-context.xml&amp;lt;/param-value&amp;gt;
        &amp;lt;/init-param&amp;gt;
        &amp;lt;load-on-startup&amp;gt;1&amp;lt;/load-on-startup&amp;gt;
&amp;lt;/servlet&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而用这样的方式指定的是app范围的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;xml&#34;&gt;&amp;lt;context-param&amp;gt; &amp;lt;!-- context-param配置的只是一个servlet context维度可以拿到的变量而已 --&amp;gt;
    &amp;lt;param-name&amp;gt;contextConfigLocation&amp;lt;/param-name&amp;gt; 
    &amp;lt;param-value&amp;gt;/WEB-INF/applicationContext*.xml&amp;lt;/param-value&amp;gt;
&amp;lt;/context-param&amp;gt;

&amp;lt;listener&amp;gt;&amp;lt;!-- 根据contextConfigLocation指定的配置，初始化spring app context --&amp;gt;
    &amp;lt;listener-class&amp;gt;org.springframework.web.context.ContextLoaderListener&amp;lt;/listener-class&amp;gt;
&amp;lt;/listener&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在代码层面整个过程如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在任何filer和servlet还未初始化时，&lt;code&gt;ServletContextListener#contextInitialized&lt;/code&gt;被容器调用&lt;/li&gt;
&lt;li&gt;而spring提供的&lt;code&gt;ContextLoaderListener&lt;/code&gt;实现了&lt;code&gt;ServletContextListener#contextInitialized&lt;/code&gt;，也正是此时被调用初始化了spring root context&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Servlet#init&lt;/code&gt;在servlet container开始初始化servlet，还没有用它服务第一个request的时候，因为&lt;code&gt;DispatchServlet&lt;/code&gt;实现了&lt;code&gt;FrameworkServlet#initServletBean&lt;/code&gt;，而这个方法就是在此时被调用的。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;FrameworkServlet#initServletBean&lt;/code&gt;主要的工作就是初始化context，详见下面这段代码：&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;protected WebApplicationContext initWebApplicationContext() {
        // 这里会拿到ContextLoaderListener中初始化的root context
        WebApplicationContext rootContext =
                WebApplicationContextUtils.getWebApplicationContext(getServletContext());
        WebApplicationContext wac = null; // 代表当前servlet对应的context

        if (this.webApplicationContext != null) {
            // A context instance was injected at construction time -&amp;gt; use it
            wac = this.webApplicationContext;
            if (wac instanceof ConfigurableWebApplicationContext) {
                ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) wac;
                if (!cwac.isActive()) {
                    // The context has not yet been refreshed -&amp;gt; provide services such as
                    // setting the parent context, setting the application context id, etc
                    if (cwac.getParent() == null) {
                        // The context instance was injected without an explicit parent -&amp;gt; set
                        // the root application context (if any; may be null) as the parent
                        cwac.setParent(rootContext);
                    }
                    configureAndRefreshWebApplicationContext(cwac);
                }
            }
        }
        if (wac == null) {
            // No context instance was injected at construction time -&amp;gt; see if one
            // has been registered in the servlet context. If one exists, it is assumed
            // that the parent context (if any) has already been set and that the
            // user has performed any initialization such as setting the context id
            wac = findWebApplicationContext(); // 这里通过contextAttribute参数指定某个特定的context作为当前servlet的context
        }
        if (wac == null) {
            // No context instance is defined for this servlet -&amp;gt; create a local one
            wac = createWebApplicationContext(rootContext); //  这里通过contextConfigLocation参数指定一个文件初始化当前servlet对应的context
        }

        if (!this.refreshEventReceived) {
            // Either the context is not a ConfigurableApplicationContext with refresh
            // support or the context injected at construction time had already been
            // refreshed -&amp;gt; trigger initial onRefresh manually here.
            onRefresh(wac);
        }

        if (this.publishContext) {
            // Publish the context as a servlet context attribute.
            String attrName = getServletContextAttributeName();
            getServletContext().setAttribute(attrName, wac);
            if (this.logger.isDebugEnabled()) {
                this.logger.debug(&amp;quot;Published WebApplicationContext of servlet &#39;&amp;quot; + getServletName() +
                        &amp;quot;&#39; as ServletContext attribute with name [&amp;quot; + attrName + &amp;quot;]&amp;quot;);
            }
        }

        return wac;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;《spring framework reference 3.2.x》17.2 The DispatcherServlet&lt;/li&gt;
&lt;li&gt;《spring framework reference 3.2.x》5.14 Standard and Custom Events&lt;/li&gt;
&lt;li&gt;《spring framework reference 3.2.x》6.7 Application contexts and Resource paths&lt;/li&gt;
&lt;li&gt;《servlet config servlet context》http://stackoverflow.com/questions/4223564/servlet-config-servlet-context&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    <item>
      <title>笔记 - 关于Java中的Null</title>
      <link>http://defworld.com/2014/09/12/java-null-note.html</link>
      <pubDate>2014-09-12 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;有人说写出NPE，是程序员的逻辑错误，我们在做code review的时候也经常提醒或者被提醒这一点，殊不知这个坑真的太容易踩了。但是如果你不辞辛劳的判断Null，你会发现你的代码变成一坨奇怪的形状，就像脸蛋白皙五官精致的姑娘被各种乱涂乱画。下面大家看看这个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;computer.getSoundCard().getUsb().getVersion();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们很容易被吐槽（博主经常被测试妹子吐槽这里这里检查了NPE了么），一个电脑肯定有声卡么，声卡肯定有usa插口么？然后代码变成了这样：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;if (computer != null) {
    SoundCard sc = computer.getSoundcard();
    if (sc != null) {
        Usb usb = sc.getUsb();
        if (usab != null) {
            return usb.getVersion();
        } else {
            return null;
        }      
    } else {
        return null;
    }
} else {
    return null;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有人说你这么写太夸张了，不是可以精简一下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;if (computer != null &amp;amp;&amp;amp; computer.getSoundCard() != null &amp;amp;&amp;amp; computer.getSoundCard().getUsb() != null) {
    return computer.getSoundCard().getUsb().getVersion();
} else {
    return null;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们来对比下这种情况其他语言和工具是怎么写的：&lt;br /&gt;
groovy用语言级别支持的?处理清晰简洁：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;Groovy&#34;&gt;String version = computer?.getSoundcard()?.getUsb()?.getVersion();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Guava框架用自定义的Optional&lt;T&gt;对象：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;Optional&amp;lt;Computer&amp;gt; maybeComputer = Optional.of(computer); // 如果此处computer为null，将跑出NPE，可用Optional.fromNullable(T)允许传入Null表示缺失
if (maybeComputer.isPresent()) { // 这里只有present/absent两种状态，present时就拿到的对象就肯定不为null
    maybeComputer.getSoundCard();
}
// ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Java8：&lt;br /&gt;
简单解释下下面代码，&lt;code&gt;maybeSoundcard.orElse(new Soundcard(&amp;quot;defaut&amp;quot;))&lt;/code&gt;等价于&lt;code&gt;soundcard != null ? soundcard : new Soundcard(&amp;quot;basic_sound_card&amp;quot;)&lt;/code&gt;，&lt;code&gt;maybeSoundcard.map(Soundcard::getUSB)&lt;/code&gt;等价于&lt;code&gt;soundcard != null ? souncard.getUSB() : null&lt;/code&gt;，而&lt;code&gt;Computer::getSoundcard&lt;/code&gt;是Lambdas写法。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;String name = computer.flatMap(Computer::getSoundcard)
                          .flatMap(Soundcard::getUSB)
                          .map(USB::getVersion)
                          .orElse(&amp;quot;UNKNOWN&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;总结一下，Map中get一个值返回Null有可能表示缺失也可能表示存在且值就为Null，而Guava Optional&lt;T&gt;强制提醒开发者需要去关注是否null，从而去避免NPE引起执行流程的异常甚至整个程序中断，它里面其他一些工具一定程度上简化了各种判断和默认值的书写，但还不够彻底。使用java8的Optional&lt;T&gt;加Lambdas加Streams的写法，在Guava基础上做的更加彻底，但比Groovy这种语言级别的支持略显笨重。&lt;br /&gt;
建议先在框架的某个层面（比如控制层）把所有NPE处理掉，不要往下层流，尤其是在多个模块甚至多个系统之间交互的时候，最好能够一方处理掉这个，最起码保证另一方怎么写代码都不会跑NPE。其次才是用Optional&lt;T&gt;这样的工具来处理。最次是在接口doc上写清楚可能为null的情况。&lt;/p&gt;

&lt;p&gt;参考：&lt;/p&gt;

&lt;p&gt;*《Tired of Null Pointer Exceptions? Consider Using Java SE 8&amp;rsquo;s Optional!》http://www.oracle.com/technetwork/articles/java/java8-optional-2175753.html&lt;br /&gt;
*《避免Java中的空对象检查》http://it.deepinmind.com/java/&lt;sup&gt;2014&lt;/sup&gt;&amp;frasl;&lt;sub&gt;08&lt;/sub&gt;/08/avoiding-null-checks-in-java.html&lt;br /&gt;
*《[Google Guava] 1.1-使用和避免null》http://ifeve.com/google-guava-using-and-avoiding-null/&lt;br /&gt;
* 《Java中避免NPE的一些方法》http://segmentfault.com/a/1190000002477715&lt;/p&gt;
</description>
    </item>
    <item>
      <title>js入门笔记（四）—— 工具</title>
      <link>http://defworld.com/2014/09/03/node-js-4-tools.html</link>
      <pubDate>2014-09-03 12:00:00 +0800</pubDate>
      <description>&lt;h1&gt;&lt;a style=&#34;display: block;&#34; name=&#34;[grunt](http://gruntjs.com/getting-started)&#34; href=&#34;#[grunt](http://gruntjs.com/getting-started)&#34;&gt;&lt;/a&gt;&lt;a href=&#34;http://gruntjs.com/getting-started&#34;&gt;grunt&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;grunt是javascript的任务运行器。&lt;/p&gt;

&lt;h1&gt;&lt;a style=&#34;display: block;&#34; name=&#34;[npm](https://www.npmjs.org/)&#34; href=&#34;#[npm](https://www.npmjs.org/)&#34;&gt;&lt;/a&gt;&lt;a href=&#34;https://www.npmjs.org/&#34;&gt;npm&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;npm是node.js的包管理器。&lt;/p&gt;

&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;常用命令&#34; href=&#34;#常用命令&#34;&gt;&lt;/a&gt;常用命令&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;npm install&lt;/code&gt;在&lt;code&gt;package.json&lt;/code&gt;文件存在的目录执行，安装响应的依赖&lt;/li&gt;
&lt;li&gt;&lt;code&gt;npm install grunt --save-dev&lt;/code&gt;将grunt的最新版本安装到工程目录，并在devDependencies中添加&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;版本描述定义&#34; href=&#34;#版本描述定义&#34;&gt;&lt;/a&gt;版本描述定义&lt;/h2&gt;

&lt;p&gt;参见&lt;a href=&#34;https://www.npmjs.org/doc/misc/semver.html&#34;&gt;semver&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;npmrc&#34; href=&#34;#npmrc&#34;&gt;&lt;/a&gt;npmrc&lt;/h2&gt;

&lt;p&gt;参见&lt;a href=&#34;https://www.npmjs.org/doc/files/npmrc.html&#34;&gt;npmrc&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;依赖管理&#34; href=&#34;#依赖管理&#34;&gt;&lt;/a&gt;依赖管理&lt;/h2&gt;

&lt;p&gt;待补充&lt;/p&gt;
</description>
    </item>
    <item>
      <title>黄山团队三日游</title>
      <link>http://defworld.com/2014/08/10/huangshan.html</link>
      <pubDate>2014-08-10 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;主题 - 黄山&lt;/p&gt;

&lt;p&gt;黄山主要的路线就是两条，前山山后山下，后山上前山下。考虑到是团队出游，且还有没有可能还有小孩，我们主路线是：后山徒步上（后山较平缓），前山下，且前山下到玉屏楼走玉屏索道缆车下山。有妇女儿童体力欠缺者建议后山也是走云谷新索道缆车到白鹅岭再行步行。主要的时间安排是第一天早上坐车中午到黄山，下午晚上住在山脚，会准备三国杀和狼人杀。第二天早上开始登山，全天登山，晚上住光明顶，第三天从前山下。详细安排是：&lt;/p&gt;

&lt;h1&gt;&lt;a style=&#34;display: block;&#34; name=&#34;详细规划&#34; href=&#34;#详细规划&#34;&gt;&lt;/a&gt;详细规划&lt;/h1&gt;

&lt;h3&gt;D1上午，杭州 -&amp;gt; 黄山景区换乘中心&lt;/h3&gt;

&lt;p&gt;早上9点阿里巴巴西溪园区发车。&lt;br /&gt;
从杭州坐汽车或者包车到黄山景区（看映容是否能包到车）大约4h，找一户农家吃午饭。下午下榻旁边的中泰大酒店，下午可以在酒店打牌，也可去后山泡温泉。&lt;/p&gt;

&lt;h3&gt;D2，云谷寺 -&amp;gt; 白鹅岭 -&amp;gt; 光明顶-&amp;gt;西海大峡谷-&amp;gt;光明顶&lt;/h3&gt;

&lt;p&gt;先从换乘中心坐车到云谷寺，大约30min。&lt;br /&gt;
从云谷寺开始就是登山的起点，山顶为光明顶。可以有几种选择，全程步行登顶或者坐缆车，是否去西海大峡谷，都是可选的，大家可根据自己体力酌情考虑。&lt;br /&gt;
云谷寺到白鹅岭6.5km，步行3小时左右，腿力好的2.5之内应该可以搞定。&lt;br /&gt;
从白鹅岭至光明顶至光明顶至光明顶，要2~3h，只能步行。&lt;br /&gt;
光明顶去西海大峡谷，下山3~4h，上山4~5h，上山可选择坐缆车。&lt;br /&gt;
一路云海天梯美女帅哥欢歌笑语不再多说。&lt;/p&gt;

&lt;h3&gt;D2晚上，光明顶，星空 + (帐篷 / 白云宾馆)&lt;/h3&gt;

&lt;p&gt;当时的黄山的温度应该在10多度的样子，如果是帐篷建议自带棉睡袋（租的你懂的）。&lt;br /&gt;
如果是好天气，晚上11点之后的星空绝对不能错过哦，超赞。&lt;br /&gt;
鉴于一个西红柿炒蛋60RMB，我会准备干粮（当然要分散给大家来背，嘿嘿），如果有需要吃饭到时候再协商安排。&lt;/p&gt;

&lt;h3&gt;D3 光明顶日出 -&amp;gt; 玉屏楼 -&amp;gt; 前山入口慈光阁 -&amp;gt; 黄山景区换乘中心-&amp;gt;杭州&lt;/h3&gt;

&lt;p&gt;日出在5点40左右，如果要占据有利位置，最好3点就能起床。&lt;br /&gt;
回去睡个回笼觉后，9点左右出发下山。这部分又分两拨，一部分人可以下到玉屏楼，走玉屏索道坐缆车下山，然后乘坐专用公交出景区，可以先去晚上下榻的宾馆打牌游戏或者自行其他安排，这拨人午饭自行安排，并注意留下发票。一拨人人全程下山，大约4小时左右，下山后去换乘中心吃午饭，下午3点左右坐大巴回杭州。&lt;/p&gt;

&lt;h1&gt;&lt;a style=&#34;display: block;&#34; name=&#34;重要提醒和温馨提示&#34; href=&#34;#重要提醒和温馨提示&#34;&gt;&lt;/a&gt;重要提醒和温馨提示&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;索道都是现场购票&lt;/li&gt;
&lt;li&gt;光明顶宾馆和山下宾馆提前预定，租帐篷和吃饭等不预定&lt;/li&gt;
&lt;li&gt;每个人手头至少准备500元现金，我会准备多点以备公共支出和其他情况&lt;/li&gt;
&lt;li&gt;如果住帐篷，需要购置防潮垫、帐篷、棉睡袋（是否购买气垫可自行决定）&lt;/li&gt;
&lt;li&gt;尽量穿鞋底有纹路的鞋，摩擦力大，黄山还是比较陡的&lt;/li&gt;
&lt;li&gt;零食我们会帮大家准备一些基本的方便面饼干，大家也可以自己再带一点，不过不要太多太重，毕竟要背上去，大家必须要自己准备水&lt;/li&gt;
&lt;li&gt;准备厚衣服，气温在10~15度&lt;/li&gt;
&lt;li&gt;周五早上9点公司集合&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考：&lt;br /&gt;
《三上黄山-完美黄山深度游路线（2013）》http://www.mafengwo.cn/i/2931907.html&lt;br /&gt;
《黄山换乘中心百度百科》http://baike.baidu.com/view/6991144.htm?fr=aladdin&lt;br /&gt;
《中泰大酒店美团链接》http://www.meituan.com/deal/25143324.html?mtt=1.deal%2Fdefault.do.1.hyzbnmy5#business-info&lt;/p&gt;
</description>
    </item>
    <item>
      <title>压力测试小结 - 工具</title>
      <link>http://defworld.com/2014/08/08/load-test-1.html</link>
      <pubDate>2014-08-08 12:00:00 +0800</pubDate>
      <description>&lt;h1&gt;&lt;a style=&#34;display: block;&#34; name=&#34;工具&#34; href=&#34;#工具&#34;&gt;&lt;/a&gt;工具&lt;/h1&gt;

&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;top&#34; href=&#34;#top&#34;&gt;&lt;/a&gt;top&lt;/h2&gt;

&lt;p&gt;可以显示的以下信息：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;cpu

&lt;ul&gt;
&lt;li&gt;us 用户占用&lt;/li&gt;
&lt;li&gt;sy 内核占用&lt;/li&gt;
&lt;li&gt;ni 改变过优先级的进程占用百分比&lt;/li&gt;
&lt;li&gt;id 空闲&lt;/li&gt;
&lt;li&gt;wa i/o等待占用&lt;/li&gt;
&lt;li&gt;hi 硬中断（Hardware IRQ）占用&lt;/li&gt;
&lt;li&gt;si 软中断（Software Interrupts）占用&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;各进程的详细状态

&lt;ul&gt;
&lt;li&gt;PID&lt;/li&gt;
&lt;li&gt;USER&lt;/li&gt;
&lt;li&gt;PR 进程优先级&lt;/li&gt;
&lt;li&gt;NI nice值，优先级，值越小优先级越高&lt;/li&gt;
&lt;li&gt;VIRT 进程使用的虚拟内存总量，单位KB，VIRT=SWAP+RES&lt;/li&gt;
&lt;li&gt;RES 进程使用的、未被换出的物理内存大小，单位KB，RES=CODE+DATA&lt;/li&gt;
&lt;li&gt;SHR 共享内存大小，单位KB&lt;/li&gt;
&lt;li&gt;S 进程状态。D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程&lt;/li&gt;
&lt;li&gt;%CPU 上次更新到现在的CPU时间占用百分比&lt;/li&gt;
&lt;li&gt;%MEM — 进程使用的物理内存百分比&lt;/li&gt;
&lt;li&gt;TIME+ — 进程使用的CPU时间总计，单位1/100秒&lt;/li&gt;
&lt;li&gt;COMMAND&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;可以控制：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;显示完整的命名&lt;/li&gt;
&lt;li&gt;指定用户名&lt;/li&gt;
&lt;li&gt;指定进程&lt;/li&gt;
&lt;li&gt;默认按照CPU占用排序，可以改变排序项&lt;/li&gt;
&lt;li&gt;top命令执行过程中有些交互命令可以使用&lt;/li&gt;
&lt;li&gt;可将当前的配置写入~/.toprc文件中&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;vmstat&#34; href=&#34;#vmstat&#34;&gt;&lt;/a&gt;vmstat&lt;/h2&gt;

&lt;p&gt;定时统计系统指标。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;r 表示运行队列(就是说多少个进程真的分配到CPU)&lt;/li&gt;
&lt;li&gt;b 阻塞进程数&lt;/li&gt;
&lt;li&gt;swpd 虚拟内存使用&lt;/li&gt;
&lt;li&gt;free 空闲物理内存大小&lt;/li&gt;
&lt;li&gt;buff Linux/Unix系统是用来存储，目录里面有什么内容，权限等的缓存&lt;/li&gt;
&lt;li&gt;cache 直接用来记忆我们打开的文件,给文件做缓冲&lt;/li&gt;
&lt;li&gt;si 每秒从磁盘读入虚拟内存的大小&lt;/li&gt;
&lt;li&gt;so 每秒虚拟内存写入磁盘的大小&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;lsof&#34; href=&#34;#lsof&#34;&gt;&lt;/a&gt;lsof&lt;/h2&gt;

&lt;p&gt;查看文件系统打开文件状况。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;COMMAND：进程的名称
PID：进程标识符
USER：进程所有者
FD：文件描述符，应用程序通过文件描述符识别该文件。如cwd、txt等
TYPE：文件类型，如DIR、REG等
DEVICE：指定磁盘的名称
SIZE：文件的大小
NODE：索引节点（文件在磁盘上的标识）
NAME：打开文件的确切名称
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;lsof  filename 显示打开指定文件的所有进程
lsof -c string   显示COMMAND列中包含指定字符的进程所有打开的文件
lsof -u username  显示所属user进程打开的文件
lsof +d /DIR/ 显示目录下被进程打开的文件
lsof +D /DIR/ 同上，但是会搜索目录下的所有目录，时间相对较长
lsof -d FD 显示指定文件描述符的进程
lsof -i 用以显示符合条件的进程情况
lsof -i[46] [protocol][@hostname|hostaddr][:service|port]
            46 --&amp;gt; IPv4 or IPv6
            protocol --&amp;gt; TCP or UDP
            hostname --&amp;gt; Internet host name
            hostaddr --&amp;gt; IPv4地址
            service --&amp;gt; /etc/service中的 service name (可以不只一个)
            port --&amp;gt; 端口号 (可以不只一个)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果一个文件还处于被一个进程打开的状态，即使被删除也可以被回复，原理是/proc/pid/..目录实际上对应一个进程在内存中对应的空间，我们可以从这里看到缓存在内存中的数据。&lt;/p&gt;

&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;iostat&#34; href=&#34;#iostat&#34;&gt;&lt;/a&gt;iostat&lt;/h2&gt;

&lt;p&gt;《iostat来对linux硬盘IO性能进行了解》http://www.php-oa.com/&lt;sup&gt;2009&lt;/sup&gt;&amp;frasl;&lt;sub&gt;02&lt;/sub&gt;/03/iostat.html&lt;br /&gt;
《通过IOStat命令监控IO性能》http://huoding.com/&lt;sup&gt;2011&lt;/sup&gt;&amp;frasl;&lt;sub&gt;07&lt;/sub&gt;/&lt;sup&gt;13&lt;/sup&gt;&amp;frasl;&lt;sub&gt;91&lt;/sub&gt;&lt;br /&gt;
《用iostat分析fio性能问题》http://www.atatech.org/articles/14188&lt;/p&gt;

&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;strace&#34; href=&#34;#strace&#34;&gt;&lt;/a&gt;strace&lt;/h2&gt;

&lt;p&gt;用来跟踪所有的系统调用和时间。可以做以下几件事：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;看系统打开了那些文件&lt;/li&gt;
&lt;li&gt;统计一个时间段内正在运行的程序的system call状态&lt;/li&gt;
&lt;li&gt;跟踪一个服务器连接不上的原因&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;systemtamp&#34; href=&#34;#systemtamp&#34;&gt;&lt;/a&gt;systemtamp&lt;/h2&gt;

&lt;p&gt;一开始需要监控内核程序运行状态，需要开发人员在内核源代码中加入调试代码，然后重新编译安装内核，整个过程繁琐困难。之后Kprobe机制，不需要重新编译内核，即可加入调试信息。systemtamp封装了Kprobe，提供了更易用的api。&lt;br /&gt;
不只是可以知道所有内核调用的状态，还可以知道用户空间的一些动作。&lt;/p&gt;

&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;火焰图&#34; href=&#34;#火焰图&#34;&gt;&lt;/a&gt;火焰图&lt;/h2&gt;

&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;tsar&#34; href=&#34;#tsar&#34;&gt;&lt;/a&gt;tsar&lt;/h2&gt;

&lt;h1&gt;&lt;a style=&#34;display: block;&#34; name=&#34;实战例子&#34; href=&#34;#实战例子&#34;&gt;&lt;/a&gt;实战例子&lt;/h1&gt;

&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;磁盘写入/读取速度上限是多少？&#34; href=&#34;#磁盘写入/读取速度上限是多少？&#34;&gt;&lt;/a&gt;磁盘写入/读取速度上限是多少？&lt;/h2&gt;

&lt;h3&gt;用dd命令来测试读写速度&lt;/h3&gt;

&lt;p&gt;dd命令：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;if=FILE read from FILE instead of stdin&lt;/li&gt;
&lt;li&gt;of=FILE writ to FILE instead of stdout&lt;/li&gt;
&lt;li&gt;bs=BYTES force ibs=BYTES and obs=BYTES&lt;/li&gt;
&lt;li&gt;ibs=BYTES read BYTES bytes at a time，即一次读入缓冲区的字节数&lt;/li&gt;

&lt;li&gt;&lt;p&gt;obs=BYTES write BYTES bytes at a time，即一次写入缓冲区的字节数&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;测试/目录所在磁盘的纯写速度&lt;code&gt;sudo time dd if=/dev/zero bs=1024 count=1000000 of=/1Gb.file conv=fdatasync&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;没有加conv=fdatasync实际上只是将数据读入读缓冲中，并不是最终全部写到磁盘的速度。
加上oflag=dsync每次读入bs=1024byte大小的数据，都会写到磁盘，也就是说写缓冲区没起作用。
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;测/目录所在磁盘的纯读速度：&lt;code&gt;dd if=/kvm/ftp/other/1Gb.file bs=64k |dd of=/dev/null&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;测读写速度：&lt;code&gt;sudo dd -if=/1Gb.file of/1Gb.file.bak bs=64K&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;用hdparm测磁盘读写速度&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;hdparm -T /dev/sda&lt;/code&gt;测试磁盘缓存读写速度，不走device本身&lt;/li&gt;
&lt;li&gt;&lt;code&gt;hdparm -t /dev/sda&lt;/code&gt;测试磁盘的本身读写速度&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;根据接口和硬件指标判断读写速度&lt;/h3&gt;

&lt;p&gt;从以下一点看读写速度：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;接口：一开始是ATA 133MB/s，升级为SATA 1.0 150MB/s ，SATA 2.0 300MB/s，SATA 3.0 600MB/s。
2.磁盘转速：普通5400转的hdd读写速度一般在70-80MBs，普通7200转的hdd读写速度大概在100-120M/s，而普通ssd的读速度有400-500MB/s，写入速度也有200MB/s。加上正常情况下的读写是随即读写，如果需要读取的内容或者写入的地方相隔较远，磁头花在寻道（锁定磁道约4ms）、平均延时（找到磁道上某个位置约2ms）的时间会很夸张。&lt;/li&gt;
&lt;li&gt;SSD读写速度不均&lt;/li&gt;
&lt;/ol&gt;

&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;linux如何知道文件被哪个进程写？&#34; href=&#34;#linux如何知道文件被哪个进程写？&#34;&gt;&lt;/a&gt;linux如何知道文件被哪个进程写？&lt;/h2&gt;

&lt;p&gt;参考：&lt;br /&gt;
《每天一个linux命令（44）：top命令》http://www.cnblogs.com/peida/archive/&lt;sup&gt;2012&lt;/sup&gt;&amp;frasl;&lt;sub&gt;12&lt;/sub&gt;/&lt;sup&gt;24&lt;/sup&gt;&amp;frasl;&lt;sub&gt;2831353&lt;/sub&gt;.html&lt;br /&gt;
《 计算机中断/硬中断/软中断之理解(1)》http://blog.csdn.net/pxz_002/article/details/7327668&lt;br /&gt;
《Linux vmstat命令实战详解》http://www.cnblogs.com/ggjucheng/archive/&lt;sup&gt;2012&lt;/sup&gt;&amp;frasl;&lt;sub&gt;01&lt;/sub&gt;/05/2312625.html&lt;br /&gt;
《正确用DD测试磁盘读写速度》http://blog.csdn.net/xrb66/article/details/7180919&lt;br /&gt;
《Linux利用dd测试读取/写入磁盘速度》http://www.tsingpost.com/articles/&lt;sup&gt;201401&lt;/sup&gt;&amp;frasl;&lt;sub&gt;344&lt;/sub&gt;.html&lt;br /&gt;
《mac下的改装人生——关于ssd》http://www.cnblogs.com/wisejoker/p/3399828.html&lt;br /&gt;
《SATA百科》http://zh.wikipedia.org/wiki/SATA&lt;br /&gt;
《（总结）Linux的hdparm工具参数详解：硬盘检查、测速、设定、优化 》 &lt;a href=&#34;http://blog.chinaunix.net/uid-22823163-id-3294012.html&#34;&gt;http://blog.chinaunix.net/uid-22823163-id-3294012.html&lt;/a&gt;&lt;br /&gt;
《硬盘原理与IO吞吐量计算》http://www.cnblogs.com/netflu/archive/&lt;sup&gt;2010&lt;/sup&gt;&amp;frasl;&lt;sub&gt;01&lt;/sub&gt;/&lt;sup&gt;19&lt;/sup&gt;&amp;frasl;&lt;sub&gt;1651519&lt;/sub&gt;.html&lt;br /&gt;
《linux lsof详解》http://blog.csdn.net/guoguo1980/article/details/2324454&lt;br /&gt;
《5 simple ways to troubleshoot using Strace》http://www.hokstad.com/5-simple-ways-to-troubleshoot-using-strace&lt;br /&gt;
《内核探测工具systemtap简介》http://www.cnblogs.com/hazir/p/systemtap_introduction.html
《systemtap官网》http://sourceware.org/systemtap/&lt;br /&gt;
《如何统计lua每个函数的执行时间占比》https://groups.google.com/forum/#!topic/openresty/bOwgPymXQzg&lt;br /&gt;
《春哥的nginx systemtap工具集》https://github.com/openresty/nginx-systemtap-toolkit#sample-bt&lt;br /&gt;
《ata systemtap资源》http://www.atatech.org/search?q=systemtap&lt;/p&gt;
</description>
    </item>
    <item>
      <title>压力测试 - 关注那些点</title>
      <link>http://defworld.com/2014/08/08/load-test-3.html</link>
      <pubDate>2014-08-08 12:00:00 +0800</pubDate>
      <description>&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;jvm&#34; href=&#34;#jvm&#34;&gt;&lt;/a&gt;jvm&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;a. 启动参数
b. gc
c. 关闭即时编译
d. 启动加载问题
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;nginx&#34; href=&#34;#nginx&#34;&gt;&lt;/a&gt;nginx&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;磁盘I/O是阻塞的&lt;/li&gt;
&lt;li&gt;CPU Affinity&lt;/li&gt;
&lt;li&gt;Keep Alive&lt;/li&gt;
&lt;li&gt;tcp_nodelay and tcp_nopush&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;系统层面&#34; href=&#34;#系统层面&#34;&gt;&lt;/a&gt;系统层面&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;cpu&lt;/li&gt;
&lt;li&gt;mem&lt;/li&gt;
&lt;li&gt;I/O&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;java代码层面&#34; href=&#34;#java代码层面&#34;&gt;&lt;/a&gt;java代码层面&lt;/h2&gt;
</description>
    </item>
    <item>
      <title>js入门笔记（三）</title>
      <link>http://defworld.com/2014/06/15/notes-js-3.html</link>
      <pubDate>2014-06-15 12:00:00 +0800</pubDate>
      <description>&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;利用`__definegetter__``__definesetter__`定义get/set方法，并且注意下js没有块作用域的问题&#34; href=&#34;#利用`__definegetter__``__definesetter__`定义get/set方法，并且注意下js没有块作用域的问题&#34;&gt;&lt;/a&gt;利用&lt;code&gt;__defineGetter__&lt;/code&gt;&lt;code&gt;__defineSetter__&lt;/code&gt;定义get/set方法，并且注意下js没有块作用域的问题&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;// 错误的写法
var Record = function(data) {
  this.fieldValues = {}
  this._data = data;
  var record = this;
  for(var key in data) {
    record.__defineGetter__(key, function() {
      return record._data[key];
    });
    record.__defineSetter__(key, function(val) {
      record.fieldValues[key] = val; // 因为key是全局变量，对data对象遍历时，最终key为prop2
    });
  }
}

var myRecord = new Record({prop1: &#39;prop1test&#39;, prop2: &#39;prop2test&#39;});

myRecord.prop1 = &#39;newvalue&#39;;

console.log(myRecord.fieldValues.prop1); // undefined
console.log(myRecord.fieldValues.prop2); // &#39;newvalue&#39;

// 正确的写法
var Record = function(data) {
    var key;
    this.fieldValues = {}
    this._data = data;
    for(key in data) {
        //closure maintains state of &amp;quot;key&amp;quot; variable
        //without being overwritten each iteration
        (function (record, key) { // 把key变成局部对象，函数内部的使用将不会随着外部key变量的指向而改变
            record.__defineGetter__(key, function() {
                return record._data[key];
            });
            record.__defineSetter__(key, function(val) {
                record.fieldValues[key] = val;
            });
        }(this, key));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考:&lt;br /&gt;
&lt;a href=&#34;http://stackoverflow.com/questions/10453725/weird-behavior-with-javascript-getter-setters&#34;&gt;Weird behavior with Javascript getter/setters&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>js入门笔记（二）——面向对象</title>
      <link>http://defworld.com/2014/06/13/notes-js-2-object.html</link>
      <pubDate>2014-06-13 12:00:00 +0800</pubDate>
      <description>&lt;h1&gt;&lt;a style=&#34;display: block;&#34; name=&#34;直接创建一个对象&#34; href=&#34;#直接创建一个对象&#34;&gt;&lt;/a&gt;直接创建一个对象&lt;/h1&gt;

&lt;p&gt;ECMA-262把对象定义为&lt;code&gt;无序属性的结合，其属性可包含基本值、对象或者函数&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;创建自定义对象方式一——创建一个Object实例&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;var person = new Object();
person.name = &#39;tiemie&#39;;
person.age = 29;

person.sayName = function() {
    alert(this.name);
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;早期用这种方式创建对象，不过后来被方式二替代了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;方式二——对象字面量&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;var person = {
    name: &#39;tiemei&#39;,
    age: 29,

    sayName: function() {
        alert(this.name);
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;对象属性&lt;/h3&gt;

&lt;p&gt;ECMAScript定义对象上有两种属性：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;数据属性

&lt;ul&gt;
&lt;li&gt;[[Configurable]]，默认true，表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，能否把属性修改为访问器属性&lt;/li&gt;
&lt;li&gt;[[Enumerable]]，默认true，能否通过for-in循环返回属性&lt;/li&gt;
&lt;li&gt;[[Writable]]，默认true，能否修改属性的值&lt;/li&gt;
&lt;li&gt;[[Value]]，默认值undefined，这个属性的数据值&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;访问器属性

&lt;ul&gt;
&lt;li&gt;[[Configurable]]，默认true，能否通过delete删除属性从而重新定义属性，能否修改属性的特性，能否把属性修改为数据属性&lt;/li&gt;
&lt;li&gt;[[Enumerable]]，默认true，能否通过for-in循环返回属性&lt;/li&gt;
&lt;li&gt;[[Get]]，默认undefined，在读取属性时调用的函数&lt;/li&gt;
&lt;li&gt;[[Set]]，默认undefined，在写入属性时调用的函数&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;上面定义的person对象name属性，前三个数据属性都是true，[[Value]]为&amp;rsquo;tiemei&amp;rsquo;。ECMAScript5可通过&lt;code&gt;defineProperty&lt;/code&gt;可修改属性：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;// 修改数据属性
var person = {};
Object.defineProperty(person, &amp;quot;name&amp;quot;, {
    configurable: false,
    value: &#39;tiemei&#39;
});

// 修改访问器属性
var bool = {
    _year: 2004 // 前置下划线，表示只能通过对象方法访问的属性
};
Object.defineProperty(book, &amp;quot;year&amp;quot;, {
    get: function() {
        return this._year;
    };
    set: function(newValue) {
        this._year = newValue;
    };
});
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;也可通过&lt;code&gt;Object.defineProperties&lt;/code&gt;一次定义多个属性。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;也可通过&lt;code&gt;Object.getOwnPropertyDescriptor&lt;/code&gt;读取属性特性。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1&gt;&lt;a style=&#34;display: block;&#34; name=&#34;先定义后创建对象&#34; href=&#34;#先定义后创建对象&#34;&gt;&lt;/a&gt;先定义后创建对象&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;工厂模式&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function createPerson(name, age) {
    var o = new Object();
    o.name = name;
    o.age = age;

    o.sayName = function() {
        alert(this.name);
    };
    return o;
};

var p1 = createPerson(&#39;tiemei&#39;, 25);
var p2 = createPerson(&#39;ll&#39;, 25);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;缺点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;无法知道一个对象的类型&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;构造函数模式&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;function Person(name, age) {
    this.name = name;
    this.age = age;

    this.sayName = function() {
        alert(this.name);
    };
};

var p1 = new Person(&#39;tiemei&#39;, 25);
var p2 = new Person(&#39;tiemei&#39;, 25);

// 虽然constructor属性也可用来标识对象类型，但是还是建议用instanceof来判断
alert(p1.constructor == Person); // true
alert(p2.constructor == Person); // true

// 构造函数与其他函数的唯一区别，就在于调用它们的方式不同。
// 任何函数只要通过new操作符调用，那它就可作为构造函数；而任何函数不通过new操作符调用跟普通函数就没啥区别
Person(&#39;tiemie&#39;, 25); // 此时this对象就是外部环境变量

var o = new Object();
Person.call(o, &#39;tiemei2&#39;, 25); // 在另一个对象作用域中调用
o.sayName(); // tiemei2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上创建对象的方式实际上经历：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;创建一个新对象&lt;/li&gt;
&lt;li&gt;将构造函数的作用域赋给新对象（因此this就指向了这个新对象）&lt;/li&gt;
&lt;li&gt;执行构造函数中的代码（为这个新对象添加属性）&lt;/li&gt;
&lt;li&gt;返回新对象&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;缺点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;每个方法都要在每个对象上重新创建一遍，没有必要&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;构造函数的进化模式&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;function Person(name, age) {
    this.name = name;
    this.age = age;

    this.sayName = sayName;
};

// 这种方式创建的函数，在源码之前也可以使用。
// new Function()创建的则不行
function sayName() {
    alert(this.name);
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;缺点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在全局作用域中定义的函数实际上只能被某个对象调用，这让全局作用域名不副实&lt;/li&gt;
&lt;li&gt;没有封装性可言&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;原型模式&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;functino Person() {};

Person.prototype.name = &#39;timei&#39;;
Person.prototype.age = 25;
Person.prototype.sayName = function() {
    alert(this.name);
};

// p1, p2公用name, age, sayName
var p1 = new Person();
var p2 = new Person();
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;p1包含一个指向构造函数的原型对象（见《JavaScript高级程序设计（第2版）》P148）。每当代码读取某个对象的某个属性时，执行一次搜索。从&lt;code&gt;对象实例&lt;/code&gt;本身，到指向的&lt;code&gt;原型对象&lt;/code&gt;。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;不能通过对象实例重写原型中的值，添加一个属性，实际上在该实例对象中添加了一个同名属性。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;obj.hasOwnProperty()&lt;/code&gt;可以检测一个属性是否存在于实例中&lt;/li&gt;
&lt;li&gt;&lt;code&gt;in&lt;/code&gt;操作符会在通过对象能访问到给定属性时返回true。当然不能枚举的属性不包含在内。&lt;code&gt;for-in&lt;/code&gt;循环可返回所有可枚举属性&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Objects.keys(obj)&lt;/code&gt;返回一个所有可枚举属性的字符串数组&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;缺点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;原型对象中的属性和对象公用，虽然可通过重新赋值方式覆盖原型对象中的属性&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;原型模式的简化写法&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;function Person() {};

Person.prototype = {
    name: &#39;tiemie&#39;,
    age: 25;

    sayName: function() {
        alert(this.name);
    };
};

// 以上写法，原型对象的constructor属性不会指向Person，虽然instanceof还可用。优化下如下:
function Person() {};

Person.prototype = {
    constructor: Person, // 上面的方式constructor不可枚举，这种方式可枚举
    name: &#39;tiemie&#39;,
    age: 25;

    sayName: function() {
        alert(this.name);
    };
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;原型的动态性&lt;/code&gt;：实例对象创建后，在原型上所做的任何修改，都会立即在实例对象上反映出来，因为实例对象只是保有一个指向原型对象的指针。下面举例说明：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var f = new Person();
Person.prototype.sayHi = function() {};
f.sayHi(); // ok

var f = new Person();
Person.prototype = {
    sayHi: function() {}
};
f.sayHi(); // not ok。因为f对象中指针指向的原型对象不是通过{}方式重新创建的新对象。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;原生对象的原型&lt;/code&gt;：原生对象都在其构造函数的原型上定义了方法，因此可以自己添加更多方法，但是不建议这么做。&lt;/p&gt;

&lt;p&gt;缺点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;无法通过构造函数传递不同的初始化参数&lt;/li&gt;
&lt;li&gt;所有对象共享属性，导致如果属性是引用类型，例如数组，一个对象的修改会影响到另一个对象&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;组合构造函数模式和原型模式&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;function Person(name, age) {
    this.name = name;
    this.age = age;
}

Person.prototype = {
    constructor: Person,
    sayName = function() {}
};

// p1 p2的name age属性不同
var p1 = new Person(&#39;tiemei&#39;, 25);
var p1 = new Person(&#39;ll&#39;, 25);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;动态原型模式&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;function Person(name, age) {
    this.name = name;
    this.age = age;

    if (typeof this.sayName != &amp;quot;fuction&amp;quot;) {
        Person.prototype.sayName = fucntion() {

        };
        // .. 这里可写多个方法
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;优点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;加强了视觉上的封装性&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;寄生构造函数&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;function SpecialArray() {
    var arr = new Array();

    // 用构造函数所接受到的所有参数初始化了数组的值
    arr.push.apply(arr, argsments);

    // 添加新方法
    arr.toPipedString = function() {
        return this.join(&amp;quot;|&amp;quot;);
    };

    return arr;
}

var colors = new SpecialArray(&#39;blue&#39;, &#39;red&#39;);
alert(colors.toPipedString());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;缺点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;不能使用instanceof方法&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;稳妥构造函数&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;稳妥对象&lt;/code&gt;：没有公共属性，而且其方法也不引用this对象。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;function Person(name, age) {
    var o = new Object();
    o.sayName = function() {
        alert(name);
    };

    return o;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;缺点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;不能使用instanceof方法&lt;/li&gt;
&lt;/ul&gt;

&lt;h1&gt;&lt;a style=&#34;display: block;&#34; name=&#34;js对象继承&#34; href=&#34;#js对象继承&#34;&gt;&lt;/a&gt;js对象继承&lt;/h1&gt;

&lt;p&gt;由于函数没有签名，在ECMAScript中无法实现接口继承，只支持实现继承，主要是依靠原型链来实现的。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;function SuperType() {
    this.property = true;
}
SuperType.prototype.getSuperValue = function() {
    return this.property;
};

function SubType() {
    this.subproperty = false;
}

// 继承了SuperType
// 原来存在于SuperType的实例中所有的属性和方法，现在也存在于SubType.prototype中了
// 实际上SubType.prototype指向的对象，就是SupterType的实例。
SubType.prototype = new SuperType();
// 添加新方法
SubType.prototype.getSubValue = function() {
    return this.subproperty;
};
// 重写超类中的方法
// SubType.prototypegetSubValue = function() {...};

// instance指向SubType的原型，SubType作为一个SuperType的对象又指向SuperType的原型。
// 实际上所有函数的默认原型都是Object实例，因此SuperType的原型对象持有一个指向Object原型的指针
var instance = new SubType();
alert(instance.getSuperValue()); // true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://farm4.staticflickr.com/3924/15135450548_b4f2082b7c.jpg&#34; alt=&#34;prototype inherit&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;原型链继承所带来的缺点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;父类中的引用类型的属性，被所有子类的实例共享。不同于Java等语言的方式&lt;/li&gt;
&lt;li&gt;因为子类的原型是父类的实例对象，子类的所有实例对象共享这个父类对象，所以没有办法在不影响所有子类对象实例的情况下给超类的构造函数传递参数&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;借用构造函数（constructor stealing）&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;function SuperType() {
    this.colors = [&#39;red&#39;, &#39;blue&#39;];
}

function SubType() {
    // 继承SuperType
    SuperType.call(this);
}

var instance1 = new SubType();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;优点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;解决原型链模型中，父类实例属性被所有子类对象共享的问题&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;缺点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;仅用构造函数，方法都在构造函数中定义，函数每次都是new出来的，没法复用&lt;/li&gt;
&lt;li&gt;在超类型的原型中定义的方法，对子类型而言是不可见的&lt;/li&gt;
&lt;li&gt;因此，借用构造函数技术很少单独使用&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;组合集成&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;最常用方式。思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来试下你对实例属性的继承。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;function SuperType(name) {
    this.name = name;
    this.colors = [&#39;red&#39;, &#39;blue&#39;, &#39;green&#39;];
}

SuperType.prototype.sayName = function() {
    alert(this.name);
};

function SubType(name, age) {
    // 继承属性
    SuperType.call(this, name); // 第二次调用SupertType()。这里创建的name，colors属性会屏蔽第一次创建的属性
    this.age = age;
}

// 继承方法
SubType.prototype = new SuperType(); // 第一调用SupterType()
// 自定义方法
SubType.prototype.sayAge = function() {
    alert(this.age);
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;缺点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;无论什么情况下，都会调用两次超类型构造函数&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;原型式继承&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;思路是，借助原型可以基于已有对象创建新对象，同时不必因此创建自定义类型。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;// 新对象持有一个指向o的原型指针，因此新对象能访问到o的所有属性和方法
function objecct(o) {
    function F() {};
    F.prototype = o;
    return new F();
}

var person = {
    name: &#39;tiemei&#39;,
    friends: [&#39;Su&#39;, &#39;Wang&#39;]
};

// anotherPerson实例持有一个原型指针指向person对象
var anotherPerson = object(person); 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ECMAScript5通过新增&lt;code&gt;Object.create()&lt;/code&gt;方法规范了原型式继承。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;// 接上一个例子
// 等价于上面的object方法
var anotherPerson = Object.create(person); 

// 第二个参数与Object.defineProperties()方法第二个参数格式相同
var yeAnotherPerson = Object.create(person, {
    name: {
        value: &amp;quot;Greg&amp;quot;
    }
});

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;寄生式继承&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;创建一个用于封装继承过程的函数。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;function createAnother(original) {
    var clone = object(orginal); // object()不是必须的，任何能返回新对象的函数都适用于此模式

    clone.sayHi = function() {};
    return clone;
}

var person = {};
var anotherPerson = createAnother(person);
another.sayHi();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;缺点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;与构造函数模式类似，做不到函数的复用&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;寄生组合式继承&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;最理想的继承方式&lt;/code&gt;。为了解决组合继承的缺点，出现了寄生组合式继承。借用构造函数来继承属性，通过原型链混成形式来继承方法。思路是，不必为了指定子类型的原型而调用超类型的构造函数，我们所需的无非就是超类型原型的一个副本而已。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;// 
function inheritPrototype(subType, superType) {
    var prototype = object(superType.prototype);
    prototype.constructor = subType;
    subType.prototype = prototype;
}

function SuperType(name) {
    this.name = name;
}
SuperType.prototype.sayName = function() {};

function SubType(name, age) {
    SuperType.call(this, name);

    this.age = age;
}

inheritPrototype(SubType, SuperType);

SubType.prototype.sayAge = function() {
    // ...
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;优点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;只调用了一次SuperType构造函数，因此避免了在SubType.prototype上创建不必要的多余的属性。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1&gt;&lt;a style=&#34;display: block;&#34; name=&#34;js闭包&#34; href=&#34;#js闭包&#34;&gt;&lt;/a&gt;js闭包&lt;/h1&gt;

&lt;p&gt;待续&lt;/p&gt;

&lt;p&gt;参考:&lt;/p&gt;

&lt;p&gt;JavaScript高级程序设计（第2版）》&lt;/p&gt;
</description>
    </item>
    <item>
      <title>js入门笔记（一）——基础</title>
      <link>http://defworld.com/2014/06/13/notes-js-1.html</link>
      <pubDate>2014-06-13 12:00:00 +0800</pubDate>
      <description>&lt;h1&gt;&lt;a style=&#34;display: block;&#34; name=&#34;js函数有啥特点&#34; href=&#34;#js函数有啥特点&#34;&gt;&lt;/a&gt;js函数有啥特点&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;函数的参数实际上在内部是用一个数组表示的，在函数体内可以通过&lt;code&gt;arguments&lt;/code&gt;对象访问。arguments只是跟数组类型可以通过方括号访问每一个元素，实际不是Array实例&lt;/li&gt;
&lt;li&gt;函数定义的参数与实际传递的参数没有个数相等的限制，不像Java语言会编译校验这个&lt;/li&gt;
&lt;li&gt;因为函数参数是由包含另零个或多个值的数组来表示的，没有函数签名，故&lt;code&gt;没有重载&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1&gt;&lt;a style=&#34;display: block;&#34; name=&#34;js基本类型和引用类型&#34; href=&#34;#js基本类型和引用类型&#34;&gt;&lt;/a&gt;js基本类型和引用类型&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;基本数据类型&lt;/code&gt;：Undefined 、 Null 、 Boolean 、 Number 、 String&lt;/li&gt;
&lt;li&gt;不能给基本数据类型添加属性，添加以后访问也是undifined&lt;/li&gt;
&lt;li&gt;因为String在js不同于其他语言是基本类型，所以赋值的时候会将值拷贝一份&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;检测类型&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;&lt;code&gt;typeof&lt;/code&gt;区分是基本类型还是应用类型&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;var s = &#39;Nicholas&#39;;
var b = true;
var i = 22;
var u;
var n = null;
var o = new Object();

alert(typeof s); // string
alert(typeof i); // number
alert(typeof b); // boolean
alert(typeof u); // undefined
alert(typeof n); // object
alert(typeof o); // object
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;code&gt;instanceof&lt;/code&gt;检测对象是啥基本类型&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;所有引用类型都是Object的实例&lt;/li&gt;
&lt;li&gt;对基本类型使用都会返回false&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;函数也是对象。&lt;/p&gt;

&lt;h3&gt;基本包装类型Boolean Number String&lt;/h3&gt;

&lt;p&gt;不建议在代码中使用包装类型。&lt;br /&gt;
之所以基本类型上有方法可以访问，是因为执行的瞬间后台创建了一个包装类型，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;var s1 = &#39;some text&#39;;
var s2 = s1.substring(2);

// 上面的实际上再后台是这么运行的

var s1 = new String(&#39;some text&#39;);
var s2 = s1.substring(2);
s1 = null; // 使用new操作符创建的引用类型实例作用域内一直存在，而这里只是存在于一行代码的执行瞬间
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;创建String类型的一个实例&lt;/li&gt;
&lt;li&gt;在实例上调用指定的方法&lt;/li&gt;
&lt;li&gt;销毁这个实例&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;// 两种创建包装类型的方式

var obj = new Object(&#39;some text&#39;);

// 等价于

var str = new String(&#39;some text&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;// 转型函数与包装类型

var value = &#39;25&#39;;
var number = Number(value); // 转型函数
alert(typeof number); // &#39;number&#39;

var obj = new Number(value); // 构造函数
alert(typeof obj); // &#39;object&#39;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;布尔表达式中所有对象都会被转换成true&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;var falseObj = new Boolean(false);
var result = falseObj &amp;amp;&amp;amp; true;
alert(result); // true
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;&lt;a style=&#34;display: block;&#34; name=&#34;js执行环境及作用域&#34; href=&#34;#js执行环境及作用域&#34;&gt;&lt;/a&gt;js执行环境及作用域&lt;/h1&gt;

&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;执行环境与作用域链&#34; href=&#34;#执行环境与作用域链&#34;&gt;&lt;/a&gt;执行环境与作用域链&lt;/h2&gt;

&lt;p&gt;每个&lt;code&gt;执行环境&lt;/code&gt;都有一个与之关联的&lt;strong&gt;变量对象（variable object）&lt;/strong&gt;，环境中定义的所有变量和函数都保存在这个对象中，虽然我们编写的代码无法访问这个对象，但解析器在处理数据时会在后台使用它。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;每个函数有自己的执行环境&lt;/li&gt;
&lt;li&gt;代码在一个环境中执行时，会创建变量对象的一个&lt;code&gt;作用域链（scope chain）&lt;/code&gt;，超找对象也按此链形成一个优先级&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;延长作用域链&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;js&#34;&gt;function buildUrl() {
    var qs = &#39;?debug=true&#39;;

    with(location) {
        var url = herf + qs; // herf实际上是location.herf
    }

    return url;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;try-catch&lt;/code&gt;的catch块也是类似&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;没有块级作用域&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;所有控制语句的代码块内部声明的变量都会逸出到外部，不同于Java语言。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;函数中的声明的var变量作用域仅限于函数内部&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考:&lt;/p&gt;

&lt;p&gt;JavaScript高级程序设计（第2版）》&lt;/p&gt;
</description>
    </item>
    <item>
      <title>run &amp; debug node.js</title>
      <link>http://defworld.com/2014/06/08/st3-debug-node-js.html</link>
      <pubDate>2014-06-08 12:00:00 +0800</pubDate>
      <description>&lt;h1&gt;&lt;a style=&#34;display: block;&#34; name=&#34;debug-node.js&#34; href=&#34;#debug-node.js&#34;&gt;&lt;/a&gt;debug node.js&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;sudo npm install -g node-inspector&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;node-debug xxx.js&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;set breakpoints&lt;/li&gt;
&lt;li&gt;request &amp;amp; break auto&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;shortcuts&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Resume script execution (F8): 继续执行&lt;/li&gt;
&lt;li&gt;Step over next function call (F10): 按步执行，不进入另一个函数&lt;/li&gt;
&lt;li&gt;Step into next function call (F11): 按步执行，进入另一个函数内部&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Step out of current functino (⇧ F11): 跳出当前函数，进入父函数&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;⌘ o&lt;/code&gt; find file&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;⇧ ⌘ o&lt;/code&gt; find function member in current file&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;other&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;可给断点设置条件&lt;/li&gt;
&lt;li&gt;可通过console查看当前断点下上下文状态&lt;/li&gt;
&lt;li&gt;Pause on exception 可选择打开或关闭&lt;/li&gt;
&lt;li&gt;可打开左侧源码窗口，保持两边窗口的同步&lt;/li&gt;
&lt;/ul&gt;

&lt;h1&gt;&lt;a style=&#34;display: block;&#34; name=&#34;run-node.js&#34; href=&#34;#run-node.js&#34;&gt;&lt;/a&gt;run node.js&lt;/h1&gt;

&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;用[node-dev](https://github.com/fgnass/node-dev)做文件热加载&#34; href=&#34;#用[node-dev](https://github.com/fgnass/node-dev)做文件热加载&#34;&gt;&lt;/a&gt;用&lt;a href=&#34;https://github.com/fgnass/node-dev&#34;&gt;node-dev&lt;/a&gt;做文件热加载&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;准备工作&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;npm install -g node-dev
# 你也可以选择Growl or libnotify，osX可以内置的提醒器
sudo gem install terminal-notifier
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;开始吧&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;node-dev foo.js&lt;/code&gt;&lt;br /&gt;
可用两个选项：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;--no-deps&lt;/code&gt; Watch only the project&amp;rsquo;s own files and linked modules (via &lt;code&gt;npm link&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--all-deps&lt;/code&gt; Watch the whole dependency tree&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;By default node-dev will watch all first-level dependencies, i.e. the ones in the project&amp;rsquo;s node_modulesfolder.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;其他&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;CoffeeScript这样的翻译成js的语言也可以用这个工具&lt;/li&gt;
&lt;li&gt;还有其他高级配置项可供选择&lt;/li&gt;
&lt;li&gt;如果子进程需要重启，会发一个&lt;code&gt;SIGTERM&lt;/code&gt;信号，如果你的代码没有处理这些
信号，&lt;code&gt;process.exit(0)&lt;/code&gt;就会被强行调用&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考：&lt;br /&gt;
&lt;a href=&#34;https://developer.chrome.com/devtools/docs/javascript-debugging?csw=1&#34;&gt;Debugging JavaScript&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://docs.strongloop.com/display/DOC/Debugging+with+Node+Inspector#DebuggingwithNodeInspector-Keyboardshortcuts&#34;&gt;Debugging with Node Inspector&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>C语言入门笔记</title>
      <link>http://defworld.com/2014/06/05/notes-c.html</link>
      <pubDate>2014-06-05 12:00:00 +0800</pubDate>
      <description>&lt;h3&gt;C语言的指针是什么？&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;指针中保存的是指向某个内存对象的地址&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;amp;&lt;/code&gt;取地址，&lt;code&gt;int *p&lt;/code&gt;指向int类型的指针p，&lt;code&gt;*p&lt;/code&gt;p指向的对象&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;C语言的结构体是什么？&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;结构体将多个数据捆绑在一起使用&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;类型定义（typedef）&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;用来建立新的数据类型名&lt;/li&gt;
&lt;li&gt;&lt;code&gt;typedef int Length&lt;/code&gt;类型Length将与int完全相同&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;C&#34;&gt;typedef struct tnode *Treeptr;

typedef struct tnode {
  char *word;
  int count;
  Treeptr left;
  Treeptr right;
} Treenode;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;创建了两个新关键字：Treenode一个结构和Treeptr一个指向该结构的指针&lt;/p&gt;

&lt;h3&gt;C语言的头文件的作用是？&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;局部变量，外部变量，静态变量..&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;函数内部声明的变量属于&lt;code&gt;局部变量&lt;/code&gt;，在函数退出时会被自动回收。
又称自动变量，编译器不会给自动变量隐含初始值。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;外部变量&lt;/code&gt;声明在函数之外，某个函数需要访问时，需要加上extern关键字
做一个声明。如果在源文件中外部变量的声明在使用它的函数之前，extern那一行声明
可省略。默认情况下全局变量只能在定义它的文件中使用，但是在另一个文件中
可用extern将它的作用域扩展到该文件中。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;静态变量&lt;/code&gt;，局部变量加上static为内部静态变量，编译时分配静态存储空间，
而不是运行时动态分配。外部定义的变量加上static为外部静态变量，作用域仅限
定义它的文件，可实现数据隐藏。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;int i;&lt;/code&gt;这时变量定义，分配存储单元。同时也是该源文件其余部分的声明。
&lt;code&gt;extern int i;&lt;/code&gt;声明一个外部变量，不再分配存储单元。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;C语言预处理器&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;预处理是编译过程中单独执行的第一个步骤&lt;/li&gt;
&lt;li&gt;&lt;code&gt;#include&lt;/code&gt;将指定内容的文件包含进当前文件&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;#define&lt;/code&gt;用任意字符替代一个标记&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;对括再引号中的字符不起作用
作用域从定义位置到被编译的源文件末尾
可加上参数
条件包含
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所以，通常把extern的声明放到单独的一个头文件中，&lt;code&gt;#include&lt;/code&gt;进来。还可以用头文件
共享#define等公共部分.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;变量初始化&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;自动变量和寄存器变量只能显示初始化，否则将有不确定值&lt;/li&gt;
&lt;li&gt;外部变量和静态变量仅在编译时初始化一次为0&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;http://farm6.staticflickr.com/5536/14176655820_6e7ccc5454.jpg&#34; alt=&#34;c语言变量作用域&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;参考：&lt;br /&gt;
&lt;a href=&#34;http://blog.csdn.net/qmhlan/article/details/6629360&#34;&gt;浅析c语言中的变量(局部变量，外部变量，静态变量，寄存器变量）&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>java web应用性能调优</title>
      <link>http://defworld.com/2014/05/26/java-web-app-performance-optimization.html</link>
      <pubDate>2014-05-26 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;&lt;a href=&#34;http://ifeve.com/hashcode-method-performance-tuning/&#34;&gt;hashCode()方法的性能优化&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://blog.hesey.net/2014/05/gc-oriented-java-programming.html&#34;&gt;面向GC的Java编程&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://coderbee.net/index.php/java/20140503/907&#34;&gt;Java 性能调优指南 – 高性能Java&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://hellojava.info/?p=347&#34;&gt;高压力下表现不够好的Java应用&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>我的Sublime Text快捷键</title>
      <link>http://defworld.com/2014/05/09/my-sublime-text-3-shortcuts.html</link>
      <pubDate>2014-05-09 12:00:00 +0800</pubDate>
      <description>&lt;h3&gt;select&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;⌃+⌘ +G&lt;/code&gt; find all &lt;code&gt;Escape&lt;/code&gt; cancle&lt;/li&gt;
&lt;li&gt;&lt;code&gt;⌃ ⇧ ↑&lt;/code&gt; &lt;code&gt;⌃ ⇧ ↓&lt;/code&gt; column select 。需要先把系统的shortcuts绑定去掉&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;line&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;⇧ ⌘ D&lt;/code&gt; duplicate line&lt;/li&gt;
&lt;li&gt;&lt;code&gt;⌃ ⇧ K&lt;/code&gt; delete line&lt;/li&gt;
&lt;li&gt;&lt;code&gt;⌃ ⌘ ↑&lt;/code&gt;  &lt;code&gt;⌃ ⌘ ↓&lt;/code&gt; swap line&lt;/li&gt;
&lt;li&gt;&lt;code&gt;⌘ ]&lt;/code&gt; &lt;code&gt;⌘ [&lt;/code&gt; line indent / unindent&lt;/li&gt;
&lt;li&gt;&lt;code&gt;⌘ ↩&lt;/code&gt; insert line after&lt;/li&gt;
&lt;li&gt;&lt;code&gt;⇧ ⌘ ↩&lt;/code&gt; insert line before&lt;/li&gt;
&lt;li&gt;&lt;code&gt;⌃ K&lt;/code&gt;  &lt;code&gt;⌘ ⌦&lt;/code&gt; delete to end / beginning&lt;/li&gt;
&lt;li&gt;&lt;code&gt;⌃ a&lt;/code&gt; go to line head &lt;code&gt;⌃ e&lt;/code&gt; go to line end&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;comment&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;⌘ /&lt;/code&gt; toggle comment&lt;/li&gt;
&lt;li&gt;&lt;code&gt;⌥ ⌘ /&lt;/code&gt; toggle block comment&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;code folding&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;⌥ ⌘ [&lt;/code&gt; &lt;code&gt;⌥ ⌘ ]&lt;/code&gt; fold /unfold&lt;/li&gt;
&lt;li&gt;&lt;code&gt;⌘ K, ⌘ 1&lt;/code&gt; flod all&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;edit&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;⌘ K, ⌘ U&lt;/code&gt; &lt;code&gt;⌘ K, ⌘ L&lt;/code&gt; upper/lower case&lt;/li&gt;
&lt;li&gt;&lt;code&gt;⌃ space&lt;/code&gt; show complete&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;find &amp;amp; goto&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;⌘ G&lt;/code&gt; &lt;code&gt;⇧ ⌘ G&lt;/code&gt; find next/previous&lt;/li&gt;
&lt;li&gt;&lt;code&gt;⌥ ⌘ F&lt;/code&gt; replace / replace all&lt;/li&gt;
&lt;li&gt;&lt;code&gt;⌘ P&lt;/code&gt; go to anything&lt;/li&gt;
&lt;li&gt;&lt;code&gt;⌘ R&lt;/code&gt; go to symbol&lt;/li&gt;
&lt;li&gt;&lt;code&gt;⌥ ⌘ ↓&lt;/code&gt; go to define&lt;/li&gt;
&lt;li&gt;&lt;code&gt;⌃ -&lt;/code&gt; jump back&lt;/li&gt;
&lt;li&gt;&lt;code&gt;⌃ ⇧ -&lt;/code&gt; jump forward&lt;/li&gt;
&lt;li&gt;&lt;code&gt;⌃ G&lt;/code&gt; go to line&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;panes &amp;amp; view&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;⌥ ⌘ 2/3/4&lt;/code&gt; two/three/four column (vertical) panes&lt;/li&gt;
&lt;li&gt;&lt;code&gt;⇧ ⌥ ⌘ 2/3/4&lt;/code&gt; two/three/four row (horizontal) panes&lt;/li&gt;
&lt;li&gt;&lt;code&gt;⌘ K, ⌘ B&lt;/code&gt; toggle the sidebar&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;package&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;⌘ ⇧ P&lt;/code&gt; 调出package control&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;其他&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;key bindings&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;single_line&lt;/code&gt;表示不仅作用于当前行，作用于整个文本。&lt;br /&gt;
&lt;code&gt;json
[
  { &amp;quot;keys&amp;quot;: [&amp;quot;ctrl+shift+r&amp;quot;], &amp;quot;command&amp;quot;: &amp;quot;reveal_in_side_bar&amp;quot;},
  { &amp;quot;keys&amp;quot;: [&amp;quot;ctrl+shift+f&amp;quot;], &amp;quot;command&amp;quot;: &amp;quot;reindent&amp;quot;, &amp;quot;args&amp;quot;: {&amp;quot;single_line&amp;quot;: false}},
  { &amp;quot;keys&amp;quot;: [&amp;quot;ctrl+shift+w&amp;quot;], &amp;quot;command&amp;quot;: &amp;quot;close_all&amp;quot; },
  { &amp;quot;keys&amp;quot;: [&amp;quot;ctrl+shift+s&amp;quot;], &amp;quot;command&amp;quot;: &amp;quot;sava_all&amp;quot;},
  { &amp;quot;keys&amp;quot;: [&amp;quot;ctrl+shift+b&amp;quot;], &amp;quot;command&amp;quot;: &amp;quot;view_in_browser&amp;quot;, &amp;quot;args&amp;quot;: { &amp;quot;browser&amp;quot;: &amp;quot;chrome&amp;quot; } }
]
&lt;/code&gt;&lt;/p&gt;

&lt;h3&gt;插件&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;JSONLint json语法检查插件&lt;/li&gt;
&lt;li&gt;PrettyJSON json格式化，因为reindent对json不好用，&lt;code&gt;⌃ ⌘ j&lt;/code&gt;快捷键&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    <item>
      <title>Node.js前后端分离在广告页面中的思考</title>
      <link>http://defworld.com/2014/04/20/node-js-and-division-of-work.html</link>
      <pubDate>2014-04-20 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;撇下Node.js社区的红火，异步I/O的相比阻塞I/O的好处，也不谈回调嵌套是否反人类，Node.js是否在“羞辱”后端程序员，我想借着这篇文字理一下Node.js在我们广告页面中能否提高合作效率和迭代速度。&lt;/p&gt;

&lt;h3&gt;过去和现状&lt;/h3&gt;

&lt;p&gt;我们团队维护直通车、外投外、无线等多条产品线的二跳页面，且正在接入一跳广告位。&lt;/p&gt;

&lt;p&gt;2012年我刚来团队的时候，说的简单点，主要做的事情无非就是从广告引擎、其他数据源获取数据，展示到页面上。因为公司技术环境的原因，最开始选择了webx+velocity模板，由前端工程师写静态的html页面，java工程师拿过来，把其中的动态部分用vm模板语言重写一遍，再从后端数据源把数据拿过来，几乎不会对数据进行更多的逻辑加工。加上页面几乎没有用户输入部分，基本上交互都集中在纯js/css动态效果，ajax异步数据请求和展现（没有数据输入）。&lt;/p&gt;

&lt;p&gt;可以看到这样的合作模式里，前端/后端工程师的分工是非常明确和解耦的，当然前端同学也能在这样的模式下积累可重用的js组件提交效率。但，随着粗放式增长的瓶颈，加上内部流程的制约，这样的迭代方式遇到了问题？首先，经常性的页面局部调整一般只能在下周的发布日才能完成；一次无法尝试过多版本，因为开发html改成动态模版和测试都需要资源；重复的页面模块开发；后端工程师一直在干重复枯燥的劳动，没有精力去思考如何做到流程的自动化、数据可反馈、统一解决方案的问题；当然还有多终端时代的挑战。&lt;/p&gt;

&lt;p&gt;我们做的第一次尝试，“组件化”平台，我认为实际上是做到页面搭建过程的模型化，也就是说用一种统一的模型来描述页面的逻辑，进而用线上可动态改变的配置文件来描述这个模型。显然，在后端工程师的角度，我们不再是写写数据接口，写写页面模版了，我们面对统一的页面模型，进行配置的统一生成和解析。这里可以简单说下这个模型，基于广告页面的实际业务场景，我们把页面切分成几个独立的块，每块用“动态模版+数据源配置+样式js”的方式描述，块之间的js,css依赖通过css class命名规范进行解耦，块之间的数据依赖（这样的依赖极少）通过配置上的数据传递来解决。&lt;/p&gt;

&lt;p&gt;“组件化”平台的配置化的统一模型尝试是突破性的，后端开发终于从将html改写成动态模版这样的无聊的工作中解脱了，我们也似乎看到一点平台化的统一解决方案的影子。但，因为这个配置化的模型还是过于复杂了，生成模型配置的管理系统，提供出来的配置界面(&lt;code&gt;http://moc.taobao.org/&lt;/code&gt;)过于复杂，也注定了它只能给开发自己玩玩。更大的问题是，&lt;strong&gt;前端工程师需要写后端动态模板&lt;/strong&gt;，调试是个大问题呀！前端们用node.js+velocity.js搭了一个调试平台，然后再用约定的接口数据格式，自己定义一些mock数据调试。这样的方式勉强可以跑通，但前端开发完页面的动的模块后，需要后端工程师在配置系统配置上数据接口和模块之间的依赖关系，然后再将模块代码上传到后端渲染系统，然后才能看到真正的动态页面长什么样。这样的合作方式，我们做出来的页面已经覆盖到淘客、直通车、外投外、淘星云等多个页面，流量也上千万了。如此多的依赖，和前端对最终运行环境的无法感知，带来不少坎坷和诡异的问题。&lt;/p&gt;

&lt;h3&gt;“组件化”方案中前后端到底哪里耦合&lt;/h3&gt;

&lt;p&gt;首先再反思下，我们现有的前后端解耦手段：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;数据接口输出预先约定好&lt;/li&gt;
&lt;li&gt;Node.js + velocity.js 搭建前端开发调试环境&lt;/li&gt;
&lt;li&gt;前端控制动态模版的编写和css/js的控制&lt;/li&gt;
&lt;li&gt;后端控制数据接口入参的控制，数据接口的准备，页面模块间依赖的配置，
最终配置的解析和渲染输出&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;看起来，一点问题都没有，大家分工很清晰，由于前端工程师编写的是后端的动态模版（现在是vm），难免不熟悉容易出错。如果熟悉与否还可以通过时间来解决，那另一个致命的问题看起来就很难解决了：模版从开发完到最终渲染成页面，中间隔了太多层，且这部分对前端完全黑盒，一旦页面上出现什么问题，必然是后端前端测试都扎在这个长链里排查。排查结果，有时候是vm语法写错，有时候时配置出错，有时候是js有问题。&lt;/p&gt;

&lt;h3&gt;Node.js真的能够解耦前后端么&lt;/h3&gt;

&lt;p&gt;如果将模版的渲染交给前端工程师控制呢？&lt;br /&gt;
看一下现在前端圈的声音：&lt;/p&gt;

&lt;p&gt;李牧&lt;a href=&#34;http://limu.iteye.com/blog/2042700&#34;&gt;《818前后分离的架构以及Node在其中的作用》&lt;/a&gt;这篇试图解决的问题就是：“前后端如何解耦？”提到了Backone为为代表的OPOA(One Page One Application)下后端彻底的数据API化，到这里解耦还只在浏览器器和服务器的解耦;然后又提到了Node.js将这种解耦扩展到了服务器端，因为Node.js来了，服务器端端的UI层（原来由vm,jsp等后端模版语言把控）也能交给前端工程师控制了。&lt;/p&gt;

&lt;p&gt;朴灵&lt;a href=&#34;http://www.programmer.com.cn/13844/&#34;&gt;《Node.js的核心与红利》&lt;/a&gt;更多的实在强调Node.js生态圈的完善和生机勃勃，异步I/O的好处，鼓励JavaScript更多的涉足后端，注意，并没有说Node.js是大势所趋，因为毕竟异步I/O并不是Node.js独有，v8引擎性能和稳定性虽然在脚本语言中已经很赞，暂时也不足以替代JVM。&lt;/p&gt;

&lt;p&gt;Nicholas&lt;a href=&#34;http://www.nczonline.net/blog/2013/10/07/node-js-and-the-new-web-front-end/&#34;&gt;《Node.js and the new web front-end》&lt;/a&gt;也在说Node.js能把后端UI layer也放到前端工程师这边来做，后端工程师可以去关心数据存储、数据接口等逻辑。但，其实细想一下，如果是ajax + jjson数据api的方式是不是效果也一样，所谓将UI layer放到Node.js里来做能解耦前后端的说法作用就不那么大了。&lt;/p&gt;

&lt;p&gt;所以，我觉得Node.js能解耦前后端的说法其实并不是一个普适的说法。加上大多数现在的服务器架构下，异步化，cache技术，长链接技术，接口化等方案的选择，Node.js也并不是必须的，可能在现有语言和平台做一些技术改造（例如从现在的多线程阻塞I/O变成tomcat异步支持+servlet3+NIO），在人员储备和所花时间精力上都要好的多。&lt;/p&gt;

&lt;h3&gt;Node.js能解决“组件化”方案耦合问题么&lt;/h3&gt;

&lt;p&gt;首先，前端工程师写模板不用再用vm这样的后端模版语言了，模版渲染也放在Node.js中。考虑到多终端:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;PC下首屏依然得服务器渲染，后面走ajax请求，cache/&lt;a href=&#34;http://engineering.xueqiu.com/blog/2013/02/27/implementing-bigpipe-in-nodejs/&#34;&gt;BigPipe&lt;/a&gt;走起来&lt;/li&gt;
&lt;li&gt;无线App直接面对服务器端数据API接口（就不一定是http了，自定义协议都是可能的）&lt;/li&gt;
&lt;li&gt;无线页面，相比PC对网络流量和网速敏感&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;无线APP看起来广告这边暂时不会做，但将来做不做就说不定了。若三个场景都能用同一套技术架构看起来确实不错。但注意，这也并不是非Node.js不可。还是回到“组件化”里模版交给Node.js渲染，但事情不只是将数据API抽离出去这么简单！因为在请求数据之前，还有页面配置、分流配置的解析，进一步有配置的更新。这部分涉及到metaq tair diamond HSF TFS等交互，当然这些Node.js的支持的也不错（&lt;a href=&#34;http://www.atatech.org/article/detail/13675/0&#34;&gt;阿里 node 手册&lt;/a&gt;）。问题的关键到了！如果配置的解析和更新不是放到Node.js中实现，实际上前端同学写出的js模板（注意这里已经不是vm模板了）还是跑不起来呀，因为这个模板还是按照“组件化”统一配置化模型定义的数据结构来编写的，一个页面的各模版还需要通过配置串联起来，渲染模版面对的数据结构依然不是纯净的宝贝/店铺list数据，还包含了其他页面控制数据。&lt;/p&gt;

&lt;p&gt;再进一步想一下，咱们前端开发工程师现在写完页面是不是还要通过配置系统上传发布呢？是不是排查问题的链还是那么长呢？似乎问题并没有得到很明显的改善。&lt;/p&gt;

&lt;h3&gt;回到问题的本质，我们最终和最初的目的是什么&lt;/h3&gt;

&lt;p&gt;我们的核心目的是什么？快速的页面迭代，快捷统一构建页面入口，个性化分流支持，数据回流。&lt;br /&gt;
前端工程师擅长页面UI控制，不擅长数据接口输入参数控制，也不应该关心页面数据依赖，不关心分流配置，不关心数据回流。如果去简化“组件化”统一模型配置，去掉页面模块数据依赖（这个完全可以做到，只要把有依赖的木块看做一个模板来实现就行了），并将前后端渲染的选择权交给前端工程师控制，Node.js可调用页面配置解析接口获取这样的返回:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    {
      &amp;quot;page_layout&amp;quot;: 1,
      &amp;quot;page_module1&amp;quot;: [
        &amp;quot;http://odin.re.taobao.com/data1?keyword={url.key}&amp;amp;nickname={cookie.tracknick}&amp;amp;pid=44_4444&amp;quot;,
        &amp;quot;http://odin.re.taobao.com/data2?keyword={url.key}&amp;amp;nickname={cookie.tracknick}&amp;amp;pid=44_4444&amp;quot;,
      ],
      &amp;quot;page_module2&amp;quot;: [
        &amp;quot;http://odin.re.taobao.com/data2?keyword={url.key}&amp;amp;nickname={cookie.tracknick}&amp;amp;pid=44_4444&amp;quot;,
      ]
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一个页面静态的部分包括html框架，css控制，js控制，都在page_layout里，动态数据获取通过返回的数据接口获取。注意&lt;code&gt;keyword={url.key}&lt;/code&gt;代表Node.js需要从请求参数解析出key参数替换进去。cookie也类似。不过这段逻辑是统一的也不会很复杂。&lt;/p&gt;

&lt;p&gt;上面返回格式中，都是http协议的数据api，也不仅限于http。哪几个api直接Node.js请求数据渲染，哪几个由页面ajax异步请求数据，完全交给前端工程师控制了，也就是通过page_layout id能找到那段决定如何使用这些page_module的数据接口的代码就可以了。&lt;/p&gt;

&lt;p&gt;页面中其他需要动态数据的部分，例如翻页参数的拼接，因为Node.js能直接面对请求，所以都能顺利拿到，再不需要js在后台吐出的数据中苦苦找了。页面渲染要用啥工具，直接Node.js提供就行了。另，我建议不要用现在metaq消息更新page_layout等配置，前端工程师写完page_layouy页面组件模板等自己行管理推送到Node.js服务器，最简单就是复用tms方式全量同步。将模板完全交给前端工程师维护，也有利于模板复用和模板库的形成。至于在页面数据数据接口配置，分流配置等后端掌控部分，也可以尝试Node.js来写配置管理系统，以做到拖拉生成页面时的实时渲染。&lt;/p&gt;

&lt;p&gt;“组件化”模型简化后，看起来皆大欢喜。前端工程师编写页面调试、和最终线上渲染的环境统一了，且无需关心接口的入参逻辑（因为从哪里获取参数那段代码是统一的）。后端的数据json数据API接口封装，屏蔽了不同广告引擎和数据源的复杂性，提供给前端使用的只是宝贝list/店铺list这样的统一模型。再插一句无关的，现在Http接口已经支持多个数据接口的合并请求。&lt;br /&gt;
粗略思考，望各位指正。&lt;/p&gt;
</description>
    </item>
    <item>
      <title>《linux 101 hacks》笔记</title>
      <link>http://defworld.com/2014/01/18/reading-linux-101-hacks.html</link>
      <pubDate>2014-01-18 12:00:00 +0800</pubDate>
      <description>&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;cd&#34; href=&#34;#cd&#34;&gt;&lt;/a&gt;cd&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;CDPATH&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;默认&lt;code&gt;cd logs&lt;/code&gt;进入当前目录的logs目录，设置了这个变量，优先进入这个变量
指向的目录的下对应的文件夹。可用冒号分隔指定多个。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;返回多级上级目录&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~/.bashrc

alias ..=&#39;cd ..&#39;
alias ..2=&#39;cd ../..&#39;
alias ..3=&#39;cd ../../..&#39;

或者这种方式：

alias ..=&#39;cd ..&#39;
alias ...=&#39;cd ...&#39;

或者

alias cd...=&amp;quot;cd ../..&amp;quot;

等等方式
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;创建目录并进入该目录&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function mkdircd () { mkdir -p &amp;quot;$@&amp;quot; &amp;amp;&amp;amp; eval cd &amp;quot;\&amp;quot;\$$#\&amp;quot;&amp;quot;; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;$@&lt;/code&gt;所有参数，&lt;code&gt;$#&lt;/code&gt;mkdircd函数传入的参数长度，例如mkdircd hello，
eval将$1这个字符串解释为变量值hello&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;cd -&lt;/strong&gt; 在最近访问的两个目录间切换&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;目录堆栈&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;* dirs:显示目录栈
* pushd:将目录压入目录栈 
* popd:将目录弹出目录栈
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;智能纠正cd命令错误目录名&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;shopt –s cdspell&lt;/code&gt;&lt;/p&gt;

&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;其他&#34; href=&#34;#其他&#34;&gt;&lt;/a&gt;其他&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;grep&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;grep -ri str dir&lt;/code&gt; 在目录dir的所有子目录超找包含字符str的内容的地方&lt;/li&gt;
&lt;li&gt;&lt;code&gt;grep -ril str dir&lt;/code&gt; 只显示文件名&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;find&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;find / -type f -size +100M&lt;/code&gt; 找到/目录下大于100M的文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;find . -mtime +60&lt;/code&gt; 最近60天没有被修改过的文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;find . –mtime -2&lt;/code&gt;  最近2天被修改过的文件&lt;/li&gt;

&lt;li&gt;&lt;p&gt;删除&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; find / -type f -name *.tar.gz -size +100M -exec ls -l {} \;
 find / -type f -name *.tar.gz -size +100M -exec rm -f {} \;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;打包&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; find /home/jsmith -type f -mtime +60 | xargs tar -cvf /tmp/`date &#39;+%d%m%Y&#39;_archive.tar`
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;join&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;合并两个文件，按相同列。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;xargs&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;将一个命令的输出传递给下一个命令的输入&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;cat url-list.txt | xargs wget –c&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;find /etc -name &amp;quot;*.conf&amp;quot; | xargs ls –l&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;uniq&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;sort namesd.txt | uniq –cd&lt;/code&gt; -c显示出个数，-d只列出重复项&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;ac&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ac -d&lt;/code&gt; 按天显示登陆主机时间&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ac -p&lt;/code&gt; 显示所有用户的时间&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ac -d jiadongkai&lt;/code&gt; 指定用户时间&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;提示符&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;PS1=”\u@\h \w&amp;gt;&amp;quot;&lt;/code&gt; \u用户 \h主机名 \w当前目录&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PS2=&amp;quot;continue-&amp;gt; &amp;quot;&lt;/code&gt; 多行命令的默认提示符&amp;gt;修改为continue-&amp;gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PS3=&amp;quot;Select a day (1-4): &amp;quot;&lt;/code&gt;select命令的默认提示符号&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;http://farm8.staticflickr.com/7331/12007421406_6031688bca.jpg&#34; alt=&#34;PS3&#34; /&gt;
&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;PS4=&#39;$0.$LINENO+ &#39;&lt;/code&gt; 改变调试脚本(直接加上&lt;code&gt;set -xv&lt;/code&gt;/&lt;code&gt;bash -xv script&lt;/code&gt;)时的默认前缀，$0当前脚本的名字，$LINENO当前行号&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PROMPT_COMMAND=&amp;quot;date +%k:%m:%S&amp;quot;&lt;/code&gt; Bash 在显示 PS1 之前先执行 PROMPT_COMMAND 定义的内容&lt;/li&gt;
&lt;li&gt;可以在提示符中显示任何命令的输出&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;提示符颜色&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;export PS1=&amp;quot;\e[0;34m\u@\h \w&amp;gt; \e[m &amp;quot;&lt;/code&gt; 改变提示符的前景颜色为亮蓝色&lt;/li&gt;
&lt;li&gt;&lt;code&gt;export PS1=&amp;quot;\e[0;34m\e[47m\u@\h \w&amp;gt; \e[m &amp;quot;&lt;/code&gt;定制前景色和背景色&lt;/li&gt;
&lt;li&gt;可使用tput更加丰富颜色展示&lt;/li&gt;
&lt;li&gt;已有的 PS1 变量可使用&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;压缩&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;略过&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;history&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;export HISTTIMEFORMAT=&#39;%F %T &#39;&lt;/code&gt; history显示时间戳&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ctrl + r&lt;/code&gt;搜索历史命令&lt;/li&gt;
&lt;li&gt;&lt;code&gt;!n&lt;/code&gt; 执行history中第几条命令&lt;/li&gt;
&lt;li&gt;&lt;code&gt;!ps&lt;/code&gt;执行最近的已ps开头的历史命令&lt;/li&gt;
&lt;li&gt;历史命令默认保存在.bash_history，用HISTFILE改变&lt;/li&gt;
&lt;li&gt;自动去除重复历史命令&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;fdisk&lt;/strong&gt; 管理分区&lt;br /&gt;
&lt;strong&gt;mke2fsk&lt;/strong&gt; 管理文件系统&lt;br /&gt;
略&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;crontab&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://farm3.staticflickr.com/2838/12008804724_a300fcfbe1.jpg&#34; alt=&#34;crontab&#34; /&gt;
&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1,2,3,4&lt;/code&gt;&lt;code&gt;1-4&lt;/code&gt; 每一项可以指定多个值，两种写法相同&lt;/li&gt;
&lt;li&gt;&lt;code&gt;*/5 * * * *&lt;/code&gt; 每隔5分钟&lt;/li&gt;
&lt;li&gt;&lt;code&gt;crontab file&lt;/code&gt; 用file替代当前的crontab内容&lt;/li&gt;
&lt;li&gt;&lt;code&gt;echo &amp;quot;5 * * * * touch ni&amp;quot; | crontab -&lt;/code&gt; 替换crontab内容&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;.bash..&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;执行顺序:&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;http://farm4.staticflickr.com/3803/12013970874_ff612e3f50.jpg&#34; alt=&#34;bash执行顺序&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;/etc/bashrc在/etc/profile中被调用，~/.bashrc在~/.bash_profile中被调用。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://farm6.staticflickr.com/5498/12014506206_8f06f37a46.jpg&#34; alt=&#34;非登录bash执行顺序&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;echo&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;echo 1 \; 2&lt;/code&gt; 输出&lt;code&gt;1 ; 2&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;单引号按字符原意输出&lt;/li&gt;

&lt;li&gt;&lt;p&gt;双引号变量会被解释&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;除了以下字符,双引号会去除所有字符的特殊含义
$ 参数替换
` 后引号
\$ 美元符号
\&amp;quot; 双引号
\\ 插入反斜杠
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;从文件中读取指定域&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://farm6.staticflickr.com/5541/12014671226_006e3e3ca2.jpg&#34; alt=&#34;while读取文件指定域&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;top&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;显示进程的绝对路径按c&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ps&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ps axuf&lt;/code&gt;/&lt;code&gt;ps –ejH&lt;/code&gt;/&lt;code&gt;pstree&lt;/code&gt; 显示进程树&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ps U oracle&lt;/code&gt;查看指定用户进程&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;lsof&lt;/strong&gt;列出系统中所有打开的文件&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;lsof -u user&lt;/code&gt; 查看指定用户打开的文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;lsof file&lt;/code&gt; 查看使用文件的所有用户&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;nice&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;程的 nice 值决定进程需要多少处理器时间。nice 值的取值范围是是:-20 到 20。一
个具有-20 的 nice 值的进程有很高的优先级&lt;br /&gt;
&lt;code&gt;renice&lt;/code&gt;可以给正在运行的进程设置调度优先级&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;tee&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ls | tee file&lt;/code&gt; 同时将输出写入标准输出和文件，&lt;/li&gt;
&lt;li&gt;&lt;code&gt;crontab -l | tee crontab-backup.txt | sed &#39;s/old/new/&#39; | crontab –&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ls | tee -a file&lt;/code&gt; 默认覆盖文件改成追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ls | tee f1 f2 f3&lt;/code&gt; 写入多个文件&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;系统监控命令系列&#34; href=&#34;#系统监控命令系列&#34;&gt;&lt;/a&gt;系统监控命令系列&lt;/h2&gt;

&lt;p&gt;待续&lt;/p&gt;
</description>
    </item>
    <item>
      <title>谈谈Unix-like上软件安装那些事</title>
      <link>http://defworld.com/2013/11/10/linux-software-install.html</link>
      <pubDate>2013-11-10 12:00:00 +0800</pubDate>
      <description>&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;linux和mac-os-x&#34; href=&#34;#linux和mac-os-x&#34;&gt;&lt;/a&gt;Linux和Mac OS X&lt;/h2&gt;

&lt;p&gt;在大学刚听说linux时候，被一堆名词唬住了：CentOS,Ubuntu,RedHat等。我一开始用
Fedora13一直用到Fedora15，使用过程中遇到多次诡异问题，最后都定位到是Fedora发行
版的bug，变忍痛弃之。相对，使用率更高的Ubuntu成为我的第二选择，因为使用率高，出现
问题也能从网上获得更多帮助。从今年3月份开始，换成了现在的os x系统。&lt;br /&gt;
如此多的选择，常常让入门者无所适从。&lt;br /&gt;
linux发行版分为主要的三个分支：RedHat、Slackware和Debian，每一个分支都拥有一个
最具代表性的商业服务器级的发行版，它们是：RedHat Enterpries Linux，简称RHEL、
SUSE LinuxEnterprise，简称SUSE，和Ubuntu Server，简称Ubuntu。有分支的区分，是因为
后来的各种发行版是在这几个最初版本上修改而来的，虽然某些发行版实际上已经跟最初的
版本相差甚远了。很多大型互联网公司会选择REHL，因为它对kvm的支持。但REHL收费，除非
你自己下它的源码编译，不过CentOS就是REHL源码编译过来的，所以，直接上CentOS就好。&lt;br /&gt;
那现在苹果机器搭载的os x系统处在什么位置呢？&lt;code&gt;Mac OS&lt;/code&gt;基于Mach内核，这个内核的出现也是
为了弥补Unix的某些局限和不足，对Unix系统下的程序的直接移植也做到了较好的兼容性。&lt;code&gt;mac os x&lt;/code&gt;
是一次内核层面的改造，核心名为&lt;code&gt;Darwin&lt;/code&gt;，以&lt;code&gt;FreeBSD&lt;/code&gt;源码和&lt;code&gt;Mach&lt;/code&gt;微内核为基础。于是可知现在
我们使用的&lt;code&gt;Mac os x&lt;/code&gt;衍生自&lt;code&gt;BSD&lt;/code&gt;分支，而linux于1991被&lt;code&gt;Linus Benedict Torvalds&lt;/code&gt;编写时，&lt;code&gt;386BSD&lt;/code&gt;
还没有发布。如果真的要追溯linux和&lt;code&gt;mac os x&lt;/code&gt;的血缘关系，恐怕要更远了。所以，如果你觉得
用惯了Ubuntu，换成Mac机有一些不习惯，那是不可避免的了。&lt;/p&gt;

&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;unix安装软件&#34; href=&#34;#unix安装软件&#34;&gt;&lt;/a&gt;Unix安装软件&lt;/h2&gt;

&lt;h3&gt;源码安装&lt;/h3&gt;

&lt;p&gt;这里最原始的软件安装方式就是自己编译源码了，通常各源码提供方（例如nginx.org）会将自己源码
放到主页供世界各地使用者下载，这时下下来的源码都是经过打包压缩的，以&lt;code&gt;tar.gz&lt;/code&gt;&lt;code&gt;tar.bz2&lt;/code&gt;等结尾。
解压后你就看到一堆纯文本的源码。&lt;br /&gt;
接下来，我们需要编译器将源码编译成机器可识别的二进制格式，常用的C语言编译器有&lt;code&gt;gcc&lt;/code&gt;&lt;code&gt;cc&lt;/code&gt;等。我们
通常会将编译、安装、卸载一个软件的所有步骤放到Makefile文件中。如果源码较大，且需要检测系统环境
动态决定具体的操作步骤时，我们可以借助&lt;code&gt;automake&lt;/code&gt;&lt;code&gt;autoconfig&lt;/code&gt;这样的自动化工具（nginx不依赖，自己编码
实现这个过程）。所以，从源码安装软件通常分为三步：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;./configure&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;检查系统环境，比如检查你的系统是否支持epoll。生成Makefile文件
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;make&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;编译
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;make install&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;安装编译好的二进制文件到指定目录
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;rpm和yum，dkpg和apt&lt;/h3&gt;

&lt;p&gt;以rpm为例，它是编译好的二进制文件，所以不同的发行版之间通常无法互通，设置同一发行版的不同版本也不兼容。
这时，通常与RPM包同时释放出的SRPM，自定编译安装。&lt;br /&gt;
我们通常会在安装rpm包时，包名里见到这样的字符&lt;code&gt;i386,i586,i686,noarch,x86_64&lt;/code&gt;。由于CPU的向下兼容性，实际上
i386基于能运行于所有的x86平台上，只是后面版本的rpm包进行过编译优化。&lt;br /&gt;
rpm包安装前会自动检查系统环境的兼容性，以及与其他软件的依赖关系。并且会自己管理RPM文件的信息，便于升级、移除、查询等。&lt;br /&gt;
yum相比rpm，解决了软件之间依赖问题。它集中收集rpm包内部记录的软件依赖数据，在你安装某个软件时，自动完成所依赖软件的安装。&lt;/p&gt;

&lt;h3&gt;SRPM的使用&lt;/h3&gt;

&lt;p&gt;SRPM在编译时会用到一些目录，以CentOS为例：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://farm4.staticflickr.com/3757/10773016346_1220899b61.jpg&#34; alt=&#34;SRPM DIR&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;我么可以从SRPM开始安装软件（&lt;code&gt;--rebuid/--recompile&lt;/code&gt;），可以从从源码开始安装软件。&lt;br /&gt;
我们将准备好的源码放到SOURCES目录，将spec文件放到SPECS目录，然后运行rpmbuild命令即可将源码打包成rpm。&lt;/p&gt;

&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;常用命令&#34; href=&#34;#常用命令&#34;&gt;&lt;/a&gt;常用命令&lt;/h2&gt;

&lt;p&gt;参考:&lt;br /&gt;
&lt;a href=&#34;http://vbird.dic.ksu.edu.tw/linux_basic/0520rpm_and_srpm_2.php&#34;&gt;软件安装： RPM, SRPM 与 YUM 功能&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;rpm&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;安装&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;rpm -ivh  rpm -ivh rp-pppoe-3.5-32.1.i386.rpm/http://website.name/path/pkgname.rpm&lt;/code&gt;从本地或远程安装rpm包，
相关信息会写入&lt;code&gt;/var/lib/rpm/&lt;/code&gt;目录&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--replacefiles&lt;/code&gt;强制覆盖本地已存在文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--replacepkgs&lt;/code&gt;强制替换已经安装过的rpm包&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--force&lt;/code&gt;上面两个的综合&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--test&lt;/code&gt; 不真的安装，检测是否有依赖问题&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--justdb&lt;/code&gt; 由於 RPM 数据库破损或者是某些缘故产生错误时，可使用这个选项来升级软件在数据库内的相关资讯。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--nosignature&lt;/code&gt;  想要略过数码签章的检查时&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--prefix 新路径&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;升级&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;rpm -Uvh rpm-pkg&lt;/code&gt; 已有这个软件，升级它，没有就装上。&lt;code&gt;rpm -Fvh rpm-pkg&lt;/code&gt;已有这个软件升级它，没有不装&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;查询&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;rpm -q t-p4p-lego_qa&lt;/code&gt; 查看某软件是否已安装&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rpm -qa&lt;/code&gt; 列出所有已安装软件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rpm -qi t-p4p-lego_qa&lt;/code&gt; 列出该软件的详细资讯 (information)，包含开发商、版本与说明等&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rpm -ql t-p4p-lego_qa&lt;/code&gt; 列出该软件所有的文件与目录所在完整档名 (list)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-qc&lt;/code&gt; 列出该软件的所有配置档 (找出在 /etc/ 底下的档名而已)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-qd&lt;/code&gt; 列出该软件的所有说明档 (找出与 man 有关的文件而已)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-qR&lt;/code&gt; 列出与该软件有关的相依软件所含的文件 (Required 的意思)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-qf&lt;/code&gt; 后面接的文件名称，找出该文件属於哪一个已安装的软件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-qp[icdlR]&lt;/code&gt; 不是到已安装文件里找，而是指定一个本地rpm包查找(p 是 package 的意思)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;其他&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;rpm -e t-p4p-lego_qa&lt;/code&gt; 需要按依赖从上往下移除&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rpm --rebuilddb&lt;/code&gt; 如果&lt;code&gt;/var/lib/rpm/&lt;/code&gt;受损坏，用它恢复&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考:&lt;br /&gt;
&lt;a href=&#34;http://zh.wikipedia.org/wiki/Mac_OS&#34;&gt;wiki-mac_os&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://zh.wikipedia.org/wiki/OS_X&#34;&gt;wiki-mac_os_x&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://zh.wikipedia.org/wiki/Mach&#34;&gt;wiki-mach&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://vbird.dic.ksu.edu.tw/linux_basic/0520source_code_and_tarball.php&#34;&gt;软件安装：原始码与 Tarball&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://vbird.dic.ksu.edu.tw/linux_basic/0520rpm_and_srpm.php&#34;&gt;软件安装： RPM, SRPM 与 YUM 功能&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>2013上半年个人总结</title>
      <link>http://defworld.com/2013/10/13/personal-summary-first-half-of-2013.html</link>
      <pubDate>2013-10-13 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;我当然要给自己一个诚实的2013上半年总结。
今年我保留了所有的周报，我甚至可以事无巨细的列出所有的大事小事。
列的详细一点，可以列很多，挑拣的列出来，也可以很少。总结一下，印象
深的投入过发自内心热情去做的事有这么几件：&lt;/p&gt;

&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;组件化平台&#34; href=&#34;#组件化平台&#34;&gt;&lt;/a&gt;组件化平台&lt;/h2&gt;

&lt;p&gt;对于我来说，从技术上去改革，需要很大的自我不满足和挑战心。
也第一次给我很大的思想冲击，因为把组件化拉出来，也就等于是说我们开始去思考
一些问题：我们是否可以做的更好？自己是否对前端这边的业务现状和未来有过深入
思考？因为没有深入思考过，在组件化整件事推进过程中会很被动。我经历了聚在一起，
你一句他一句混乱零星的讨论。我知道了，一件事的落地和真正执行是怎样从嘴皮子上
到手上。我学会去辨识每个人背后对一件事的原始目的、动力和认真程度。&lt;br /&gt;
在说“营销解决方案”这个词的时候，我有些激动。是的，这样指出最终美丽的目标不能不
激动。不过，包括在组件化最初方案敲定，和后期的讨论中，我都很容易陷入具体的细节里，
所以很多时候很被动。这是很困扰我的一件事情，因为被动影响我的激情。但，从一开始过来
负责的事情需要需要对每一个细节都体察入微，稍不小心影响面就很大，可能养成了把细节摆在
首位的习惯。认识到自己的问题是一回事，解决又是另一回事。可能是需要时间，可能是需要
调整自己的做事方式，可能是需要向其他人学习借鉴，总之，我还有很多事要做。希望能找回
激情和主动。&lt;/p&gt;

&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;技术积累&#34; href=&#34;#技术积累&#34;&gt;&lt;/a&gt;技术积累&lt;/h2&gt;

&lt;p&gt;今年看过一些系统、工具的源码，fastjson、webx整合velocity部分、velocity超找resoureloader部分、
日志框架的整体架构、Roma框架等。也错过或搁置了一些技术积累和提高的机会，比如上次渲染引擎压测后
的几个问题：“http_load压测时配置参数和原理”“load到底指什么”“读写锁深入”。已经搞懂的技术点，我觉得
很简单，甚至觉得不值一提（这也是程序员的通病）。没有能够深入的点，可能有各种原因，可能是搞了一段时间
发现知识储备不够举步维艰，也可能有其他更加紧急的工作打断，甚至可能自己生活节奏有些问题，那段时间关心
的重点不在这里。&lt;br /&gt;
我是有强烈的愿望搞懂一些难题的，这跟我上学时热衷于解决试卷最后一道难题是一脉相承的。这也是我自己搭建
个人博客&lt;code&gt;defworld.com&lt;/code&gt;的初衷。可是我坚信所有的问题到最后都非常简单，所以很多时候搞个半懂，也绝不会拿出来说。&lt;br /&gt;
虽然时间被切割成小片，一些小点的问题固然希望自己能够当时就搞懂。还是希望自己能花比较长时间对一个主题，比如
&lt;code&gt;操作系统&lt;/code&gt;&lt;code&gt;网络安全&lt;/code&gt;&lt;code&gt;并发编程&lt;/code&gt;有个全面和集中的思考学习。遇到问题解决固然来的深刻和快捷见收获，但这些自发的长久
的对一个技术问题的关注才是好心态、持久热情的体现把，可能这种想法还很传统带了些学究气。总之，希望自己能够静下心
深入一个主题。&lt;/p&gt;

&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;个人生活和工作结合&#34; href=&#34;#个人生活和工作结合&#34;&gt;&lt;/a&gt;个人生活和工作结合&lt;/h2&gt;

&lt;p&gt;今年过来，我应该看了几十本非技术书。这需要时间，我也热衷于参加骑行、讲座等活动，这当然跟工作有冲突。&lt;br /&gt;
我这样理解这件事。这些事情使我身体健康、保持细腻的心思和敏感，保持对生活的热情，我相信这些是工作时间越来越长
后要能一直保持下去的比较难的东西。虽然看起来我花在工作上的时间少了，少解决了一个问题，甚至又是心思不完全在
工作上（没什么不可以说的），但没有生活气息的人，做工作的时候必然也可能是死板、缺乏创新的狭隘的，与人合作，
做出来的产品也不一定是客户想要的，我们面对的最终和最直接的是人不是嘛。&lt;br /&gt;
前面有几个星期时间，跟人合作我也出现了一些问题，这跟我要强的性格和敏感的心有关系。我觉得不对的事情或解决方案，
我是不怎么会妥协的，而且由于年轻气盛，情绪控制不好。也谢谢大家的包容和开导，现在我知道，我的坚持也许是对的，
但我不好的语气是不对的，我可以通过理智的说服或者拉上公平的第三者一起评说协调。这点，得向凌萧你学习，因为你每次
出来解决问题，所说的理由和淡定的态度都很令我信服。相比业务技术的成长，这些为人做事的领悟和改变，也很重要吧。这方面
，也是我工作很看重、觉得收获很大的一点。&lt;br /&gt;
最后说一点，我不喜欢三蛮每件事都催促和事无巨细的插手，感觉是对我的不信任。当然，这也是他积极主动的表现形式。可能，
我并不算一个大度的人，我和他之间的隔阂我个人觉得还没有完全消除，之前也跟你说过这事，所以我并不能当面对他说这事。&lt;/p&gt;

&lt;p&gt;我觉得有必要告诉你最真实的我的状态，所以我的总结可能有些奇怪。但平时严谨密集的工作之下，我是一个有血有肉的思想涌动的人。&lt;/p&gt;
</description>
    </item>
    <item>
      <title>JVM——类加载器，初始化</title>
      <link>http://defworld.com/2013/09/15/jvm-class-loader-and-init.html</link>
      <pubDate>2013-09-15 12:00:00 +0800</pubDate>
      <description>&lt;h1&gt;&lt;a style=&#34;display: block;&#34; name=&#34;类加载器&#34; href=&#34;#类加载器&#34;&gt;&lt;/a&gt;类加载器&lt;/h1&gt;

&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;“双亲”委派&#34; href=&#34;#“双亲”委派&#34;&gt;&lt;/a&gt;“双亲”委派&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;类加载器使用“双亲委派”模型。
&lt;img src=&#34;http://farm4.staticflickr.com/3705/9757201665_47321648aa.jpg&#34; alt=&#34;classloaders&#34; /&gt;
&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;可以自己写一个类编辑打成Jar包放到&lt;code&gt;$JAVA_HOME/jre/lib/ext&lt;/code&gt;目录，再写一个启动类，
打印出加载所写类的classloader，发现是extclassloader。但是放到&lt;code&gt;$JAVA_HOME/jre/lib&lt;/code&gt;
目录并不会被加载&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;被加载的类唯一标识是类路径+类加载器id.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;线程类加载器&#34; href=&#34;#线程类加载器&#34;&gt;&lt;/a&gt;线程类加载器&lt;/h2&gt;

&lt;p&gt;首先介绍一个概念：&lt;strong&gt;当前类加载器&lt;/strong&gt;，指当前方法方法所在类的加载器。&lt;code&gt;Class.forName(String)&lt;/code&gt;
&lt;code&gt;Class.getResource(String)&lt;/code&gt;&lt;code&gt;X.class&lt;/code&gt;都是用的当前类加载器。&lt;br /&gt;
这是原有的“双亲委派”模型就不能解决问题了。例如JNDI的核心类在JRE的rt.jar中，而这些核心类
需要加载第三方厂商的JNDI实现，加载时的类加载器默认是“当前类加载器”，即&lt;code&gt;Bootstrap class loader&lt;/code&gt;，
显然是加载不到这些实现类的。这时，&lt;strong&gt;线程类加载器&lt;/strong&gt;就起作用了。让JNDI核心类的加载使用线程
上下文类加载器，打破“双亲委托”限定的向上代理机制。&lt;br /&gt;
虽然下“线程类加载器”解决了某些特殊问题，但它也存在不足。除非所有线程使用同一个线程上下文类
加载器，否则它们的数据共享成为问题。并且，缺省规则为使用当前类加载器，有些代码你又没法控制，
这个问题变得更加复杂。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;J2SE中常见类加载场景：
→ JNDI使用线程上下文类加载器
→ Class.getResource()和Class.forName()使用当前类加载器
→ JAXP使用上下文类加载器
→ Java.unit.ResourceBundle使用调用者的当前类加载器
→ URL协议处理器使用java.protocol.handler.pkgs系统属性并只使用系统类加载器
→ Java序列化API缺省使用调用者当前的类加载器.
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;jvm类加载体系初始化过程&#34; href=&#34;#jvm类加载体系初始化过程&#34;&gt;&lt;/a&gt;JVM类加载体系初始化过程&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;http://farm3.staticflickr.com/2812/9758702554_fdd089dd36.jpg&#34; alt=&#34;JVM classloader init&#34; /&gt;
&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;载入方式&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;→ pre-loading 预先载入，未避免以后多次IO操作，JRE预先载入一些基础类，主要是rt.jar里
→ load-on-demand，按需载入
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;可用&lt;code&gt;java –verbos:class Main&lt;/code&gt;查看加载详细过程&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Static 何时执行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;→ forName(String)执行，而ClassLoader.loadClass并不会执行，forName(String,false,ClassLoader)也不会执行
→ 载入class时没有执行static块，则在第一次实例化时执行
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;隐式加载/显示加载&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;→ 显示加载：用forName方法显示指定要加载哪个类
→ 隐式加载：new方法实例化时，JVM隐式帮忙做加载，并执行静态代码快
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1&gt;&lt;a style=&#34;display: block;&#34; name=&#34;tomcat中类加载器&#34; href=&#34;#tomcat中类加载器&#34;&gt;&lt;/a&gt;tomcat中类加载器&lt;/h1&gt;

&lt;p&gt;除了J2SE已经有的最基础的类加载器，tomcat类加载还有以下几种：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Catalina类加载器：对Tomcat服务器内核可见,对Web应用程序不可见。
tomcat内核线程上下文加载器就是它。
加载目录&lt;code&gt;server/classes和server/lib&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Common类加载器：Tomcat内核和每个Web应用程序都可以看见。
加载未知&lt;code&gt;common/class&lt;/code&gt;&lt;code&gt;common/lib&lt;/code&gt;，例如servlet.jar&lt;/li&gt;
&lt;li&gt;Shared类加载器：只对所有Web应用程序有效,对Tomcat不可见。
加载位置：&lt;code&gt;share/classes&lt;/code&gt;&lt;code&gt;share/lib&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Webapp类加载器：只对当前Web应用程序有效。
每个web应用程序的上下文类加载器就是它。
加载位置：&lt;code&gt;WEB-INF/classes&lt;/code&gt;&lt;code&gt;WEB-INF/lib&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;tomcat类加载顺序&#34; href=&#34;#tomcat类加载顺序&#34;&gt;&lt;/a&gt;tomcat类加载顺序&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;查看缓存中之前有没加载过&lt;/li&gt;
&lt;li&gt;没有，委托给system classloader加载，走“双亲委派”那套&lt;/li&gt;
&lt;li&gt;2加载不到，某些类会尝试用”shared类加载器“，其他用“webapp类加载器”加载&lt;/li&gt;
&lt;li&gt;3搞不定，向上委派&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;整个过程如图：&lt;br /&gt;
&lt;img src=&#34;http://farm4.staticflickr.com/3777/9758884752_bac5a4b3b7.jpg&#34; alt=&#34;tomcat class loader&#34; /&gt;
&lt;/p&gt;

&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;tomcat最新版本&#34; href=&#34;#tomcat最新版本&#34;&gt;&lt;/a&gt;tomcat最新版本&lt;/h2&gt;

&lt;p&gt;Tomcat 6之后classloader 稍微有些改动了，去掉了server 和 shared, 都由common classloader 来载入了&lt;/p&gt;

&lt;h1&gt;&lt;a style=&#34;display: block;&#34; name=&#34;初始化&#34; href=&#34;#初始化&#34;&gt;&lt;/a&gt;初始化&lt;/h1&gt;

&lt;p&gt;待补充&lt;/p&gt;

&lt;p&gt;参考:&lt;br /&gt;
&lt;a href=&#34;http://blog.csdn.net/vernonzheng/article/details/8461380&#34;&gt; 深入JVM系列（三）之类加载、类加载器、双亲委派机制与常见问题&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://ieroot.com/2013/05/01/932.html&#34;&gt;ClassLoader类加载器&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://www.goldendoc.org/2010/12/tomcat_classloader/&#34;&gt;Tomcat ClassLoader机制介绍&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://www.blogjava.net/William/archive/2006/08/25/65804.html&#34;&gt;深入探讨Java的类加载机制&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>常用maven命令</title>
      <link>http://defworld.com/2013/09/12/maven-cmd.html</link>
      <pubDate>2013-09-12 12:00:00 +0800</pubDate>
      <description>&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;剪裁反应堆&#34; href=&#34;#剪裁反应堆&#34;&gt;&lt;/a&gt;剪裁反应堆&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;构建指定几个模块&lt;code&gt;mvn clean install -pl account-email,account-persist&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;构建指定模块及其依赖&lt;code&gt;mvn clean install -pl account-email -am&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;构建指定模块及依赖它的模块&lt;code&gt;mvn clean install -pl account-email -amd&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在完整的反应对顺序上指定从哪个模块开始构建&lt;code&gt;mvn clean install -rf account-email&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在&lt;code&gt;-pl -am / -pl -amd&lt;/code&gt;基础上还能用&lt;code&gt;-rf&lt;/code&gt;再次剪裁&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;常用命令&#34; href=&#34;#常用命令&#34;&gt;&lt;/a&gt;常用命令&lt;/h2&gt;

&lt;p&gt;新建一个空白工程&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;不能用了：·
mvn archetype:create -DgroupId=com.tiemei -DartifactId=p1 -DpackageName=com.tiemei.p1
建web工程加-DarchetypeArtifactId=maven-archetype-webapp
换成：mvn archetype:generate -DgroupId=com.tiemei -DartifactId=zookeeper -DpackageName=com.tiemei.demo.zookeeper -DarchetypeArtifactId=maven-archetype-webapp -DinteractiveMode=false·
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下载依赖源码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mvn dependency:sources
mvn eclipse:eclipse -DdownloadSources=true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看依赖树&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mvn dependency:tree
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;发布&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mvn clean source:jar javadoc:jar deploy 同时发布源码和doc文档
mvn clean deploy 只发布calss jar包
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;常用插件&#34; href=&#34;#常用插件&#34;&gt;&lt;/a&gt;常用插件&lt;/h2&gt;

&lt;p&gt;maven-compiler-plugin&lt;br /&gt;
1. maven2.1 默认用jdk 1.3来编译，这个版本不支持注解，compiler插件可以制定jdk版本为1.6
2. windows平台默认GBK编码，如果工程编码为utf-8，需要再compiler插件中指定&lt;/p&gt;
</description>
    </item>
    <item>
      <title>java锁笔记</title>
      <link>http://defworld.com/2013/08/30/java-locks.html</link>
      <pubDate>2013-08-30 12:00:00 +0800</pubDate>
      <description>&lt;h1&gt;&lt;a style=&#34;display: block;&#34; name=&#34;线程通信&#34; href=&#34;#线程通信&#34;&gt;&lt;/a&gt;线程通信&lt;/h1&gt;

&lt;p&gt;通信遇到的问题包括：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;共享对象：需要做同步处理&lt;/li&gt;
&lt;li&gt;忙等待：循环等待另一个线程发来信号，可sleep&lt;/li&gt;

&lt;li&gt;&lt;p&gt;wait(),notify()&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1. 遇到mobj.wait()，让线程进入非运行状态，直到另一个线程mobj.nitify
2. 这几个方法必须在获得mobj锁的前提下调用，否则IllegalMonitorStateException
3. 一个线程调用了wait()，即释放mobj上的锁
4. 一旦一个线程被唤醒，不能立刻就退出wait()的方法调用，直到调用
notify()的线程退出了它自己的同步块。因此，多个线程被notifyAll唤醒，只有一个
线程可以最终退出wait()方法，因为必须获得mobj的锁
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;丢失的信号（Missed Signal）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;线程A先调用了mobj.notify()，线程B后调用mobj.wait()，通知信号发送过了就被丢弃，
线程B就可能永远不能醒来。
这就需要一个额外的变量来保存‘是否被通知过’的信息。
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;假唤醒（spurious wakeups）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;没有调用过notify()和notifyAll()的情况下醒来，原因未知
需要加个自旋锁，即将wait()方法放到while循环中
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;不要在字符串常量或全局对象中调用wait()。mobj与信号常量不是一一对应。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;mobj: 管程 (英语：Monitors，也称为监视器)&lt;/p&gt;

&lt;h1&gt;&lt;a style=&#34;display: block;&#34; name=&#34;锁&#34; href=&#34;#锁&#34;&gt;&lt;/a&gt;锁&lt;/h1&gt;

&lt;p&gt;锁由synchronized实现，有以下几个特性:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;同一时刻只能有一个线程穿过临界区，进入同步块&lt;/li&gt;
&lt;li&gt;锁的可重入性：synchronized同步块可重入，相应也有可重入锁&lt;/li&gt;
&lt;li&gt;锁的公平性：多个线程不断竞争访问相同的synchronized同步块，可能存在某个
线程一直竞争不到。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;参考&lt;/strong&gt;:&lt;br /&gt;
&lt;a href=&#34;http://ifeve.com/locks/&#34;&gt;Java中的锁&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://ifeve.com/thread-signaling/&#34;&gt;线程通信&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>jdk自带工具</title>
      <link>http://defworld.com/2013/08/30/jdk-tools.html</link>
      <pubDate>2013-08-30 12:00:00 +0800</pubDate>
      <description>&lt;h1&gt;&lt;a style=&#34;display: block;&#34; name=&#34;javah&#34; href=&#34;#javah&#34;&gt;&lt;/a&gt;javah&lt;/h1&gt;

&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;jni示例&#34; href=&#34;#jni示例&#34;&gt;&lt;/a&gt;JNI示例&lt;/h2&gt;

&lt;p&gt;参考:&lt;a href=&#34;https://blogs.oracle.com/moonocean/entry/a_simple_example_of_jni&#34;&gt;JNI example&lt;/a&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;写一个java类，生命navtive方法&lt;/li&gt;
&lt;li&gt;调用javah生成头文件&lt;/li&gt;
&lt;li&gt;写c代码，生成库文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;java -Djava.library.path=&amp;lt;path_of_native_lib&amp;gt; JNIFoo&lt;/code&gt;会默认先载入头文件，
然后按指定的路径查找库文件&lt;/li&gt;
&lt;/ol&gt;

&lt;h1&gt;&lt;a style=&#34;display: block;&#34; name=&#34;jmap(java-memory-map)&#34; href=&#34;#jmap(java-memory-map)&#34;&gt;&lt;/a&gt;jmap(Java Memory Map)&lt;/h1&gt;

&lt;p&gt;参考:&lt;a href=&#34;http://blog.csdn.net/fenglibing/article/details/6411953&#34;&gt;jmap&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;jmap--histo-pid&#34; href=&#34;#jmap--histo-pid&#34;&gt;&lt;/a&gt;jmap -histo pid&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;http://farm8.staticflickr.com/7346/9627329472_b28eba137c.jpg&#34; alt=&#34;jmap output&#34; /&gt;
&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;B代表byte
C代表char
D代表double
F代表float
I代表int
J代表long
Z代表boolean
前边有[代表数组，[I 就相当于int[]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;jmap--heap-pid&#34; href=&#34;#jmap--heap-pid&#34;&gt;&lt;/a&gt;jmap -heap pid&lt;/h2&gt;

&lt;p&gt;查看JVM初始化内存分配，以及各代详细的内存使用&lt;/p&gt;

&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;产生heap-dump文件&#34; href=&#34;#产生heap-dump文件&#34;&gt;&lt;/a&gt;产生heap dump文件&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;jmap -heap:format=b pid&lt;/code&gt; JDK1.5&lt;/li&gt;
&lt;li&gt;&lt;code&gt;jmap -dump:live,format=b,file=xxx pid&lt;/code&gt; JDK1.6&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;jmap--permstat-pid&#34; href=&#34;#jmap--permstat-pid&#34;&gt;&lt;/a&gt;jmap -permstat pid&lt;/h2&gt;

&lt;p&gt;打印一些持久代上的内存使用状态&lt;/p&gt;

&lt;h1&gt;&lt;a style=&#34;display: block;&#34; name=&#34;jstack&#34; href=&#34;#jstack&#34;&gt;&lt;/a&gt;jstack&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;pstree -p pid&lt;/code&gt; 查看某个进程的进程数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;top -H&lt;/code&gt; 线程维度查看&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ps -eLf | grep java | wc&lt;/code&gt; 查看java线程数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ps -Lf 24551&lt;/code&gt;查看某个进程所有线程&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ps mp pid -o THREAD,tid&lt;/code&gt; 查看某个进程下各线程的运行状态&lt;/li&gt;
&lt;li&gt;&lt;code&gt;netstat -anp |grep port&lt;/code&gt; 查看占用某个端口的进程&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;结果分析&#34; href=&#34;#结果分析&#34;&gt;&lt;/a&gt;结果分析&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://iamzhongyong.iteye.com/blog/1441285&#34;&gt;cankao&lt;/a&gt;&lt;br /&gt;
可以分析到：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;死锁：看到线程已获得哪个锁，在等待哪个锁&lt;/li&gt;
&lt;li&gt;程序运行慢：查看waiting状态的几个线程在干嘛&lt;/li&gt;
&lt;li&gt;cpu占用特别高的线程在干什么

&lt;ol&gt;
&lt;li&gt;某个进程占用cpu/mem较高，用ps查看改进程各线程运行状态&lt;/li&gt;
&lt;li&gt;用jstack查看改线程的调用堆栈，定位问题&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;一个例子:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;main&amp;quot; prio=10 tid=0x0000000040c75800 nid=0x5fe8 runnable [0x0000000040209000]
&amp;quot;xxx&amp;quot; - 线程名 
prio  - 优先级 
tid   - 线程id(jmm中内存规范中地址) 
nid   - 是linux下的线程id  
runnable - 线程状态
&amp;quot;main&amp;quot; 主线程，后面接了daemon未守护线程
&amp;quot;http-bio-8080-exec-xxx&amp;quot; http 8080 端口bloked io 线程
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;jvm-pid文件&#34; href=&#34;#jvm-pid文件&#34;&gt;&lt;/a&gt;JVM pid文件&lt;/h2&gt;

&lt;p&gt;jvm运行时会生成一个目录hsperfdata&lt;em&gt;$USER(linux默认在/tmp/hsperfdata&lt;/em&gt;$USER)，存放Pid文件(/etc/cron.daily/tmpwatch会240h移除这个目录)。jstack等工具读取这个文件获取pid。（&lt;a href=&#34;http://windows9834.blog.163.com/blog/static/273450042012919101435608/&#34;&gt;参考&lt;/a&gt;）从Java 6 update 21 ~ 24，会优先&lt;code&gt;-Djava.io.tmpdir&lt;/code&gt;，这样jstack等文件可可能找不到pid文件。&lt;/p&gt;
</description>
    </item>
    <item>
      <title>玩Pi过程中Q&amp;A(持续更新)</title>
      <link>http://defworld.com/2013/06/30/pi-q-a.html</link>
      <pubDate>2013-06-30 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;自己玩Pi过程中遇到的问题，有些只是找到解决方案，原理并没有深究&lt;/p&gt;

&lt;h4&gt;执行apt-get install时，报404 Not Found&lt;/h4&gt;

&lt;p&gt;执行&lt;code&gt;sugo apt-get update&lt;/code&gt;解决&lt;/p&gt;
</description>
    </item>
    <item>
      <title>ssh密钥自动登陆+ssh-agent使用+单机多个ssh账号</title>
      <link>http://defworld.com/2013/06/30/ssh.html</link>
      <pubDate>2013-06-30 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;参考：&lt;br /&gt;
&lt;a href=&#34;http://www.lainme.com/doku.php/blog/2011/01/%E4%BD%BF%E7%94%A8ssh_config#生成ssh证书&#34;&gt;使用SSH CONFIG&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://7056824.blog.51cto.com/69854/403669/&#34;&gt;使用ssh公钥密钥自动登陆linux服务器&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;生成ssh-key&#34; href=&#34;#生成ssh-key&#34;&gt;&lt;/a&gt;生成ssh key&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;ssh -t rsa&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;ssh -t rsa -C &amp;quot;jiadongkai@gmail.com&amp;quot;&lt;/code&gt; 注释用邮箱地址&lt;br /&gt;
将公钥追加到需要登录机器的~/.ssh/authorized_keys，如果无法登陆将~/.ssh/known_hosts
对应行删掉&lt;br /&gt;
注意需要保证authorized_keys文件只有当前用户有写权限&lt;/p&gt;

&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;用ssh-agent省掉passphrase输入&#34; href=&#34;#用ssh-agent省掉passphrase输入&#34;&gt;&lt;/a&gt;用ssh-agent省掉passphrase输入&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;准备ssh-agent需要的环境变量，选择下面的一种方法即可&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;eval `ssh-agent` 只在当前登陆窗口生效
echo &#39;eval `ssh-agent`&#39; &amp;gt;&amp;gt; /etc/profile 每次登陆生效
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;将ssh key对应的passphrase添加到ssh agent高速缓存中&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ssh-add ~/.ssh/private_key_name
你可已查看缓存中内容
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ssh-agent默认打开，你可以关掉&lt;code&gt;ssh-agent -k&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;你有这些特殊需求嘛？-多个ssh帐号、使用非标准端口&#34; href=&#34;#你有这些特殊需求嘛？-多个ssh帐号、使用非标准端口&#34;&gt;&lt;/a&gt;你有这些特殊需求嘛？ 多个ssh帐号、使用非标准端口&lt;/h2&gt;

&lt;p&gt;用ssh config解决，详见&lt;code&gt;man ssh_config&lt;/code&gt;&lt;br /&gt;
编辑&lt;code&gt;~/.ssh/config&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Host pi
  HostName defworld.com
  User pi
  IdentityFile ~/.ssh/id_rsa

Host github
  HostName github.com
  User git
  IdentityFile ~/.ssh/gmail
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;任何使用&lt;code&gt;pi@defworld.com&lt;/code&gt;的地方用&lt;code&gt;pi&lt;/code&gt;代替，例如&lt;code&gt;ssh pi@defworld.com&lt;/code&gt;用&lt;code&gt;ssh pi&lt;/code&gt;代替，
会自动查找指定的密钥&lt;code&gt;id_rsa&lt;/code&gt;进行权限验证。于是，你可以单机保存多个密钥。&lt;/p&gt;
</description>
    </item>
    <item>
      <title>.bashrc .bash_profile等文件区别</title>
      <link>http://defworld.com/2013/06/28/about-bashrc.html</link>
      <pubDate>2013-06-28 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;&lt;strong&gt;/etc/profile&lt;/strong&gt;&lt;br /&gt;
全局，用户第一次登录执行一次&lt;br /&gt;
会从/etc/profile.d目录的配置文件中搜集shell的设置.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;/etc/bashrc&lt;/strong&gt;&lt;br /&gt;
全局，bash shell配置，一般由/etc/profile调用&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;~/.bash_profile&lt;/strong&gt;&lt;br /&gt;
似有，用户登录(ssh远程登陆/本地新开一个terminal)时执行一次
一般会调用~/.bashrc&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;~/.bashrc&lt;/strong&gt;&lt;br /&gt;
似有，每次执行bash命令时自动调用，或者非交互方式进入bash时运行&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;~/.bash_logout&lt;/strong&gt;&lt;br /&gt;
当每次退出系统(退出bash shell)时,执行该文件.&lt;/p&gt;
</description>
    </item>
    <item>
      <title>我的svn git常用命令及配置</title>
      <link>http://defworld.com/2013/06/27/svn-git-cmds.html</link>
      <pubDate>2013-06-27 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;参考:&lt;br /&gt;
&lt;a href=&#34;http://blog.csdn.net/sunboy_2050/article/details/6187464&#34;&gt;SVN常用命令&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://www.subversion.org.cn/svnbook/1.4/svn.ref.svn.c.diff.html&#34;&gt;svn diff&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;svn&#34; href=&#34;#svn&#34;&gt;&lt;/a&gt;svn&lt;/h2&gt;

&lt;h3&gt;常用命令&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;svn co remote-svn-path local-dir --username tiemei&lt;/code&gt;签出&lt;/li&gt;
&lt;li&gt;&lt;code&gt;svn cp base-svn-path new-svn-path -m &amp;quot;commit log&amp;quot;&lt;/code&gt;新建分支&lt;/li&gt;
&lt;li&gt;&lt;code&gt;svn diff -r m path/file&lt;/code&gt; 比较工作拷贝和某个版本的区别&lt;/li&gt;
&lt;li&gt;&lt;code&gt;svn diff -c m path/file&lt;/code&gt; 查看某个版本修改的内容&lt;/li&gt;
&lt;li&gt;&lt;code&gt;svn diff --diff-cmd /usr/bin/diff -x &amp;quot;-i -b&amp;quot; COMMITTERS&lt;/code&gt; 指定外部diff程序&lt;/li&gt;
&lt;li&gt;&lt;code&gt;svn diff -r m:n path&lt;/code&gt; 比较两个版本文件差异&lt;/li&gt;
&lt;li&gt;&lt;code&gt;svn diff -r m:n path |grep &amp;quot;Index:&amp;quot;&lt;/code&gt; 比较两个版本间变化的文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;svn info path&lt;/code&gt; 列出某个path svn信息&lt;/li&gt;
&lt;li&gt;&lt;code&gt;svn log path&lt;/code&gt; 查看path提交log&lt;/li&gt;
&lt;li&gt;&lt;code&gt;svn log -l4&lt;/code&gt;  查看前四个提交log&lt;/li&gt;
&lt;li&gt;&lt;code&gt;svn ls path&lt;/code&gt;  列出某个路径下内容(与远程交互)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;svn mkdir path&lt;/code&gt; 远程增加某个path&lt;/li&gt;
&lt;li&gt;&lt;code&gt;svn cat /path/to/file&lt;/code&gt; 打印某个文件内容&lt;/li&gt;
&lt;li&gt;&lt;code&gt;svn st path&lt;/code&gt; 只输出状态有变化的文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;svn st -v path&lt;/code&gt; 列出所有文件详细状态信息&lt;/li&gt;
&lt;li&gt;&lt;code&gt;svn add file/dir&lt;/code&gt;&lt;code&gt;svn ci m &amp;quot;comment log&amp;quot;&lt;/code&gt; 添加文件，提交变动&lt;/li&gt;
&lt;li&gt;&lt;code&gt;svn rm path/file&lt;/code&gt; 移除某个分支/文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;svn merge URL local_dir/url&lt;/code&gt;合并分支，先将原分支cm，然后merge到本地新开发分支，
或者merge到远程svn新分支&lt;/li&gt;
&lt;li&gt;&lt;code&gt;svn update -r version&lt;/code&gt;更新到指定版本&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;配置&lt;/h3&gt;

&lt;h4&gt;排除&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;全局排除&lt;/strong&gt;&lt;br /&gt;
~/.subversion/conf文件中global-ignores&lt;br /&gt;
&lt;strong&gt;局部排除&lt;/strong&gt;&lt;br /&gt;
* &lt;code&gt;svn ps svn:ignore ignore_pattern .&lt;/code&gt; 设置当前目录排除ignore_file脱离版本控制
* &lt;code&gt;svn ps svn:ignore -F .svnignore .&lt;/code&gt; 指定文件.svnignore
* &lt;code&gt;svn pe svn:ignore . --editor-cmd=vim&lt;/code&gt; 用vim来编辑需排除的pattern列表，与.svnignore方式互斥&lt;/p&gt;

&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;git&#34; href=&#34;#git&#34;&gt;&lt;/a&gt;git&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://git-scm.com/book/zh/Git-%E5%88%86%E6%94%AF-%E4%BD%95%E8%B0%93%E5%88%86%E6%94%AF&#34;&gt;Git 分支 - 何谓分支&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;git remote add origin remote-url&lt;/code&gt; 将本地仓库与远程仓库remote-url绑定，可以绑定多个。一般用origin，因为git clone默认设置origin&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git push -u origin master&lt;/code&gt; 提交到别名为origin的远程仓库的master分支&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git remote -v&lt;/code&gt; 列出本地绑定的所有远程仓库&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;http://farm4.staticflickr.com/3701/9147517685_85e9e01925.jpg&#34; alt=&#34;git提交状态&#34; /&gt;
&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;git add file/dir&lt;/code&gt;&lt;code&gt;git commit -m &#39;commit log&#39;&lt;/code&gt;上图很形象的说明了git命令和文件所处状态的变化关系。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git commit -a -m &amp;quot;commit log&amp;quot;&lt;/code&gt; 将add和commit动作合并，不过只作用域变化的文件，对新增文件无效&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git log&lt;/code&gt;查看commit历史 &lt;code&gt;git log --pretty=oneline --abbrev-commit&lt;/code&gt;查看commit历史，简明格式&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;http://farm6.staticflickr.com/5331/9149824940_25f19bf055.jpg&#34; alt=&#34;git回退&#34; /&gt;
&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;git checkout file/dir&lt;/code&gt; 用index中文件覆盖working tree中文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git reset HEAD file&lt;/code&gt;   用commit中文件覆盖index中文件,HEAD为commit log前几位字符(唯一就行)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git revert HEAD&lt;/code&gt;       undo某次commit动作，你也可以undo更老些的commit&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git show HEAD&lt;/code&gt;         show diff from one commmit compared to its parent&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git diff HEAD1..HEAD2&lt;/code&gt; 两个commit之间的变化&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;http://farm8.staticflickr.com/7443/9149898002_3c3513af25.jpg&#34; alt=&#34;git tag&#34; /&gt;
&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;git tag wokring 3720b35&lt;/code&gt;&lt;code&gt;git tag broken&lt;/code&gt; 给某次commit加tag&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git diff working..broken&lt;/code&gt; tag可以被用在HEAD出现的任何地方&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;branche&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;http://farm8.staticflickr.com/7384/9150086081_dfe8ef4bce.jpg&#34; alt=&#34;git branche&#34; /&gt;
&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;git branche&lt;/code&gt; 查看有几个分支，以及活动分支&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git branch -r&lt;/code&gt; 列出服务器仓库所有分支&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git branche &amp;lt;name&amp;gt; &amp;lt;commit&amp;gt;&lt;/code&gt; commit指定新branche的起始点，默认最新一次commit&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git checkout &amp;lt;branchname&amp;gt;&lt;/code&gt; 指定当前活动分支，与从Index同步文件命令意义不同&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在新分支上commit后，然后又切回master，状态如下图：&lt;br /&gt;
&lt;img src=&#34;http://farm8.staticflickr.com/7350/9150130937_6908be5258.jpg&#34; alt=&#34;git branche 2&#34; /&gt;
&lt;br /&gt;
接着，你又在master分支上commit，状态变成:&lt;br /&gt;
&lt;img src=&#34;http://farm6.staticflickr.com/5547/9152373240_ee693532ee.jpg&#34; alt=&#34;git branche 3&#34; /&gt;
&lt;/p&gt;

&lt;h3&gt;merging&lt;/h3&gt;

&lt;p&gt;你在新branche开发完毕，要将变动合并到master，你将执行&lt;code&gt;git merge newfeature&lt;/code&gt;，如果没有冲突，最终状态如下图：&lt;br /&gt;
&lt;img src=&#34;http://farm6.staticflickr.com/5529/9152407936_c8898f484e.jpg&#34; alt=&#34;git merging&#34; /&gt;
&lt;br /&gt;
如果发生冲突，你将看到这样提示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CONFLICT (content): Merge conflict in somefile.txt
Automatic merge failed; fix conflicts and then commit the result.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你需要手动解决冲突，冲突的文件中冲突处类似下面格式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt; HEAD:somefile.txt
this change was done in master
=======
this change was done in newfeature
&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; newfeature:somefile.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;改好后commit，你就可以删掉branche了&lt;code&gt;git branche -d newfeature&lt;/code&gt;&lt;/p&gt;

&lt;h3&gt;配置&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;git config --global color.ui auto&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git config user.name &amp;quot;Bob&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git config user.email &amp;quot;bob@example.com&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git config --global user.name &amp;quot;Bob&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git config --global user.email &amp;quot;bob@example.com&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;直接编辑.git/config&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    <item>
      <title>近一年来shell命令积累(随时更新)</title>
      <link>http://defworld.com/2013/06/12/my-shell-mannual.html</link>
      <pubDate>2013-06-12 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;参考:&lt;br /&gt;
&lt;a href=&#34;http://roclinux.cn/&#34;&gt;linux命令五分钟系列博文，写的简洁易懂&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#awk&#34;&gt;awk&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#echo&#34;&gt;echo&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#expect&#34;&gt;expect&lt;/a&gt; 对命令行提示输入自动输入，如密码验证&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#cut&#34;&gt;cut&lt;/a&gt;      字节/字符/域（特殊字符分隔）的按行切割&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#paste&#34;&gt;paste&lt;/a&gt;  多文件按行连接/一个文件多行连接&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#split&#34;&gt;split&lt;/a&gt; 按行/大小拆分文件&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#sed&#34;&gt;sed&lt;/a&gt; stream editor,面向行处理，输出到标准输出&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#awk&#34;&gt;awk&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#xargs&#34;&gt;xargs&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#cat&#34;&gt;cat&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#tac&#34;&gt;tac&lt;/a&gt; 逆向输出文件&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#date&#34;&gt;date&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#截取子串&#34;&gt;截取子串&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#其他&#34;&gt;其他&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#find&#34;&gt;find&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#service&#34;&gt;service&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#du&#34;&gt;du&lt;/a&gt; disk usage，目录及文件大小&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#chkconfig&#34;&gt;chkconfig&lt;/a&gt; 设置各个系统运行级别启动的服务&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#uname&#34;&gt;unmae&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#tr&#34;&gt;tr&lt;/a&gt; 标准输入到标准输出的字符串转译&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;[压缩和解压](#压缩和解&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#shudown&#34;&gt;shutdown&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#chsh&#34;&gt;chsh&lt;/a&gt; choose shell&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#man&#34;&gt;man&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#who am i&#34;&gt;who am i&lt;/a&gt;- &lt;a href=&#34;#wc&#34;&gt;wc&lt;/a&gt; 字符/字节/最长行字符数/行数 统计&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#vim&#34;&gt;vim&lt;/a&gt; 字符替换&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#sort&#34;&gt;sort&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#ln&#34;&gt;ln&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#sar&#34;&gt;sar&lt;/a&gt;  收集、汇报与存储CPU/IO..信息&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#netstat&#34;&gt;netstat&lt;/a&gt; 和netstat说再见！官方都不维护了！&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#ss&#34;&gt;ss&lt;/a&gt; Socket Statistics&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#iproute2&#34;&gt;iproute2&lt;/a&gt; 于TCP/IP协议的流量控制工具套装,取代原来包含netstat的套装net-tools&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#实时观察文件变化&#34;&gt;实时观察文件变化&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#ps&#34;&gt;ps&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#shuf&#34;&gt;shuf&lt;/a&gt; 打乱文本的行&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#rpm&#34;&gt;rpm&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#grep&#34;&gt;grep&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#screen&#34;&gt;screen&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#script/scriptrelay&#34;&gt;script/scriptrelay&lt;/a&gt; 终端演示&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;[pushd/popd]#(#pushd/popd) 目录压栈出栈&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#touch&#34;&gt;touch&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;http相关&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#wget&#34;&gt;wget&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#curl&#34;&gt;curl&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;&lt;a id=&#34;awk&#34;&gt;&lt;font color=&#34;green&#34;&gt;awk&lt;/font&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://124.16.151.186/docs/linux/script/Awk-1index.shtml#12&#34;&gt;入门一&lt;/a&gt;_&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;awk &amp;lsquo;{ print }&amp;rsquo; file # 对每一行都执行{}内的命令&lt;/li&gt;
&lt;li&gt;$0表示整行，$1&amp;hellip;表示第几几个字段，分割符可制定-F &amp;lsquo;:&amp;rsquo;&lt;/li&gt;
&lt;li&gt;&amp;rsquo;{ print $1 &amp;ldquo; &amp;rdquo; $3 }&amp;rsquo; 这样才会在两个字段间插入空格&lt;/li&gt;

&lt;li&gt;&lt;p&gt;外部脚本 awk -f myscript.awk file&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# myscript.awk
BEGIN {
  FS=&amp;quot;:&amp;quot; # 不同的是，这里没有用-F参数设置分隔符
} 
{ print $1 }
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;BEFIN END 在处理所有行之前和之后做一次的事，前者通常设置FS，打印页眉，或初始化全局变量，后者执行最终计算或输出结尾摘要&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;规则表达式和快&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/foo/ { print }，指数出有foo的行，/[0-9]+\.[0-9]*/ { print },浮点数 
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;表达式和块&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$1 == &amp;quot;fred&amp;quot; { print $3 } 只有第一字段是fred时才输出
可用： == &amp;lt; &amp;gt; &amp;lt;= &amp;gt;= !=  ~ !~
$5 ~ /root/ { print $3 } 匹配时才


() &amp;amp;&amp;amp;/|| () {}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;条件语句&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;上个例子等价于：
{
    if ( $5 ~ /root/ ) {
       print $3
    }
}
复杂例子：
{
    if ( $1 == &amp;quot;foo&amp;quot; ) {
        if ( $2 == &amp;quot;foo&amp;quot; ) {
            print &amp;quot;&amp;quot;
        } else {
            print &amp;quot;&amp;quot;
        }
    } else if ( $1 == &amp;quot;bar&amp;quot; ) {
        print &amp;quot;&amp;quot;
    } else { 
        print &amp;quot;&amp;quot;
    }
 }


 ! /match/ {}
 等价 
 {
     if ( $0 !~ /match/ ) {
     }
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;数值运算&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; BEFIN { x=0 }
 /^$/  { x=x+1 }
 END   { print &amp;quot;Blank line num: &amp;quot; x }
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;字符串到数字的转换自动发生&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; x=&amp;quot;1.01&amp;quot;
 x=x+1
 print x # 2.01


 bash需要放到$()中，而python需要显示转换
 awk { print ($1^2)+1 } ，如果不能成功转换默认0
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;众多运算符&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; + - * / 
 ++ --（前后都支持）
 += -= *= /=
 ^ % ^= %=
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;字段分隔符&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; FS 可指定任意长度
 FS=&amp;quot;\t+&amp;quot; 一个或多个
 FS=&amp;quot;[[:space:]+]&amp;quot; 其实默认就是一个或多个空格tab
 FS=&amp;quot;foo[0-9][0-9][0-9]&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;其他特殊变量&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; NF 字段数量，当前记录中的字段数量
 NR 记录号，比如当前行号
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h6&gt;四行合一行&lt;/h6&gt;

&lt;pre&gt;&lt;code&gt;[code:1:bde308dcc7]cat filename
111111111
222222222
333333333
444444444
555555555
666666666
777777777
888888888
999999999
awk &#39;{if (NR%4==0){print $0} else {printf&amp;quot;%s &amp;quot;,$0}}&#39; filename
111111111 222222222 333333333 444444444
555555555 666666666 777777777 888888888
999999999
&lt;/code&gt;&lt;/pre&gt;

&lt;h6&gt;按特殊符号分隔 $NF表示最后一个匹配到的&lt;/h6&gt;

&lt;pre&gt;&lt;code&gt;    cat file1
&amp;gt; 111.222
&amp;gt; 3333.44
cat file1 | awk -F &#39;.&#39; &#39;{printf &amp;quot;%s %s&amp;quot;,$1,$2}&#39;
&amp;gt; 111 222
&amp;gt; 3333 44
&lt;/code&gt;&lt;/pre&gt;

&lt;h6&gt;split内建命令&lt;/h6&gt;

&lt;pre&gt;&lt;code&gt;awk &#39;BEGIN{begno=&amp;quot;1,2,3&amp;quot;;split(begno,str,&amp;quot;,&amp;quot;);print str[1],str[2],str[3]}&#39;
&amp;gt; 1 2 3
&lt;/code&gt;&lt;/pre&gt;

&lt;h6&gt;awk其他教程&lt;/h6&gt;

&lt;pre&gt;&lt;code&gt;[csdn博文](http://suo.iteye.com/blog/1319525)  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://124.16.151.186/docs/linux/script/Awk-1index.shtml&#34;&gt;awk实例&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;&lt;a id=&#34;echo&#34;&gt;&lt;font color=&#34;green&#34;&gt;echo&lt;/font&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;h6&gt;输出换行&lt;/h6&gt;

&lt;pre&gt;&lt;code&gt;echo &amp;quot;line1\nline2&amp;quot;
&amp;gt; line1\nline2
echo -e line1\n\line2
&amp;gt; line1
&amp;gt; line2
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;&lt;a id=&#34;expect&#34;&gt;&lt;font color=&#34;green&#34;&gt;expect&lt;/font&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://en.wikipedia.org/wiki/Expect#Examples&#34;&gt;wiki&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;&lt;a id=&#34;cut&#34;&gt;&lt;font color=&#34;green&#34;&gt;cut&lt;/font&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://roclinux.cn/?p=1328&#34;&gt;网友博文：《cut命令》-linux命令五分钟系列之十九&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 定位格式
3 /3-5 / 4- / -2

# 按字节切割
[rocrocket@rocrocket programming]$ who
rocrocket :0           2009-01-08 11:07
rocrocket pts/0        2009-01-08 11:23 (:0.0)
rocrocket pts/1        2009-01-08 14:15 (:0.0)

[rocrocket@rocrocket programming]$ who|cut -b 3-5,8
croe
croe
croe

# 按字符切割
[rocrocket@rocrocket programming]$ cat cut_ch.txt
星期一
星期二
星期三
星期四
[rocrocket@rocrocket programming]$ cut -b 3 cut_ch.txt
�
�
�
�
[rocrocket@rocrocket programming]$ cut -c 3 cut_ch.txt
一
二
三
四

# -n选项
[rocrocket@rocrocket programming]$ cat cut_ch.txt |cut -nb 2

[rocrocket@rocrocket programming]$ cat cut_ch.txt |cut -nb 1,2,3
星
星
星
星

# 按域（特殊字符分隔）切割
# cut的-d选项的默认间隔符就是制表符，如果分隔符为空格，用&#39; &#39;(只允许一个空格，因为cut只允许间隔符为一个字符)
[rocrocket@rocrocket programming]$ cat /etc/passwd|head -n 5
root:x:0:0:root:/root:/bin/bash
bin:x:1:1:bin:/bin:/sbin/nologin
daemon:x:2:2:daemon:/sbin:/sbin/nologin
adm:x:3:4:adm:/var/adm:/sbin/nologin
lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin
[rocrocket@rocrocket programming]$ cat /etc/passwd|head -n 5|cut -d : -f 1
root
bin
daemon
adm
lp

# 制表符和空格区分，制表符显示为&amp;quot;\t&amp;quot;，空格原样显示
sed -n l tab_space.txt

# 不足
-d 选项多空格分隔符不支持
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;&lt;a id=&#34;cat&#34;&gt;&lt;font color=&#34;green&#34;&gt;cat&lt;/font&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;h6&gt;用cat合并文件技巧&lt;/h6&gt;

&lt;p&gt;&lt;a href=&#34;http://www.ibm.com/developerworks/cn/linux/l-tip-prompt/l-tiptex2/&#34;&gt;IBM Dev博文&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;&lt;a id=&#34;date&#34;&gt;&lt;font color=&#34;green&#34;&gt;date&lt;/font&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://xingfujie.blog.51cto.com/2791569/637223&#34;&gt;参考&lt;/a&gt;
&lt;code&gt;date –I –d &#39;-n day&#39;&lt;/code&gt;   (可以得到N天前的日期，格式为YYYY-MM-DD)
&lt;code&gt;date –d &#39;-n day&#39; &amp;quot;+Y%m%d&amp;quot;&lt;/code&gt;       (可以得到你天前的日期，格式为YYYYMMDD)&lt;/p&gt;

&lt;p&gt;&lt;code&gt;date –I –d &#39;+n day&#39;&lt;/code&gt;   (可以得到N天后的日期，格式为YYYY-MM-DD)
&lt;code&gt;date –d &#39;+n day&#39; &amp;quot;+%Y%m%d&amp;quot;&lt;/code&gt;       (可以得到你天后的日期，格式为YYYYMMDD)&lt;br /&gt;
&lt;code&gt;date +%s.%N&lt;/code&gt; (%s是秒，%N是纳秒，需要ms可以对输出做一个计算，基本可作为唯一字符戳)&lt;/p&gt;

&lt;h4&gt;时间戳格式化日期互转&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;date -d @1287331200  &amp;quot;+%Y-%m-%d %M:%S&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;date -d &amp;ldquo;2010-10-18 00:00:00&amp;rdquo; +%s 输出时间戳&lt;/li&gt;

&lt;li&gt;&lt;p&gt;指定时间前后几天&lt;/p&gt;

&lt;p&gt;s=&lt;code&gt;date -d &amp;quot;2010-10-10 00:00:00&amp;quot; +%s&lt;/code&gt;
   s_new=&lt;code&gt;expr $s + 86400&lt;/code&gt; # 加上一条的秒数
   date_new=&lt;code&gt;date -d @$s_new &amp;quot;+%Y-%m-%d&amp;quot;&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;&lt;a id=&#34;截取子串&#34;&gt;&lt;font color=&#34;green&#34;&gt;截取子串&lt;/font&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;h3&gt;&lt;a id=&#34;其他&#34;&gt;&lt;font color=&#34;green&#34;&gt;其他&lt;/font&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://blog.sina.com.cn/s/blog_69516b7f01015j34.html&#34;&gt;linux下grep分析APACHE 服务器日志 命令集合&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;&lt;a id=&#34;find&#34;&gt;&lt;font color=&#34;green&#34;&gt;find&lt;/font&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;分几个维度查找：&lt;br /&gt;
&lt;code&gt;find . -name file_name&lt;/code&gt; # 文件名&lt;br /&gt;
&lt;code&gt;fine . -type d -name file_name&lt;/code&gt; # 文件类型,f(普通文件),l(链接文件)&lt;br /&gt;
&lt;code&gt;find . -user tiemei&lt;/code&gt; # 用户/用户组&lt;br /&gt;
&lt;code&gt;find . -perm 755&lt;/code&gt; # 权限&lt;br /&gt;
&lt;code&gt;find . -regex &#39;.*b.*3&#39;&lt;/code&gt; # 正则过滤&lt;br /&gt;
&lt;code&gt;find . -type f -name “*.abc” -exec cat {} \&lt;/code&gt;&lt;br /&gt;
                 # 输出找到项的内容， -exec 表示找到的项作为后面命令的参数， -ok 表示每个匹配项用户确认是否输出，{}表示find查找的结果。&lt;br /&gt;
&lt;code&gt;find . -amin -5&lt;/code&gt;&lt;br /&gt;
                 # 访问过用amin，修改过用mmin，文件状态改变过用cmin&lt;br /&gt;
                 # 精确到分钟的用amin,mmin,cmin，精确到天的用atime,mtime,ctime&lt;br /&gt;
                 #  在5分钟之内的用-5，在5分钟以上的用＋5&lt;br /&gt;
&lt;code&gt;find . -size +10000000c&lt;/code&gt;&lt;br /&gt;
                 # -size：表示文件大小，＋表示大于某个数，－表示小于某个数。c表示单位是字节，你可以将c换成k,M,G&lt;/p&gt;

&lt;p&gt;&lt;code&gt;find . -maxdepth 1 -name “*.c”&lt;/code&gt;  # 不想深入子目录，只想在当前目录&lt;/p&gt;

&lt;h4&gt;递归修改目录、文件权限&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;find -type d -exec chmod 755 {} \;&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;find -type d|xargs chmod 755&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;find -not -type d -exec chmod 644 {} \;&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;find -not -type d|xargs chmod 644&lt;/code&gt;&lt;/p&gt;

&lt;h3&gt;&lt;a id=&#34;xargs&#34;&gt;&lt;font color=&#34;green&#34;&gt;xargs&lt;/font&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://heikezhi.com/yuanyi/things-you-didnt-know-about-xargs&#34;&gt;关于xargs，你可能不知道的&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://sidvind.com/wiki/Xargs_by_example&#34;&gt;Xargs by example&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://stackoverflow.com/questions/10803296/modifying-replace-string-in-xargs&#34;&gt;一个例子，找到所有txt结尾文件并在文件中间插入特殊字符&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;默认从管道传递过来的值是放在命令最后的&lt;/li&gt;
&lt;li&gt;If utility is omitted, echo(1) is used&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-I&lt;/code&gt;&lt;code&gt;find . -name &amp;quot;*&amp;quot; | xargs -I {} cp {} /home/ads&lt;/code&gt; -I将管道传递过来的输出作为参数，用符号{}代替&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-J&lt;/code&gt;用法和&lt;code&gt;-I&lt;/code&gt;有些区别&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-n&lt;/code&gt;如果要执行的命令只接收两个参数，&lt;code&gt;echo {0..9} | xargs -n 2&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-L&lt;/code&gt;将多个非空白行合并成后接命令的一次参数输出，与&lt;code&gt;-n&lt;/code&gt;冲突，同时出现以最后一个为准&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-t&lt;/code&gt;展示将要被执行的命令&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-s&lt;/code&gt;最终执行的命令的字符最大长度&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-R&lt;/code&gt;最大用于替换的-I指定的replstr数据，例如&lt;code&gt;echo {1..10} | xargs -I {} -n 1 -R 1 echo {} {}&lt;/code&gt;
只替换echo后前一个{}&lt;/li&gt;
&lt;li&gt;find + xargs 常用来批量处理文件，不过文件名或者目录有空格会出现问题，因为xargs会按照空格来
划分输入，给find加上&lt;code&gt;-print0&lt;/code&gt;选项告诉find使用NUL(\0)来分割结果，同时给xargs加上&lt;code&gt;-0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-P&lt;/code&gt;并行调用例如&lt;code&gt;time echo {1..5} | xargs -n 1 -P 5 sleep&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-p&lt;/code&gt;交互确认当前某个命令是否执行&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ls / |xargs -I% sh -c &#39;n=%;echo &amp;quot;[$n]&amp;quot;&#39;&lt;/code&gt; 使用sh -c执行复杂的处理&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;&lt;a id=&#34;service&#34;&gt;&lt;font color=&#34;green&#34;&gt;&lt;a href=&#34;http://roclinux.cn/?p=47&#34;&gt;service&lt;/a&gt;&lt;/font&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;service httpd start/stop/restart/reload&lt;/code&gt;(重新载入配置)&lt;br /&gt;
位于/sbin目录下，一脚本命令，动作是去/etc/init.d目录下寻找相应服务。&lt;br /&gt;
不是所有发行版都提供&lt;/p&gt;

&lt;h3&gt;&lt;a id=&#34;du&#34;&gt;&lt;font color=&#34;green&#34;&gt;du&lt;/font&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;du -h .&lt;/code&gt; # 当年前目录下所有目录以及子目录的大小
&lt;code&gt;du -ch abc | tail -n 1&lt;/code&gt; # 只想看abc目录大小，-c 表示最后计算出所有目录大小之和&lt;br /&gt;
&lt;code&gt;du -sh abc&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;du -h -max-depth=0 abc&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;du -ah abc&lt;/code&gt; # 列出abc及其子目录下所有目录和文件大小&lt;br /&gt;
&lt;code&gt;du -h -exclude=&#39;*xyz*&#39;&lt;/code&gt; # 不包含xyz字符串的目录&lt;br /&gt;
&lt;code&gt;du -0h abc&lt;/code&gt; # -0不换行，直接输出下一个&lt;/p&gt;

&lt;h3&gt;&lt;a id=&#34;chkconfig&#34;&gt;&lt;font color=&#34;green&#34;&gt;chkconfig&lt;/font&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;# 增加一个服务步骤&lt;br /&gt;
- 服务脚本放在/etc/ini.d/下&lt;br /&gt;
- &lt;code&gt;chkconfig -add servicename&lt;/code&gt; 增加，此时服务会被在/etc/rc.d/rcN.d中赋予K/S入口了&lt;br /&gt;
- 设置服务默认启动等级&lt;/p&gt;

&lt;p&gt;&lt;code&gt;chkconfig -list&lt;/code&gt; # 系统所有服务启动情况&lt;br /&gt;
&lt;code&gt;chkconfig -list mysqld&lt;/code&gt; # mysqld服务设置情况&lt;br /&gt;
&lt;code&gt;chkconfig -level 35 mysqld on&lt;/code&gt; # 只在等级3 5 执行，off表示关闭&lt;br /&gt;
&lt;code&gt;chkconfig mysqld on&lt;/code&gt;&lt;br /&gt;
                    # 各等级(2 3 4 5)为on&lt;br /&gt;
                    # 0 关机; 1 单用户模式;2 无网络连接的多用户命令行模式；&lt;br /&gt;
                    # 3 有网络连接的多用户命令行模式；4 不可用；5 带图形界面的多用户模式；6 重新启动&lt;br /&gt;
&lt;code&gt;chkconfig -del sevicename&lt;/code&gt; # 删除&lt;/p&gt;

&lt;h3&gt;&lt;a id=&#34;uname&#34;&gt;&lt;font color=&#34;green&#34;&gt;uname&lt;/font&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;uname -a&lt;/code&gt; 打印所有系统信息&lt;br /&gt;
&lt;code&gt;uname -s&lt;/code&gt; 打印内核名称&lt;br /&gt;
&lt;code&gt;uname -n&lt;/code&gt; 打印网络节点主机名&lt;br /&gt;
&lt;code&gt;uname -r&lt;/code&gt; 答应内核发信版本号&lt;br /&gt;
查看系统版本号方法还有：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;cat /proc/version&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cat /etc/redhat-release&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cat /etc/issue&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;&lt;a id=&#34;tr&#34;&gt;&lt;font color=&#34;green&#34;&gt;tr&lt;/font&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;cat filename | tr u n&lt;/code&gt;  将u替换为n&lt;br /&gt;
&lt;code&gt;cat filename | tr -d abc&lt;/code&gt; 将所有a/b/c字符删去&lt;br /&gt;
&lt;code&gt;cat filename | tr [:lower:] [:upper:]&lt;/code&gt;  小写变大写&lt;br /&gt;
&lt;code&gt;[:alnum:]&lt;/code&gt;  所有字符数字&lt;br /&gt;
&lt;code&gt;[:alpha:]&lt;/code&gt; 表示所有的字母&lt;br /&gt;
&lt;code&gt;[:blank:]&lt;/code&gt; 表示所有空格&lt;br /&gt;
&lt;code&gt;[:digit:]&lt;/code&gt; 表示所有数字&lt;br /&gt;
&lt;code&gt;[:graph:]&lt;/code&gt; 表示所有可打印字符，但不包括空格&lt;br /&gt;
&lt;code&gt;[:print:]&lt;/code&gt; 表示所有可打印字符，包括空格&lt;/p&gt;

&lt;h3&gt;&lt;a id=&#34;压缩和解压&#34;&gt;&lt;font color=&#34;green&#34;&gt;压缩和解压&lt;/font&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;RAR&lt;/strong&gt;&lt;br /&gt;
去下面的网站下载一个RAR命令&lt;br /&gt;
&lt;a href=&#34;http://www.rarlab.com/download.htm&#34;&gt;http://www.rarlab.com/download.htm&lt;/a&gt;&lt;br /&gt;
解压后，在rar文件夹make&lt;/p&gt;

&lt;p&gt;&lt;code&gt;rar x解压 rar文件&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ZIP&lt;/strong&gt;&lt;br /&gt;
适用Linux， Windows以及Mac OS。压缩率不是很高，而tar.gz和tar.gz2在压缩率方面做得非常好。&lt;br /&gt;
压缩一个目录：&lt;br /&gt;
 &lt;code&gt;zip -r archive_name.zip directory_to_compress&lt;/code&gt; 压缩目录&lt;br /&gt;
 &lt;code&gt;zip -r a.zip abc.txt dir1&lt;/code&gt; 压缩目录和文件到一起
解压一个zip文档：&lt;br /&gt;
&lt;code&gt;unzip archive_name.zip&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;unzip abc\?.zip&lt;/code&gt; 解压缩多个文件（支持正则）abc1.zip，abc2.zip和abc3.zip&amp;hellip;&lt;br /&gt;
&lt;code&gt;unzip -j music.zip&lt;/code&gt; 内部子目录内容全部解压到一级目录&lt;br /&gt;
查看：&lt;br /&gt;
&lt;code&gt;unzip -v large.zip&lt;/code&gt;  内部内容&lt;br /&gt;
&lt;code&gt;unzip -t large.zip&lt;/code&gt;  下载的文件是否完整&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;tar&lt;/strong&gt;&lt;br /&gt;
打包一个目录：&lt;br /&gt;
 &lt;code&gt;tar -cvf archive_name.tar directory_to_compress[ dir2]&lt;/code&gt;单个/多个目录打包&lt;br /&gt;
 &lt;code&gt;tar -cvf my.tar file1[ file2]&lt;/code&gt;单个/多个文件打包
如何解包：&lt;br /&gt;
&lt;code&gt;tar -xvf archive_name.tar.gz&lt;/code&gt;&lt;br /&gt;
上面这个解包命令将会将文档解开在当前目录下面。当然，你也可以用这个命令来捏住解包的路径&lt;br /&gt;
&lt;code&gt;tar -xvf archive_name.tar -C /tmp/extract_here/&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;tar.gz&lt;/strong&gt;&lt;br /&gt;
它在压缩时不会占用太多CPU的，而且可以得到一个非常理想的压缩率。&lt;br /&gt;
&lt;code&gt;tar -xzvf abc.tar.gz/abc.tgz&lt;/code&gt;  解压缩&lt;br /&gt;
上面这个解包命令将会将文档解开在当前目录下面。当然，你也可以用这个命令来捏住解包的路径：&lt;br /&gt;
&lt;code&gt;tar -zxvf archive_name.tar.gz -C /tmp/extract_here/&lt;/code&gt;
&lt;code&gt;tar -xzvpf abc.tar.gz&lt;/code&gt; 解压保留原被压缩文件权限&lt;br /&gt;
&lt;code&gt;tar -czvf dirabc.tar.gz dirabc&lt;/code&gt; 压缩文件夹&lt;/p&gt;

&lt;p&gt;&lt;code&gt;tar -ztvf abc.tar.gz&lt;/code&gt; 仅仅是查看&lt;br /&gt;
&lt;code&gt;tar -xzvf abc.tar.gz def/xyz.txt&lt;/code&gt; 只提取一个文件&lt;/p&gt;

&lt;p&gt;&lt;code&gt;tar -xvf abc.tar&lt;/code&gt; 解开包（并没有解压缩动作）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;gizp : gz&lt;/strong&gt;&lt;br /&gt;
&lt;code&gt;gzip -d xyz.gz&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;gzip -1 abc.tar&lt;/code&gt; 压缩的最快，或用&amp;ndash;fast,压缩比有1~9,9也可为&amp;ndash;best&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;TAR.BZ2&lt;/strong&gt;&lt;br /&gt;
bunzip2/bzip2&lt;br /&gt;
所有方式中压缩率最好的。就意味着，占用更多的CPU与时间。&lt;br /&gt;
压缩:&lt;br /&gt;
&lt;code&gt;tar -jcvf archive_name.tar.bz2 directory_to_compress&lt;/code&gt;&lt;br /&gt;
用这个命令来捏住解包的路径：&lt;br /&gt;
&lt;code&gt;tar -jxvf archive_name.tar.bz2 -C /tmp/extract_here/&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;bzip2&lt;/strong&gt;&lt;br /&gt;
&lt;code&gt;bzip2 abc.txt&lt;/code&gt; 压缩后得到abc.txt.bz2,原文件被删除&lt;br /&gt;
&lt;code&gt;bzip five.bz2 abc1.txt abc2.txt abc3.txt dir1 dir2&lt;/code&gt; 压缩多个目录/文件到一个文件&lt;br /&gt;
&lt;code&gt;bzip2 abc1.txt abc2.txt&lt;/code&gt; 分别压缩多个文件
&lt;code&gt;bunzip2 abc.txt.bz2 / bzip2 -d abc.txt.bz2&lt;/code&gt; 解压缩，原文件自动删除&lt;br /&gt;
&lt;code&gt;bunzip2 abc1.txt.bz2 abc2.txt.bz2&lt;/code&gt; 解压缩多个&lt;/p&gt;

&lt;p&gt;tar它只是一个打包的命令。tar.gz与tar.bz2都是在tar命令中调用了别的压缩命令实现了一个压缩的功能，实际是实行一个先打包后压缩的过程，而且，tar.gz与tar.bz2只是一个公认的一个通行后缀而已，并不是一种压缩格式（真正实现压缩的是gzip与bzip2，这是后话。），tar.gz在很多时候，也会被简写成tgz。&lt;br /&gt;
如果你在fedora下工作，你会发现bunzip2是bzip2的一个符 号连接。但bunzip2和bzip2的功能却正好相反。bzip2是用来压缩文件的（当然如果使用特殊函数也是可以用来解压，用选项-d可以实现），而 bunzip2是用来解压文件的（相当于bzip2 -d）。类比，还有zip和unzip、gzip和gunzip、compress和uncompress。&lt;/p&gt;

&lt;h3&gt;&lt;a id=&#34;shutdown&#34;&gt;&lt;font color=&#34;green&#34;&gt;shutdown&lt;/font&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;shutdown -h 23:00&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;shutdown -h +15&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;shutdown -k now &amp;quot;Server would shutdown in 15mins.&amp;quot;&lt;/code&gt; 吓唬一下&lt;/p&gt;

&lt;h3&gt;&lt;a id=&#34;chsh&#34;&gt;&lt;font color=&#34;green&#34;&gt;chsh&lt;/font&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;chsh -l&lt;/code&gt; 当前机器安装了那些shell&lt;br /&gt;
&lt;code&gt;cat /etc/shells&lt;/code&gt; 同上&lt;br /&gt;
&lt;code&gt;echo $SHELL&lt;/code&gt; 正在使用的shell&lt;br /&gt;
&lt;code&gt;chsh -s /bin/zsh&lt;/code&gt; 修改当前shell，重启shell窗口生效，修改的效果是改了文本文本文件,&lt;code&gt;cat /etc/passwd | grep ^tiemei&lt;/code&gt;&lt;/p&gt;

&lt;h3&gt;&lt;a id=&#34;man&#34;&gt;&lt;font color=&#34;green&#34;&gt;man&lt;/font&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;用man查看帮助信息，同名的情况，需要引入分类：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;1 用户命令&lt;/li&gt;
&lt;li&gt;2 系统调用&lt;/li&gt;
&lt;li&gt;3 C语言库函数&lt;/li&gt;
&lt;li&gt;4 设备或特殊文件&lt;/li&gt;
&lt;li&gt;5 文件格式和规则&lt;/li&gt;
&lt;li&gt;6 游戏及其他&lt;/li&gt;
&lt;li&gt;7 宏、包及其他杂项&lt;/li&gt;
&lt;li&gt;8 系统管理员相关的命令&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;http://www.linuxmanpages.com/&#34;&gt;一个查看man信息的网站&lt;/a&gt;&lt;br /&gt;
&lt;code&gt;manpath&lt;/code&gt;命令可查看man搜索帮助信息的路径顺序&lt;br /&gt;
&lt;code&gt;makewhatis&lt;/code&gt; 重新建立man数据库&lt;br /&gt;
&lt;code&gt;man -k roc&lt;/code&gt; 等效于 &lt;code&gt;apropos&lt;/code&gt;(一个脚本文件) ,像搜索引擎一样，给一个关键字列出所有相关信息&lt;/p&gt;

&lt;h3&gt;&lt;a id=&#34;who am i&#34;&gt;&lt;font color=&#34;green&#34;&gt;who am i&lt;/font&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;whoami 当前操作用户,即有效用户=euid(effective user id)&lt;br /&gt;
who am i 等效 who -m 登录用户，即linux术语里的实际用户=uid(user id)&lt;br /&gt;
who 当前登录的所有用户&lt;br /&gt;
深入：&lt;br /&gt;
&lt;a href=&#34;http://hi.baidu.com/xinbao125/item/0efe5d9a728cdb88581461eb&#34;&gt;用标准IO实现linux的who命令&lt;/a&gt;
&lt;a href=&#34;http://hi.baidu.com/xinbao125/item/a521ac313f3779159cc65eeb&#34;&gt;实现linux的whoami命令&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;&lt;a id=&#34;wc&#34;&gt;&lt;font color=&#34;green&#34;&gt;wc&lt;/font&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;[rocrocket@rocrocket programming]$ cat wc1.txt
1 2
34 5
你好
[rocrocket@rocrocket programming]$ wc -c wc1.txt # 字节数，空格换行都算，UTF-    8编码，汉字3字节    
16 wc1.txt    
[rocrocket    @rocrocket programming]$ wc -m wc1.txt # 字符数，一个汉字一个字符    
12 wc1.txt    
[rocrocket    @rocrocket programming]$ wc -l wc1.txt # 行数    
3 wc1.txt    
[rocrocke    t@rocrocket programming]$ wc -L wc1.txt # 最长行长度，换行不在内    
4 wc1.txt    
[rocrocket@rocrocket programming]$ wc -w wc1.txt # 字数（word），34 是一个字
5 wc1.txt


[rocrocket@rocrocket programming]$ wc wc1.txt
3  5 16 wc1.txt
输出信息依次是：行数 字数 字节数 文件名称。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;tab制表符，这个符号比较特殊，当使用-L时，制表符算7个字符（这要依据一个制表符的长度而定，在我的系统中一个制表符算7个空格长度）。而当使用-w时，制表符和空格没有两样，都作为字的间隔来看待。当用-c时，一个制表符也就算一个字符&lt;/p&gt;

&lt;h3&gt;&lt;a id=&#34;vim&#34;&gt;&lt;font color=&#34;green&#34;&gt;vim&lt;/font&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;sed -n &#39;/\sat\s/!p&#39;&lt;/code&gt; !p打印取反&lt;br /&gt;
&lt;code&gt;s/abc/xyz/&lt;/code&gt; 光标所在行第一项替换&lt;br /&gt;
&lt;code&gt;s/abc/xyz/g&lt;/code&gt; 光标所在行所有项替换&lt;br /&gt;
&lt;code&gt;1,$s/abc/xyz/g&lt;/code&gt; 第一行到最后一样替换，&lt;code&gt;.&lt;/code&gt;表示当前行&lt;br /&gt;
&lt;code&gt;:s#http://roclinux\.cn/index\.php#http://www\.sohu\.com#&lt;/code&gt; 间隔符号用#，!也行&lt;br /&gt;
&lt;code&gt;:1,$s/\([0-9]\{4\}-[0-9]\{2\}-[0-9]\{2\}\)/&#39;\1&#39;/g&lt;/code&gt;  日期格式（XXXX-XX-XX）的字符串两侧加上一对单引号&lt;br /&gt;
&lt;code&gt;:r !sed -n &#39;1,1p&#39; file&lt;/code&gt; 读入另一个文件第一行&lt;/p&gt;

&lt;p&gt;&lt;code&gt;num ctrl+w +/-&lt;/code&gt;增减宽度&lt;br /&gt;
&lt;code&gt;num ctrl+w &amp;gt;/&amp;lt;&lt;/code&gt;减小高度&lt;/p&gt;

&lt;p&gt;&lt;code&gt;n&amp;gt;&amp;gt;&lt;/code&gt; &lt;code&gt;n&amp;lt;&amp;lt;&lt;/code&gt; 多行缩进，或进入v模式按&amp;gt;/&amp;lt;&lt;/p&gt;

&lt;h3&gt;&lt;a id=&#34;sed&#34;&gt;&lt;font color=&#34;green&#34;&gt;sed&lt;/font&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;按行处理，读一行到零食缓冲区（模式空间，pattern space）,处理完输出到屏幕。&lt;br /&gt;
&lt;code&gt;sed cmd file&lt;/code&gt; 命令格式&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;sed -i &amp;quot;.bak&amp;quot; &#39;s/abc/ac/g&#39; file&lt;/code&gt; 直接在文件中替换字符串。.bak为备份文件名，为&amp;rdquo;&amp;ldquo;时不会备份。mac
下必须加上&amp;rdquo;&amp;ldquo;，linux下可省略。&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;/2/d&lt;/code&gt; 删除含有字符&amp;rsquo;2&amp;rsquo;的行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[rocrocket@rocrocket programming]$ cat roc.txt
test 1
test2
testtest
XtestX
BBtest
[rocrocket@rocrocket programming]$ sed ‘/2/d’ roc.txt
test 1
testtest
XtestX
BBtest
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;s/:.*$//&lt;/code&gt; 将第一个&amp;rsquo;:&amp;lsquo;只有的内容替换为空白&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[rocrocket@rocrocket programming]$ head -n 5 /etc/passwd
root:x:0:0:root:/root:/bin/bash
bin:x:1:1:bin:/bin:/sbin/nologin
daemon:x:2:2:daemon:/sbin:/sbin/nologin
adm:x:3:4:adm:/var/adm:/sbin/nologin
lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin


[rocrocket@rocrocket programming]$ head -n 5 /etc/passwd|sed ‘s/:.*$//’
root
bin
daemon
adm
lp
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;/4/p&lt;/code&gt; 输出含有&amp;rsquo;4&amp;rsquo;的行，sed默认先输出原始行，加上 &lt;code&gt;-n&lt;/code&gt; 只输出想要的行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[rocrocket@rocrocket programming]$ cat roc.txt
1
2
3
4
5
[rocrocket@rocrocket programming]$ sed ‘/4/p’ roc.txt
1
2
3
4
4
5
[rocrocket@rocrocket programming]$ sed -n ‘/4/p’ roc.txt
4
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;command部分包括，&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;确定范围部分

&lt;ul&gt;
&lt;li&gt;指定行数 &lt;code&gt;3,5&lt;/code&gt; &lt;code&gt;5,$&lt;/code&gt; &lt;code&gt;2,+4p&lt;/code&gt; 第2行后面再加4行&lt;/li&gt;
&lt;li&gt;用模式匹配进行指定，&lt;code&gt;/^[dD]/&lt;/code&gt;匹配行首不是以d/D开头的行&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;处理方式部分

&lt;ul&gt;
&lt;li&gt;d 删除行&lt;/li&gt;
&lt;li&gt;p 打印该行&lt;/li&gt;
&lt;li&gt;r 读取指定文件的内容&lt;/li&gt;
&lt;li&gt;w 写入指定文件&lt;/li&gt;
&lt;li&gt;a: 在下面插入新行内容&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;举例:

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;sed -n &#39;10,20p&#39; test&lt;/code&gt; 显示test文件的10到20行&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sed &#39;/^[dD]/s/x/X/g&#39; test&lt;/code&gt; 将所有以d/D开头的行小写x替换成大写X输出&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sed &#39;s/..$//&#39; test&lt;/code&gt;删除每行最后两个字符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sede &#39;s/..//&#39; test&lt;/code&gt; 删除每行前两个字符&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;s/B.*/&amp;amp;2008/&lt;/code&gt;在匹配到&amp;rsquo;B.*&amp;lsquo;后面插入2008,&lt;code&gt;&amp;amp;&lt;/code&gt;表示被匹配的部分&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[rocrocket@rocrocket programming]$ cat mysed.txt
Beijing
London[rocrocket@rocrocket programming]$ sed ‘s/B.*/&amp;amp;2008/’ mysed.txt
Beijing2008
London
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;s/\(Beijing\)\(.*\)\(Beijing\)/\12008\2\32008/&lt;/code&gt; 在行的第一个Beijing后加上2008，最后一个Beijing后加上2008，注意&amp;rsquo;()&amp;lsquo;匹配的部分存储到\1 \2 \3中&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[rocrocket@rocrocket programming]$ cat mysed.txt
Beijing Beijing Beijing Beijing
London London London London
[rocrocket@rocrocket programming]$ sed ‘s/\(Beijing\)\(.*\)\(Beijing\)/\12008\2\32008/’ mysed.txt
Beijing2008 Beijing Beijing Beijing2008
London London London London
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;sed -n &#39;1~2p&#39; file&lt;/code&gt; 打印偶数行 &lt;code&gt;sed -n &#39;0~2p&#39; file&lt;/code&gt; 打印奇数行&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://roclinux.cn/?p=1362&#34;&gt;sed不支持非贪婪算法&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;‘/2005/,/2007/p’&lt;/code&gt; 匹配有2005的行到有2007的行结束&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[rocrocket@rocrocket programming]$ cat mysed.txt
Beijing 2003
Beijing 2004
Beijing 2005
Beijing 2006
Beijing 2007
Beijing 2008
Beijing 2007
[rocrocket@rocrocket programming]$ sed -n ‘/2005/,/2007/p’ mysed.txt
Beijing 2005
Beijing 2006
Beijing 2007
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;-e&lt;/code&gt;接多个cmd，从前到后执行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[rocrocket@rocrocket programming]$ sed -n -e ’1,2p’ -e ’4p’ mysed.txt
Beijing 2003
Beijing 2004
Beijing 2006
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;-f&lt;/code&gt;将cmd部分写到file中&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[rocrocket@rocrocket programming]$ cat callsed
/2004/,/2006/p
[rocrocket@rocrocket programming]$ sed -n -f callsed mysed.txt
Beijing 2004
Beijing 2005
Beijing 2006
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;cmd中 &lt;code&gt;r  w&lt;/code&gt;用法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[rocrocket@rocrocket programming]$ cat ins.txt
====China====
[rocrocket@rocrocket programming]$ sed ‘/2005/r ins.txt’ mysed.txt
Beijing 2003
Beijing 2004
Beijing 2005
====China====
Beijing 2006
Beijing 2007
Beijing 2008
[rocrocket@rocrocket programming]$ sed ‘/200[4-6]/w new.txt’ mysed.txt; cat new.txt
Beijing 2004
Beijing 2005
Beijing 2006
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;cmd中 &lt;code&gt;i&lt;/code&gt;用法  在特定行上面插入特定内容&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[rocrocket@rocrocket programming]$ sed ‘/2004/i\China’ mysed.txt
Beijing 2003
China
Beijing 2004
Beijing 2005
Beijing 2006
Beijing 2007
Beijing 2008
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;cmd中&lt;code&gt;y&lt;/code&gt;用法，替换特定字符&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# sed -n &#39;s/eijing/EIJIGN/g&#39; mysed.txt一样的效果
[rocrocket@rocrocket programming]$ sed ‘y/eijng/EIJNG/’ mysed.txt
BEIJING 2003
BEIJING 2004
BEIJING 2005
BEIJING 2006
BEIJING 2007
BEIJING 2008
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;/2004/{n;y/eijng/EIJNG/;}&lt;/code&gt;对匹配行的下一行进行处理，n使移到下一行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[rocrocket@rocrocket programming]$ sed ‘/2004/{n;y/eijng/EIJNG/;}’ mysed.txt
Beijing 2003
Beijing 2004
BEIJING 2005
Beijing 2006
Beijing 2007
Beijing 2008
[rocrocket@rocrocket programming]$ sed ‘/200/{n;y/eijng/EIJNG/;}’ mysed.txt
Beijing 2003
BEIJING 2004
Beijing 2005
BEIJING 2006
Beijing 2007
BEIJING 2008
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://roclinux.cn/?p=1585&#34;&gt;强势扩展&lt;/a&gt; 复杂命令/h x G/&amp;hellip;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 同时写多个命令，用三种方式：分号，-e，-f
sed -n -e ‘=;p’ myfile.txt  # =表示行号，打印每行行号，然后答应每行内容
sed -n -e ‘=’ -e ‘p’ myfile.txt
sed -n -f mycommands.sed myfile.txt


# h x G 
h表示将模式空间中的内容拷贝到”保持空间(hold space)”中。“保持空间”是sed中除了模式空间外的另一个暂存数据的地方
x表示交换模式空间和保持空间中的内容
G表示将保持空间的内容追加到模式空间中内容的尾部


# s///g和s///
个都是sed里的替换命令，有g，如果一行里出现两次匹配串，那么所有的匹配串都会被替换；否则值只替换第一个匹配串


# sed -e ’s/72;/72,next_val=0×11111111;/;/@/{h;s/test/next/g;x;G}’ fmt_vuln.c
将文件中每行出现‘72;’替换为‘72,next_val=0×11111111;’；接着，如果有@符号，则将本行宝贝到hold空间，做一个全局的替换，交换保持空间和模式空间内容，并将保持空间内容追加到模式空间结尾（增加了一行）
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;http://sed.sourceforge.net/sed1line_zh-CN.html&#34;&gt;SED单行脚本快速参考&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;sed G&lt;/code&gt;在每一行后面增加一空行&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sed &#39;G;G&#39;&lt;/code&gt; 增加两个空行&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sed &#39;/^$/d;G&#39;&lt;/code&gt;删除空行并在每行后面加上一空行&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;&lt;a id=&#34;awk&#34;&gt;&lt;font color=&#34;green&#34;&gt;awk&lt;/font&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;awk &#39;NR%2&#39; file&lt;/code&gt; 提取奇数行
&lt;code&gt;awk &#39;NR%2==0&#39; file&lt;/code&gt; 提取偶数行&lt;/p&gt;

&lt;h3&gt;&lt;a id=&#34;sort&#34;&gt;&lt;font color=&#34;green&#34;&gt;sort&lt;/font&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-u&lt;/code&gt; 去除重复行&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-r&lt;/code&gt; 默认升序，改成降序&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sort file &amp;gt; otherfile&lt;/code&gt;不生效，用&lt;code&gt;sort file -o otherfile&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-n&lt;/code&gt;默认按字符排序，改成按数值排序&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;-t -k选项&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[rocrocket@rocrocket programming]$ cat facebook.txt
banana:30:5.5
apple:10:2.5
pear:90:2.3
orange:20:3.4


分隔符:，按第二列排序
[rocrocket@rocrocket programming]$ sort -n -k 2 -t : facebook.txt
apple:10:2.5
orange:20:3.4
banana:30:5.5
pear:90:2.3
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;其他选项&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-f 忽略大小写
-c 检查文件是否乱序，如果乱序输出第一个乱序行信息，返回1
-C 如果乱序，不输出，返回1
-M 以月份来排序,比如JAN小于FEB等等
-b 忽略每一行前面的所有空白部分，从第一个可见字符开始排序
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;&lt;code&gt;-k&lt;/code&gt;选项大作战&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;$ cat facebook.txt
google 110 5000
baidu 100 5000
guge 50 3000
sohu 100 4500

分隔符&#39; &#39;,先按第三列数字方式降序排，再按第二列数字方式排序
$ sort -t &#39; &#39; -k 3nr -k 2n facebook.txt
baidu 100 5000
google 110 5000
sohu 100 4500
guge 50 3000
&lt;/code&gt;&lt;/pre&gt;

&lt;h6&gt;完整语法： &lt;code&gt;[ FStart [ .CStart ] ] [ Modifier ] [ , [ FEnd [ .CEnd ] ][ Modifier ] ]&lt;/code&gt;&lt;/h6&gt;

&lt;ul&gt;
&lt;li&gt;由&lt;code&gt;,&lt;/code&gt;分成start/end两部分，end部分可省略&lt;/li&gt;
&lt;li&gt;Modifier放置类似n r的选项&lt;/li&gt;
&lt;li&gt;CStart从一个域的哪个字符开始，省略表示从第一个字符开始&lt;/li&gt;
&lt;li&gt;FStart从哪个域开始&lt;/li&gt;

&lt;li&gt;&lt;p&gt;CEnd省略表示到域尾&lt;/p&gt;

&lt;p&gt;按第一个域排序，从第二字符开始
$ sort -t &amp;lsquo; &amp;rsquo; -k 1.2 facebook.txt
baidu 100 5000
sohu 100 4500
google 110 5000
guge 50 3000&lt;/p&gt;

&lt;p&gt;按第一个域第二个字符排序，如果相同按第三个域数字方式降序
$ sort -t &amp;lsquo; &amp;rsquo; -k 1.2,1.2 -k 3,3nr facebook.txt
baidu 100 5000
google 110 5000
sohu 100 4500
guge 50 3000&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h6&gt;Modifier还可以包括：&lt;/h6&gt;

&lt;ul&gt;
&lt;li&gt;n&lt;/li&gt;
&lt;li&gt;r&lt;/li&gt;
&lt;li&gt;b 忽略本域的签到空白符号&lt;/li&gt;
&lt;li&gt;d 对本域按字典顺序排序（只考虑空白和字母）&lt;/li&gt;
&lt;li&gt;f 忽略带小些&lt;/li&gt;
&lt;li&gt;i 忽略不可打印字符&lt;/li&gt;
&lt;li&gt;u&lt;/li&gt;
&lt;li&gt;h 会识别单位，4G 大约699M&lt;/li&gt;

&lt;li&gt;&lt;p&gt;s 阻止同一个域相同，不进行进一步比较&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cat
00 2
00 1
sort -t &#39; &#39; -k 1,1 demo -s
00 2
00 1
sort -t &#39; &#39; -k 1,1 demo
00 1
00 2
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h6&gt;-u -k 联合使用&lt;/h6&gt;

&lt;p&gt;&lt;font color=&#34;red&#34;&gt;可以推测，某个域没法比较相等，从第一个域开始升序排序！！！&lt;/font&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat facebook.txt
google 110 5000
baidu 100 5000
guge 50 3000
sohu 100 4500

取出重复行，guge也没有留下
$ sort  -k 1.1,1.1 -u facebook.txt
baidu 100 5000
google 110 5000
sohu 100 4500

-u只会删除所以-k选项都相同情况，如果存在sina 100 4500就会被去掉
$ sort -n -k 2 -k 3 -u facebook.txt
guge 50 3000
sohu 100 4500
baidu 100 5000
google 110 5000

第二个域的第二个字符开始到第三个域的第一个字符结束
原来“跨域的设定是个假象”，sort只会比较第二个域的第二个字符到第二个域的最后一个字符的部分，
而不会把第三个域的开头字符纳入比较范围。当发现00和00相同时，sort就会自动比较第一个域去了。
可以推测，某个域没法比较相等，从第一个域开始升序排序！！！
$ sort -n -k 2.2,3.1 facebook.txt
guge 50 3000
baidu 100 5000
sohu 100 4500
google 110 5000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://roclinux.cn/?p=1472&#34;&gt;参考原文&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://www.linuxso.com/command/sort.html&#34;&gt;sort参数详解&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;&lt;a id=&#34;split&#34;&gt;&lt;font color=&#34;green&#34;&gt;split&lt;/font&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;split -l 3 input_file prefix.&lt;/code&gt; 3行拆分input_file,目标文件前缀prefix&lt;br /&gt;
&lt;code&gt;-b -k -m..&lt;/code&gt;按大小拆分文件&lt;/p&gt;

&lt;h3&gt;&lt;a id=&#34;ln&#34;&gt;&lt;font color=&#34;green&#34;&gt;ln&lt;/font&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://vbird.dic.ksu.edu.tw/linux_basic/0230filesystem.php&#34;&gt;Linux ext2文件系统 / 硬链接软链接&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ln srcfile hardlink&lt;/code&gt;硬链接,只能同一个文件系统，只能指向文件（）。实际是在这个目录的block增加了一条记录，指向srcfile的innode位置。由于删除文件，就是删除其目录block中的内容（需要改目录你有w权限啦~），故你删除原来的srcfile，hardlink照样存在。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ln -s srcfile/srcdir softlink&lt;/code&gt; 软链接，实际是创建了新的文件softlink,该文件的block内容指向srcfile/srcdir的inode号码。如果你删除srcfile/srcdir，该softlink失效啦。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;&lt;a id=&#34;paste&#34;&gt;&lt;font color=&#34;green&#34;&gt;paste&lt;/font&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;[rocrocket@rocrocket programming]$ cat p3.txt
I
II
III

# 默认用制表符连接
[rocrocket@rocrocket programming]$ paste p1.txt p2.txt p3.txt
1    a    I
2    b    II
3    c    III
[rocrocket@rocrocket programming]$ paste p3.txt p2.txt p1.txt
I    a    1
II   b    2
III  c    3

# 指定连接符号
[rocrocket@rocrocket programming]$ paste -d &#39;*&#39; p3.txt p2.txt p1.txt
I*a*1
II*b*2
III*c*3

# 一个文件多行连接
[rocrocket@rocrocket programming]$ paste -s -d &amp;quot;*&amp;quot; p3.txt p2.txt p1.txt
I*II*III
a*b*c
1*2*3

# 
$ cat fa.txt
20
60
90
12
$ cat fb.txt
60
90
12
14
$ cat fc.txt
70
90
80
12
$ paste -d&amp;quot;+-&amp;quot; fa.txt fb.txt fc.txt
20+60-70
60+90-90
90+12-80
12+14-12

# 计算结果
$ paste -d&amp;quot;+-&amp;quot; fa.txt fb.txt fc.txt| while read line
do
echo -n &amp;quot;($line)=&amp;quot; # -n不换行
echo $line | bc
done

Output:
(20+60-70)=10
(60+90-90)=60
(90+12-80)=22
(12+14-12)=14
$ paste fa.txt fb.txt fc.txt | awk &#39;{print &amp;quot;(&amp;quot;$1&amp;quot;+&amp;quot;$2&amp;quot;-&amp;quot;$3&amp;quot;)=&amp;quot;$1+$2-$3}&#39;

Output:
(20+60-70)=10
(60+90-90)=60
(90+12-80)=22
(12+14-12)=14

# Only list the elements which have rpm &amp;gt; 3000
$ cat element.txt
Element E1:
rpm=2300
Element E5:
rpm=8900
Element E3:
rpm=5000
Element E4:
rpm=1200
$ paste - - &amp;lt; element.txt | awk &#39;$NF&amp;gt;=3000 {print $1}&#39; FS=[:,=]
Element E5
Element E3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://unstableme.blogspot.com/2009/01/linux-paste-command-good-examples-uses.html&#34;&gt;待续&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;&lt;a id=&#34;sar&#34;&gt;&lt;font color=&#34;green&#34;&gt;sar&lt;/font&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;h5&gt;CPU信息&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;sar 时间间隔 输出次数&lt;/code&gt; 单位s,如果时间间隔0，输出从开机到现在为止的平均值；输出次数为0，永远输出下去。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sar 5 6 -o sys_info&lt;/code&gt;输出到那文件，不过格式没法cat，用&lt;code&gt;sar -f sys_info&lt;/code&gt;看吧。-o没有filename，默认到var/log/saDD文件里，其中DD表示当天的日期数字&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;sar -P ALL 1 2&lt;/code&gt;试试多核，&lt;code&gt;sar -P 5 1 1&lt;/code&gt;只看第六个核&lt;/p&gt;

&lt;h5&gt;内存/网络/IO..信息呢？&lt;/h5&gt;

&lt;p&gt;-b：报告I/O使用情况以及传输速率。（只适用于2.5及之前的内核，所以新内核有可能不支持这个选项）&lt;/p&gt;

&lt;p&gt;-B：报告“页”使用情况&lt;/p&gt;

&lt;p&gt;-c：报告进程创建情况&lt;/p&gt;

&lt;p&gt;-d：报告每一个块设备的使用情况
   （当你使用时，你会发现在DEV列有类似dev1-7格式的字符串，
   其中1代表设备的主序号，n代表设备的从序号，
   而且rd_sec/s列和wr_sec/s列的单位都是512bytes，也就是512B，也就是0.5KB）&lt;/p&gt;

&lt;p&gt;-I：汇报中断情况&lt;/p&gt;

&lt;p&gt;-n：汇报网络情况&lt;/p&gt;

&lt;p&gt;-P：设定CPU&lt;/p&gt;

&lt;p&gt;-q：汇报队列长度和负载信息&lt;/p&gt;

&lt;p&gt;-r：汇报内存和交换区使用情况&lt;/p&gt;

&lt;p&gt;-R：汇报内存情况&lt;/p&gt;

&lt;p&gt;-u：汇报CPU使用情况&lt;/p&gt;

&lt;p&gt;-v：汇报i节点、文件和其他内核表信息&lt;/p&gt;

&lt;p&gt;-w：汇报系统上下文切换情况&lt;/p&gt;

&lt;p&gt;-x：可以针对某个特定PID给出统计信息，
   可以直接指定进程ID号；
   也可以指定为SELF，这样就是检测sar进程本身；
   如果设定为ALL，则表示汇报所有系统进程信息。&lt;/p&gt;

&lt;p&gt;-X：汇报特定PID的子进程的信息&lt;/p&gt;

&lt;p&gt;-y：设定TTY设备的信息。&lt;/p&gt;

&lt;p&gt;-A 就相当于-bBcdqrRuvwWy -I SUM -n FULL -P ALL这么一堆选项了&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5&gt;网络相关&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;# sar命令使用-n选项可以汇报网络相关信息，可用的参数包括：DEV、EDEV、SOCK和FULL
# 如果你使用DEV关键字，那么sar将汇报和网络设备相关的信息，如lo，eth0或eth1等，例如：
$ sar -n DEV 1 2
Linux 2.6.9      10/17/2009

12:10:49 AM     IFACE   rxpck/s   txpck/s   rxbyt/s   txbyt/s   rxcmp/s   txcmp/s  rxmcst/s
12:10:50 AM      eth0     63.64      0.00   4072.73      0.00      0.00      0.00      0.00
12:10:50 AM      eth1     30.30     13.13   2907.07   1234.34      0.00      0.00      0.00
12:10:50 AM        lo      0.00      0.00      0.00      0.00      0.00      0.00      0.00
IFACE：就是网络设备的名称；
rxpck/s：每秒钟接收到的包数目
txpck/s：每秒钟发送出去的包数目
rxbyt/s：每秒钟接收到的字节数
txbyt/s：每秒钟发送出去的字节数
rxcmp/s：每秒钟接收到的压缩包数目
txcmp/s：每秒钟发送出去的压缩包数目
txmcst/s：每秒钟接收到的多播包的包数目

# 如果你使用EDEV关键字，那么会针对网络设备汇报其失败情况
$ sar -n EDEV 1 3
Linux 2.6.9     10/17/2009

12:15:06 AM     IFACE   rxerr/s   txerr/s    coll/s  rxdrop/s  txdrop/s  txcarr/s  rxfram/s  rxfifo/s  txfifo/s
12:15:07 AM        lo      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00
12:15:07 AM      eth0      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00
12:15:07 AM      eth1      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00
rxerr/s：每秒钟接收到的损坏的包的数目
txerr/s：当发送包时，每秒钟发生的错误数
coll/s：当发送包时，每秒钟发生的冲撞(collisions)数（这个是在半双工模式下才有）
rxdrop/s：由于缓冲区满，网络设备接收端，每秒钟丢掉的网络包的数目
txdrop/s：由于缓冲区满，网络设备发送端，每秒钟丢掉的网络包的数目
txcarr/s：当发送数据包时，每秒钟载波错误发生的次数
rxfram/s：在接收数据包时，每秒钟发生的帧对齐错误的次数
rxfifo/s：在接收数据包时，每秒钟缓冲区溢出错误发生的次数
txfifo/s：在发送数据包时，每秒钟缓冲区溢出错误发生的次数

# 如果你使用SOCK关键字，则会针对socket连接进行汇报
$ sar -n SOCK 1 3
Linux 2.6.9       10/17/2009

12:27:29 AM    totsck    tcpsck    udpsck    rawsck   ip-frag
12:27:30 AM        90        41         4         0         0
12:27:31 AM        90        41         4         0         0
12:27:32 AM        90        41         4         0         0
Average:           90        41         4         0         0
totsck：被使用的socket的总数目
tcpsck：当前正在被使用于TCP的socket数目
udpsck：当前正在被使用于UDP的socket数目
rawsck：当前正在被使用于RAW的socket数目
ip-frag：当前的IP分片的数目

# 如果你使用FULL关键字，相当于上述DEV、EDEV和SOCK三者的综合
&lt;/code&gt;&lt;/pre&gt;

&lt;h5&gt;其他好玩的&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;sar实时汇报机器性能情况 &lt;code&gt;sar -o monitor.res 间隔时间 运行次数 &amp;gt;/dev/null 2&amp;gt;&amp;amp;1 &amp;amp;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-e hh:mm:ss选项&lt;/code&gt;某个特定时间结束，只能用在读取(-f)或写入(-o)信息文件时才可用&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;或许你平时还在使用free,ifconfig或者top，从今以后，试试sar吧&lt;/strong&gt;&lt;/p&gt;

&lt;h3&gt;&lt;a id=&#34;wget&#34;&gt;&lt;font color=&#34;green&#34;&gt;wget&lt;/font&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;h5&gt;wget是什么？&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;支持HTTP、HTTPS和FTP协议的下载，其中也包括通过HTTP代理的下载&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;wget能够跟踪HTML文件和XHTML文件,傻傻的去下载外链站点的内容&lt;/li&gt;
&lt;li&gt;wget支持慢速网络下载和不稳定网络的下载。当因为网络不稳定而导致下载失败时，wget会重试直到把目标文件下载下来为止&lt;/li&gt;
&lt;li&gt;wget支持断点续传功能&lt;/li&gt;
&lt;li&gt;wget是使用getopt函数来处理选项和参数,支持长格式的选项和短的&lt;/li&gt;
&lt;li&gt;选项有参数时，你甚至可以在短选项和参数之间不加空格。比如-o log可以写成-olog&lt;/li&gt;
&lt;li&gt;连续使用了多个短选项，且这些短选项不需要加参数，那么可以将他们组合在一起。比如-d -r -c可以写成-drc&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://roclinux.cn/?p=1542&#34;&gt;还有好多呀&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;demo&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;wget -c &amp;quot;www.baidu.com&amp;quot; -O reNameFile -o wget.log&lt;/code&gt; 重命名，并输出运行日志&lt;/p&gt;

&lt;h5&gt;&lt;a href=&#34;http://roclinux.cn/?p=1546&#34;&gt;wget突破robots.txt限制&lt;/a&gt;&lt;/h5&gt;

&lt;h5&gt;&lt;a href=&#34;http://roclinux.cn/?p=2505&#34;&gt;wget目录相关选项&lt;/a&gt;&lt;/h5&gt;

&lt;h5&gt;&lt;a href=&#34;http://roclinux.cn/?p=1561&#34;&gt;大文件&lt;/a&gt;&lt;/h5&gt;

&lt;h5&gt;&lt;a href=&#34;http://roclinux.cn/?p=2107&#34;&gt;其他选项&lt;/a&gt;&lt;/h5&gt;

&lt;h3&gt;&lt;a id=&#34;curl&#34;&gt;&lt;font color=&#34;green&#34;&gt;curl&lt;/font&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;curl http://defworld.com&lt;/code&gt; GET获得一个页面内容&lt;/li&gt;
&lt;li&gt;&lt;code&gt;curl -I http://defworld.com&lt;/code&gt; 获得http head&lt;/li&gt;
&lt;li&gt;&lt;code&gt;curl -v http://defworld.com&lt;/code&gt; 打印http交互详细过程&lt;/li&gt;
&lt;li&gt;支持POST方式&lt;/li&gt;
&lt;li&gt;&lt;code&gt;curl -F upload=@localfilename -F press=OK [URL]&lt;/code&gt; 支持文件上传&lt;/li&gt;
&lt;li&gt;&lt;code&gt;curl -u name:password www.secrets.com&lt;/code&gt; 认证&lt;/li&gt;
&lt;li&gt;&lt;code&gt;curl -A “Mozilla/4.0 (compatible; MSIE 5.01; Windows NT 5.0)” [URL]&lt;/code&gt; 模拟指定浏览器&lt;/li&gt;
&lt;li&gt;&lt;code&gt;curl -D head_cookies http://bbs.it580.com&lt;/code&gt; &lt;code&gt;curl -b head_cookies http://bbs.it580.com&lt;/code&gt;保存并使用cookie&lt;/li&gt;
&lt;li&gt;&lt;code&gt;curl -x proxy.test.org:80 http://bbs.it580.com&lt;/code&gt; 使用代理访问&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;&lt;a id=&#34;netstat&#34;&gt;&lt;font color=&#34;green&#34;&gt;netstat&lt;/font&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;/Dropbox/notes/a/netstat_saygb.png&#34; alt=&#34;替代netstat的命令&#34; /&gt;
&lt;/p&gt;

&lt;h3&gt;&lt;a id=&#34;ss&#34;&gt;&lt;font color=&#34;green&#34;&gt;ss&lt;/font&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;ss快不是一点点，尤其在sock连接很多，它利用到了TCP协议栈中tcp_diag&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://roclinux.cn/?p=2420&#34;&gt;如果系统没有预装ss，如何装&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;【场景一：我想查看当前服务器的网络连接统计】&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ss -s
Total: 295 (kernel 312)
TCP:   48 (estab 1, closed 31, orphaned 0, synrecv 0, timewait 0/0), ports 13

Transport Total     IP        IPv6
*         312       -         -
RAW       0         0         0
UDP       2         2         0
TCP       17        12        5
INET      19        14        5
FRAG      0         0         0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;【场景二：我想查看所有打开的网络端口】&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ss -l
Recv-Q Send-Q           Local Address:Port               Peer Address:Port
0      128                         :::webcache                      :::*
0      128                         :::http                         :::*
0      128                         :::snapenetio                      :::*
0      128                          *:snapenetio                       *:*
0      50                           *:8531                          *:*
0      9                           :::ftp                          :::*
0      9                            *:ftp                           *:*
0      128                          *:ddi-tcp-1                       *:*
0      100                        ::1:smtp                         :::*
0      100                  127.0.0.1:smtp                          *:*
0      128                          *:8541                          *:*
0      128                  127.0.0.1:entextxid                       *:*
0      50                           *:12421                         *:*
0      10                           *:amqp                          *:*
0      128                          *:12521                         *:*
0      50                           *:mysql                         *:*

如果使用-pl参数的话，则会列出具体的程序名称。你会在输出中看到类似于这样的内容：
(&amp;quot;nginx&amp;quot;,15786,6)
从中可以知道，某个socket连接是属于nginx程序的，nginx程序的PID是15786
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;【场景三：我想查看这台服务器上所有的socket连接】&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;很简单，直接使用-a选项即可列出所有网络连接。
ss -a
如果只想查看TCP sockets，那么使用-ta选项；
如果只想查看UDP sockets，那么使用-ua选项；
如果只想查看RAW sockets，那么使用-wa选项；
如果只想查看UNIX sockets，那么使用-xa选项
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;&lt;a id=&#34;iproute2&#34;&gt;&lt;font color=&#34;green&#34;&gt;iproute2&lt;/font&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;/Dropbox/notes/a/net-tool_ip.png&#34; alt=&#34;iproute工具集替代掉net-tools工具集&#34; /&gt;

&lt;img src=&#34;/Dropbox/notes/a/iproute2.png&#34; alt=&#34;iproute2工具集&#34; /&gt;
&lt;/p&gt;

&lt;h3&gt;&lt;a id=&#34;实时观察文件变化&#34;&gt;&lt;font color=&#34;green&#34;&gt;实时观察文件变化&lt;/font&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://bbs.chinaunix.net/thread-1257647-1-1.html&#34;&gt;一个帖子&lt;/a&gt;
- &lt;code&gt;watch -n 1 cat file.log&lt;/code&gt; 实时观察cat file.log的最后几行结果&lt;/p&gt;

&lt;h2&gt;- &lt;code&gt;tail -f file.log&lt;/code&gt; 末尾几行变动&lt;/h2&gt;

&lt;h3&gt;&lt;a id=&#34;ps&#34;&gt;&lt;font color=&#34;green&#34;&gt;ps&lt;/font&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;ps -eLf | grep java | wc&lt;/code&gt;&lt;/p&gt;

&lt;h3&gt;&lt;a id=&#34;shuf&#34;&gt;&lt;font color=&#34;green&#34;&gt;shuf&lt;/font&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;自己下载源码编译安装：http://mirror.yongbok.net/nongnu//shuffle/shuffle-0.9b.tar.gz&lt;/p&gt;

&lt;h3&gt;&lt;a id=&#34;rpm&#34;&gt;&lt;font color=&#34;green&#34;&gt;rpm&lt;/font&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;h3&gt;&lt;a id=&#34;grep&#34;&gt;&lt;font color=&#34;green&#34;&gt;grep&lt;/font&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;grep -n root /etc/passwd&lt;/code&gt; 输出行号&lt;/li&gt;
&lt;li&gt;&lt;code&gt;grep -v bash /etc/passwd&lt;/code&gt; 反向输出&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;grep -c false /etc/passwd&lt;/code&gt; 统计匹配行数&lt;/p&gt;

&lt;h4&gt;正则&lt;/h4&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;grep ^root /etc/passwd&lt;/code&gt; root开头的行&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;grep :$ /etc/passwd&lt;/code&gt; :结尾的行&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;grep &#39;\&amp;lt;PATH&#39; file&lt;/code&gt; 有某个单词是以PATH开头&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;grep &#39;PATH\&amp;gt; file&#39;&lt;/code&gt; 有某个单词是以PATH结尾&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;grep -w &#39;PATH&#39; file&lt;/code&gt; 有某个独立的单词，当然前后都是空格啦&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;grep [yf] file&lt;/code&gt; 包行y或f&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;grep &#39;\&amp;lt;c...h\&amp;gt;&#39;&lt;/code&gt; 某个单词，c开头h结尾，中间还有三个字符&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;grep -E &#39;AAA|BBB&#39; urfile&lt;/code&gt; -E用egrep的方式解释正则pattern&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;&lt;a id=&#34;script/scriptrelay&#34;&gt;&lt;font color=&#34;green&#34;&gt;script/scriptrelay&lt;/font&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;open terminal 1 : $ &lt;code&gt;mkfifo fd1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;open terminal 2 : $ &lt;code&gt;cat fd1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;back terminal 1 : $ &lt;code&gt;script -f fd1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;write in terminal 1, terminal 2 will see same&lt;/li&gt;
&lt;li&gt;exit in terminal 1 : $ &lt;code&gt;exit&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;&lt;a id=&#34;pushd/popd&#34;&gt;&lt;font color=&#34;green&#34;&gt;pushd/popd&lt;/font&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;dirs&lt;/code&gt; 可现实当前目录，金丹目录堆栈只有一个目录时&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pushd /path/to/dir1&lt;/code&gt; 将目录压入目录堆栈，此时运行&lt;code&gt;dirs&lt;/code&gt;输出目录堆栈，从左到右编号0&amp;hellip;n&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pushd +3&lt;/code&gt; 迅速切换到#3目录,此时目录堆栈的顺序会变化&lt;/li&gt;
&lt;li&gt;&lt;code&gt;popd +3&lt;/code&gt; 弹出并跳转到该目录&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;&lt;a id=&#34;touch&#34;&gt;&lt;font color=&#34;green&#34;&gt;touch&lt;/font&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;touch -t [[CC]YY]MMDDhhmm[.SS] file&lt;/code&gt;&lt;/p&gt;

&lt;h3&gt;&lt;a id=&#34;screen&#34;&gt;&lt;font color=&#34;green&#34;&gt;screen&lt;/font&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://www.ibm.com/developerworks/cn/linux/l-cn-screen/&#34;&gt;参考1&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://serverfault.com/questions/155851/run-gnu-screen-from-script&#34;&gt;参考2&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;screen -S name&lt;/code&gt; 创建一个screen session，并命名name&lt;/li&gt;
&lt;li&gt;&lt;code&gt;screen -r name&lt;/code&gt; 重新进入screen session&lt;/li&gt;
&lt;li&gt;&lt;code&gt;screen -ls&lt;/code&gt; 列出所有screen session&lt;/li&gt;
&lt;li&gt;&lt;code&gt;screen -wipe&lt;/code&gt;清扫无法连接的session&lt;/li&gt;
&lt;li&gt;&lt;code&gt;screen -d -m -S name&lt;/code&gt; 创建一个开始就处于断开模式的session&lt;/li&gt;
&lt;li&gt;&lt;code&gt;screen -S name -X zombie qr&lt;/code&gt; 设置cmd结束时，screen窗口不直接退出&lt;/li&gt;
&lt;li&gt;&lt;code&gt;screen -S name -X exec cmd&lt;/code&gt; 在id为name的screen session的编号为0的窗口执行命令cmd&lt;/li&gt;
&lt;li&gt;&lt;code&gt;screen -S name -X screen cmd&lt;/code&gt; 在session中新建一个窗口并执行cmd&lt;/li&gt;
&lt;li&gt;&lt;code&gt;C-a d&lt;/code&gt; 退出screen session&lt;/li&gt;
&lt;li&gt;&lt;code&gt;C-a c&lt;/code&gt; 创建一个新的shell窗口并切换到该窗口&lt;/li&gt;
&lt;li&gt;&lt;code&gt;C-a w&lt;/code&gt; 显示所有窗口列表&lt;/li&gt;
&lt;li&gt;&lt;code&gt;C-a k&lt;/code&gt; 杀掉当前窗口&lt;/li&gt;
&lt;li&gt;&lt;code&gt;C-a p&lt;/code&gt;&lt;code&gt;C-a n&lt;/code&gt; 前一个窗口，后一个窗口&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    <item>
      <title>我的eclipse配置、快捷键、插件</title>
      <link>http://defworld.com/2013/06/11/set-up-my-eclipse.html</link>
      <pubDate>2013-06-11 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;工作是J2EE应用开发，eclipse是陪伴我最多的工具。使用频率如此高，一定要顺手，一定要舒服。从10年9月份开始编程，就一直未离开eclipse，积累了一些东西，是时候跟大家分享了。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;os:mac os x 10.8
eclipse:juno&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;我常用的快捷键&#34; href=&#34;#我常用的快捷键&#34;&gt;&lt;/a&gt;我常用的快捷键&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;cmd-shift-f&lt;/code&gt; 格式化&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cmd + w&lt;/code&gt;     关闭窗口&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    <item>
      <title>从eclipse迁移到intellijIDEA(OS x 10.5)</title>
      <link>http://defworld.com/2013/06/07/intellij-idea-shortcuts.html</link>
      <pubDate>2013-06-07 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;&lt;img src=&#34;http://farm8.staticflickr.com/7287/8977180999_271d543e62.jpg&#34; alt=&#34;intellijIDEA&#34; /&gt;
&lt;br /&gt;
本文帮助希望从eclipse迁移到IntelliJ IDEA的coder.&lt;br /&gt;
我已经使用eclipse开发java程序快3年，虽然也能满足基本需求，但是我还是希望尝试新的东西，IDEA也确实有独到之处。&lt;/p&gt;

&lt;p&gt;参考：&lt;br /&gt;
&lt;a href=&#34;http://www.oschina.net/question/12_70799&#34;&gt;IntelliJ IDEA 的 20 个代码自动完成的特性&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://www.ituring.com.cn/article/37792&#34;&gt;从Eclipse转移到IntelliJ IDEA一点心得&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://www.colorfuldays.org/program/idea_keymap/&#34;&gt;常用IDEA快捷键&lt;/a&gt;
&lt;a href=&#34;https://github.com/damao/Intellij-IDEA-F2E&#34;&gt;Intellij-IDEA-F2E&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://www.youmeek.com/intellij-idea-part-ii-ui/&#34;&gt;@IntelliJ IDEA第二部分视频讲解：项目创建/打开/导入+主题修改+布局/界面介绍+工具栏/菜单栏介绍&lt;/a&gt;
(http://wiki.jetbrains.net/intellij/Creating_and_importing_Maven_projects)&lt;br /&gt;
&lt;a href=&#34;http://willerce.com/post/intellij-idea-config-sync&#34;&gt;Intellij配置文件同步&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://www.myexception.cn/program/1032108.html&#34;&gt;Intellij IDEA常用设置&lt;/a&gt;
&lt;a href=&#34;http://www.jetbrains.com/idea/documentation/migration_faq.html&#34;&gt;IntelliJ IDEA Q&amp;amp;A for Eclipse Users&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;本文快捷键仅适用于：&lt;br /&gt;
&amp;gt; Mac OS X 10.5+ keymap&lt;br /&gt;
&amp;gt; Intellij IDEA 12&lt;/p&gt;

&lt;p&gt;其他环境请参照&lt;a href=&#34;http://www.jetbrains.com/idea/documentation/index.jsp&#34;&gt;Intellij IEDA Getting Started&lt;/a&gt;&lt;br /&gt;
或者自己到&lt;code&gt;settings → keymap&lt;/code&gt;查看设置&lt;/p&gt;

&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;自动完成功能&#34; href=&#34;#自动完成功能&#34;&gt;&lt;/a&gt;自动完成功能&lt;/h2&gt;

&lt;p&gt;相比于eclipse停留在类方法和变量的简单自动提示，IDEA实在有强太多:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;⌃ Space/自动&lt;/code&gt;(Basic code completion) 基本的类、方法、成员变量、局部变量等查找&lt;/li&gt;
&lt;li&gt;&lt;code&gt;⌃ ⌥  Space&lt;/code&gt;(Smart code completion)更加智能的根据上下文过滤后的提示&lt;/li&gt;
&lt;li&gt;chain completion，多层调用提示，在eclipse里要通过pluging: Code Recommenders完成&lt;/li&gt;
&lt;li&gt;父类构造函数super()所用参数自动完成&lt;/li&gt;
&lt;li&gt;&lt;code&gt;⌘ ⇧ ↩&lt;/code&gt;(statements complemention)语句自动完成&lt;/li&gt;
&lt;li&gt;&lt;code&gt;⌘ p&lt;/code&gt;(Parameter info)方法参数信息提示&lt;/li&gt;
&lt;li&gt;&lt;code&gt;⌥ Space&lt;/code&gt;(quick definition)显示建议列表中方法定义&lt;/li&gt;
&lt;li&gt;&lt;code&gt;⌥ ↩&lt;/code&gt;(Exclude from completion) 排除几乎总是无用的提示&lt;/li&gt;
&lt;li&gt;输入一个字符的中间部分也能匹配&lt;/li&gt;
&lt;li&gt;自动完成不止在代码编辑器，debug模式，文件选择器等都有它的影子&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;从eclipse迁移过来&#34; href=&#34;#从eclipse迁移过来&#34;&gt;&lt;/a&gt;从eclipse迁移过来&lt;/h2&gt;

&lt;p&gt;作为一个多年的eclipse用户，总有些情节和习惯无法割舍。好，现在
一起看看如何平滑过度：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;show number line : settings → editor → Appearance → 勾选&amp;rsquo;show line numbers&amp;rsquo;&lt;/li&gt;
&lt;li&gt;编辑窗口与project窗口关联: 点击project栏头部第一个地球仪图案，或者选中齿轮图案的
&lt;code&gt;AutoScroll to Source&lt;/code&gt;和&lt;code&gt;AutoScroll from source&lt;/code&gt;。你也可以充分利用&lt;code&gt;Navigation Bar&lt;/code&gt;
(&lt;code&gt;⌘ ↑&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;eclipse: ctrl + o，列出所有成员变量方法，IDEA中&lt;code&gt;⌘ F12&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;⌥ ↑&lt;/code&gt; / &lt;code&gt;⌥ ↓&lt;/code&gt; 扩大/减少选中的词语的范围&lt;/li&gt;
&lt;li&gt;eclipse&lt;code&gt;ctrl + k&lt;/code&gt;同单词跳转，IDEA建议手动添加绑定&lt;code&gt;⌘ ⌃ k&lt;/code&gt;(Find Word at Caret),
结合&lt;code&gt;⌘ g&lt;/code&gt; (Find Next) &lt;code&gt;⌘ ⇧ g&lt;/code&gt;(find Previous)使用&lt;/li&gt;
&lt;li&gt;svn /git 版本控制，修改过的eclipse默认标记到最高层目录，而IDEA默认只标记
有改动的文件，需要手动设置&lt;code&gt;settings → Version Control → 勾选show directories with
changed descendants&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;IDEA默认自动保存，无需手动&lt;code&gt;ctrl + s&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;IDEA文件默认同步刷新到磁盘，无需手动刷新&lt;/li&gt;
&lt;li&gt;工程导入时忽略某些文件&lt;code&gt;settings → file types → ignore files and folders&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;关联源码或doc&lt;code&gt;⌘ ;&lt;/code&gt;到project structure界面，&lt;code&gt;SDK → Sourcepath&lt;/code&gt;将下载的src.zip关联进来即可&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;我的其他设置及快捷键&#34; href=&#34;#我的其他设置及快捷键&#34;&gt;&lt;/a&gt;我的其他设置及快捷键&lt;/h2&gt;

&lt;h3&gt;未归类&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;关闭拼写检查 &lt;code&gt;settings → spell&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;类注释修改  &lt;code&gt;settings → file template&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;空格替换⇥ : &lt;code&gt;settings → code type → java&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/jkaving/intellij-colors-solarized&#34;&gt;color theme&lt;/a&gt;
&lt;code&gt;Preferences → Editor → Colors &amp;amp; Fonts&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;文件过滤&lt;code&gt;settings → file types → Ignore files and folders&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;⌘  ,&lt;/code&gt;     全局setting&lt;/li&gt;
&lt;li&gt;&lt;code&gt;⌘  ;&lt;/code&gt;     项目settting&lt;/li&gt;
&lt;li&gt;&lt;code&gt;⌘  w&lt;/code&gt;    关闭当前界面&lt;/li&gt;
&lt;li&gt;&lt;code&gt;⌘ ⇧ w&lt;/code&gt;   自定义,close all&lt;/li&gt;
&lt;li&gt;&lt;code&gt;F2 / ⇧ F2&lt;/code&gt; next/preview highlighting syntax problem&lt;/li&gt;
&lt;li&gt;&lt;code&gt;settings → file types&lt;/code&gt;设定文件后缀与文件类型的对应关系&lt;/li&gt;
&lt;li&gt;&lt;code&gt;⇧ ⌘ A&lt;/code&gt; to find any action inside the IDE user find action&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;编辑代码&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;⇧ ↩&lt;/code&gt;/ &lt;code&gt;⌘ ⌥ ↩&lt;/code&gt; 下/上插入新行&lt;/li&gt;
&lt;li&gt;&lt;code&gt;⌘ j&lt;/code&gt;    必statements complemention更强大， &lt;a href=&#34;http://ooxx.me/intellij-idea-live-template.orz&#34;&gt;live template&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;⌘ n&lt;/code&gt;    生成代码/创建文件/生成get&amp;amp;setter&lt;/li&gt;
&lt;li&gt;&lt;code&gt;⌘ ⇧ t&lt;/code&gt;  生成测试类，位于editor打开文件任何位置;&lt;code&gt;⌥ ↩&lt;/code&gt;位于editor class name上才有用&lt;/li&gt;
&lt;li&gt;&lt;code&gt;⌥  ↩&lt;/code&gt;    调出出错提示处理方法&lt;/li&gt;
&lt;li&gt;&lt;code&gt;⌘ d&lt;/code&gt;      double整行、块&lt;/li&gt;
&lt;li&gt;&lt;code&gt;⌘ ⌦&lt;/code&gt; / &lt;code&gt;⌘ x&lt;/code&gt; 删除一行&lt;/li&gt;
&lt;li&gt;&lt;code&gt;⌘  c/v/x&lt;/code&gt; 整行操作&lt;/li&gt;
&lt;li&gt;&lt;code&gt;⇧ ⌘ v&lt;/code&gt;    调出寄存中保存的最近赋值的内容&lt;/li&gt;
&lt;li&gt;&lt;code&gt;⌘ /&lt;/code&gt;      注释/取消注释&lt;/li&gt;
&lt;li&gt;&lt;code&gt;⌘ ⌥ /&lt;/code&gt;    块注释&lt;/li&gt;
&lt;li&gt;&lt;code&gt;⌃ o&lt;/code&gt;      生成override方法&lt;/li&gt;
&lt;li&gt;&lt;code&gt;⌃ i&lt;/code&gt;      生成implement方方法(用⌥ + enter即可)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;⇧ ⌥ ↑/↓&lt;/code&gt; 选中的整行行上下移&lt;/li&gt;
&lt;li&gt;&lt;code&gt;⇧ ⌘ ↑/↓&lt;/code&gt; 更加智能的上下移动&lt;/li&gt;
&lt;li&gt;&lt;code&gt;⌘ ⌥ t&lt;/code&gt;   对选中代码自动生成环绕(if/try..catch/..)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;⌘ ⇧ u&lt;/code&gt; 大小写转换&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;代码跳转&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;⌘ ⌥ b&lt;/code&gt; / &lt;code&gt;⌘ b&lt;/code&gt; Go to declaration / Go to implementation(s)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;⌃ ⇧ b&lt;/code&gt; Go to type declaration&lt;/li&gt;
&lt;li&gt;&lt;code&gt;⌘ u&lt;/code&gt;  Go to super-method/super-class&lt;/li&gt;
&lt;li&gt;&lt;code&gt;⌘ y&lt;/code&gt;  Open quick definition lookup&lt;/li&gt;
&lt;li&gt;&lt;code&gt;⌥ ⌘ [&lt;/code&gt; / &lt;code&gt;⌥ ⌘ ]&lt;/code&gt; Move to code block start/end(我机器设置)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;⌘ ⇧ [&lt;/code&gt; / &lt;code&gt;⌘ ⇧ ]&lt;/code&gt; pre/next tab&lt;/li&gt;
&lt;li&gt;&lt;code&gt;⌘ ⌥ ← /→&lt;/code&gt; 在代码间前进后退&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;代码查看&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;⌘ + / ⌘ -&lt;/code&gt; expand/collapse code block&lt;/li&gt;
&lt;li&gt;&lt;code&gt;⌘ ⇧ + / ⌘ ⇧ -&lt;/code&gt; expand /collapse all&lt;/li&gt;
&lt;li&gt;&lt;code&gt;⌃ + j&lt;/code&gt; class quick doc，文档生成&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;⌃ h&lt;/code&gt; class type hierarchy&lt;/li&gt;
&lt;li&gt;&lt;code&gt;⌃ ⌥ h&lt;/code&gt; Call hierarchy。常见用法，查看某个方法调用处&lt;/li&gt;
&lt;li&gt;&lt;code&gt;⌥ F7&lt;/code&gt; find usages(filed/local var/method..)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;⌘ F7&lt;/code&gt; 搜索对象在当前文件被引用地方&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;格式化&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;rearranger 格式化代码，给你更精细的格式化控制，设置&lt;code&gt;settings → rearranger&lt;/code&gt;，
可用云盘同步,快捷键&lt;code&gt;⌘ ⌥ ⇧ r&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;settings → code style&lt;/code&gt;调整&lt;code&gt;⌥ ⌘ l&lt;/code&gt;格式化效果&lt;/li&gt;
&lt;li&gt;&lt;code&gt;⌃ ⌥ o&lt;/code&gt; 优化import,排除无用的import(optimize import)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;视图切换&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;⌘  n&lt;/code&gt;   切换到n对应的视图&lt;/li&gt;
&lt;li&gt;&lt;code&gt;⌃  ⇥&lt;/code&gt;(plugin → Switch) 打开的文件切换&lt;/li&gt;
&lt;li&gt;&lt;code&gt;⌘ e&lt;/code&gt;  列出最近查看的额文件列表+视图&lt;/li&gt;
&lt;li&gt;&lt;code&gt;⇧ ⌘  e&lt;/code&gt; 最近修改的文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;⌥ F1&lt;/code&gt; 调出视图切换界面（可切换到finder）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;⇧ ⌃ ⌘ v&lt;/code&gt;垂直分屏(自定义 split vertically)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;⇧ ⌃ ⌘ h&lt;/code&gt;水平分屏(自定义 split horizontally)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;搜索&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;⌘ f&lt;/code&gt;搜索，&lt;code&gt;⌘ r&lt;/code&gt; 搜索替换&lt;/li&gt;
&lt;li&gt;project中，&lt;code&gt;⌃ ⇧ f/r&lt;/code&gt; 递归搜索/替换，&lt;code&gt;⌥  a&lt;/code&gt;全部替换&lt;/li&gt;
&lt;li&gt;&lt;code&gt;⌘ o&lt;/code&gt;    查找类 （正则/大写字母缩略）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;⌘ ⇧ o&lt;/code&gt;  查找文件 (正则/大些字母缩略)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;⌘ ⌥ o&lt;/code&gt;  查找文件内容(symbol)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;重构&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;F5&lt;/code&gt; 拷贝，只能是文件，到其他地方(类和xml都会相应变动)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;F6&lt;/code&gt; 移动（文件/变量/域/方法&amp;hellip;）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;⇧ F6&lt;/code&gt;   改名&lt;/li&gt;
&lt;li&gt;&lt;code&gt;⌘ F6&lt;/code&gt;   修改方法签名(不常用，直接改代码就行)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;⌘ ⌥ v&lt;/code&gt;  extract vaiable&lt;/li&gt;
&lt;li&gt;&lt;code&gt;⌘ ⌥ p&lt;/code&gt;  extract parameter&lt;/li&gt;
&lt;li&gt;&lt;code&gt;⌘ ⌥ f&lt;/code&gt;  extract filed&lt;/li&gt;
&lt;li&gt;&lt;code&gt;⌘ ⌥ m&lt;/code&gt;  extract method&lt;/li&gt;
&lt;li&gt;&lt;code&gt;⌘ ⌥ c&lt;/code&gt;  extract constant&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;debug &amp;amp; run&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;⌃ ⌥ r&lt;/code&gt; select configuration and run&lt;/li&gt;
&lt;li&gt;&lt;code&gt;⌃ ⌥ d&lt;/code&gt; select configuration and debug&lt;/li&gt;
&lt;li&gt;&lt;code&gt;⌃ r&lt;/code&gt;   run当前选中的config&lt;/li&gt;
&lt;li&gt;&lt;code&gt;⌃ d&lt;/code&gt;   debug当前选中的config&lt;/li&gt;
&lt;li&gt;&lt;code&gt;F7&lt;/code&gt;  step into&lt;/li&gt;
&lt;li&gt;&lt;code&gt;F8&lt;/code&gt;  step over&lt;/li&gt;
&lt;li&gt;&lt;code&gt;⇧ F8&lt;/code&gt; step out&lt;/li&gt;
&lt;li&gt;&lt;code&gt;⌥ F8&lt;/code&gt; evaluate expression&lt;/li&gt;
&lt;li&gt;&lt;code&gt;⌥ F9&lt;/code&gt; 下一个断点处&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    <item>
      <title>生活中多人购物一人付账算钱程序</title>
      <link>http://defworld.com/2013/06/03/zhangdan.html</link>
      <pubDate>2013-06-03 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;几个朋友一起旅行或者购物吃个烧烤啥的，账总是一个人先付掉，AA的话支付宝
的AA功能还行，不过如果其中的物品有的是甲的，有的是乙的，有的需要某几个
人均摊，就麻烦了。&lt;br /&gt;
tiemei经常跟朋友出去shopping，回来算账就一堆乱麻，程序员嘛，喜欢偷懒，
写个程序自算账，交给机器做，我就去享受买回来的好吃的了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;账单&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;6   jia   大号印刷背心袋
8.6 wang  八宝茶
14.6 all  咸鸭蛋
4.9 jia  干柠檬
2.7 all   鸡蛋面
12.5 jia  酒
9.9 all   馒头
3.9 jia   酸奶
15  all   刀切馒头
4.9 all   鸡蛋面
25.55 all  八宝米
16.33 jia,wang 凉菜
4.7  wang  陈皮
3.3 jia    枣粽
2.53  all  榨菜
3.9  jia   肉粽
6    wang  老爷爷的餐巾纸
-----------------------
140.9
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;算账程序&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;ruby&#34;&gt;#!/Users/jiadongkai/.rvm/rubies/ruby-2.0.0-p0/bin/ruby

items = IO.readlines(&#39;wumeizhangdan&#39;)

result = {}
split=&amp;quot;\t\t&amp;quot;
isPrices = false
expectedPrices = 0
realPrices = 0

items.each do |item|
  
  # 总价
  if isPrices
    expectedPrices = item.to_f
    if realPrices != expectedPrices
      puts &amp;quot;总价计算出错，期望总价 #{expectedPrices}，实际总价#{realPrices}&amp;quot;
    end
    break
  end

  # 总价前一行
  if(item.start_with?(&amp;quot;--&amp;quot;))
    isPrices = true
    next
  end
  
  puts &amp;quot;统计 #{item}&amp;quot;
  colums = item.split(/\s+/)
  price = colums[0].to_f
  who = colums[1]
  name = colums[2]

  # 几个人平摊一个商品
  whos = who.split(&amp;quot;,&amp;quot;)
  if whos.size &amp;gt; 1 
    ava_price = price / whos.size
  
    whos.each do |who|
      result[who] ||= [0, &#39;&#39;]
      result[who][0] += ava_price
      result[who][1] += &amp;quot;#{ava_price}#{split}#{name}|总价#{price}\n&amp;quot;
    end
    
    realPrices += price
    next
  end
  result[who] ||= [0, &#39;&#39;]
  result[who][0] += price
  result[who][1] += &amp;quot;#{price}#{split}#{name}\n&amp;quot;

  realPrices += price
end

f = File.new(&#39;zhangdanresult&#39;, &#39;w&#39;)
result.each do |who, money_items|
  f.write(&amp;quot;#{money_items[1]}&amp;quot;)
  f.write(&amp;quot;--------------------\n&amp;quot;)
  f.write(&amp;quot;#{money_items[0]}#{split}#{who}\n&amp;quot;)
  f.write(&amp;quot;++++++++++++++++++++\n&amp;quot;)
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;代码写的仓促，各位凑活看&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;结果&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;6.0     大号印刷背心袋
4.9     干柠檬
12.5        酒
3.9     酸奶
8.165       凉菜|总价16.33
3.3     枣粽
3.9     肉粽
--------------------
42.66499999999999       jia
++++++++++++++++++++
8.6     八宝茶
8.165       凉菜|总价16.33
4.7     陈皮
6.0     老爷爷的餐巾纸
--------------------
27.465      wang
++++++++++++++++++++
14.6        咸鸭蛋
2.7     鸡蛋面
9.9     馒头
15.0        刀切馒头
4.9     鸡蛋面
25.55       八宝米
2.53        榨菜
--------------------
75.18       all
++++++++++++++++++++
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    <item>
      <title>不设限的Vim，不设限的人生</title>
      <link>http://defworld.com/2013/06/01/read-vim-help-doc.html</link>
      <pubDate>2013-06-01 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;这篇是自己阅读vim help doc的一些笔记&lt;br /&gt;
我对编辑器之争的态度是:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;eclipse这样强大方便的编辑器固然需要，但vim是很好的补充。个人
不准备用sublime text 2这样的神器，毕竟精力有限，专心吃透vim已经
够，并且可以做的很好。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;usr_02-vim初步&#34; href=&#34;#usr_02-vim初步&#34;&gt;&lt;/a&gt;usr_02 Vim初步&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;normal mode&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;x  删除单个字符
dd 删除一行
J  删除当前行末的换行符


o/O  进入插入模式，下一行/上一行起
i/a  进入插入模式，当前光标前/后起


: 进入cmd mode


u  撤销一次编辑
uu 撤销到原样(vim被配置在vi兼容模式下，可调整)  
CTRL-R redo
U  行撤销，可用u撤销U动作


9k 上移9行
3a! 执行三遍a!，即追加三个!


ZZ 自动保存并退出
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;insert mode&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;cmd mode&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;:e! 放弃未保存的修改，重新编辑
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;其他&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;如何使用help doc&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;usr_03-移动&#34; href=&#34;#usr_03-移动&#34;&gt;&lt;/a&gt;usr_03 移动&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;移动一个单词&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;w / b   向后/前移动一个单词词首
e / ge  向后/前移动一个单词末尾
&#39;iskeyword&#39; 选项，设置vim认为的单词的组成部分
W / B / E /gE 按空白字符分隔的字符串
可使用数字前缀
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;行移动&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;^ $
0 移动到一行的第一个字符
2$ 移动到下一行行尾


nG 移动到n行
50% 移动到50%的地方
H / M / L 可见范围内移动
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;移动到指定字符&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fa / Fa 向后/前移动到字符a
ta / Ta 向后/前移动到字符a前一个字符
;  / ,  正/反向重复上面的命令
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;括号匹配&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;% 匹配(),第一次正向查找括号，第二次匹配
&#39;matchpairs&#39; 设置可匹配的符号
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;确定当前位置&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;:set nu
:set ruler 
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;滚屏&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CTRL-U / CTRL-D 上/下半屏
CTRL-E / CTRL-Y 上/下一行
CTRL-B / CTRL-F 上/下一屏
zt / zz /zb 光标移动到屏幕首/中/末
&#39;scrolloff&#39; 光标上下总留有几行，按了z*命令才有效
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;查找&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/ / ? 正/反向查找
:set noignorecase 忽略大小写
* / # 光标所在位置单词查找
g* / g# 部分匹配
/the/&amp;gt;  / /\&amp;lt;the 匹配词尾/词首


:set hlsearch 高亮匹配
:nohlsearch 关闭本次高亮，下次查找将恢复
:set incsearch 输入时就开始高亮
:set nowrapscan 文首/尾即停止查找
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;标记&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;`` / &#39;&#39; 移动的两个位置间跳转
CTRL-O / CTRL-I 较老/新的位置
:jumps 列出你可以跳转的位置


有名字的标记
m[a-z] 标记当前位置为a-z
m[A-Z] 标记是全局的，跨文件的(H头文件,M makefile,C代码文件)
`{mark} 跳转到标记处
&#39;{mark} 到标记出行首
:markds 查找所有标记


特殊标记
&#39; 跳转前的光标位置
&amp;quot; 离开文件时的位置
. 最后修改的位置
[ 最后修改的开始位置
] 最后修改的结束位置
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;usr_04-做小改动&#34; href=&#34;#usr_04-做小改动&#34;&gt;&lt;/a&gt;usr_04 做小改动&lt;/h2&gt;

&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;usr_07-编辑多个文件&#34; href=&#34;#usr_07-编辑多个文件&#34;&gt;&lt;/a&gt;usr_07 编辑多个文件&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;编辑多个文件&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;vim&#34;&gt;:edit foo.txt 关闭当前文件，打开另一个文件
:hide edit foo.txt 隐藏仓前该文件，编辑另一个文件

vim one.c two.c three.c vim会假定你想编辑全部
:next :wnext :2next 下一个文件
:previous :wprevious
:last :first

:args 正在编辑文件列表中哪个
:args five.c six.c seven.c 编辑另一个文件列表

:set autowrite 不是所有命令执行完都自动写

CTRL-^ 两个文件轮换
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;保留原始文件/备份文件&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;vim&#34;&gt;:set backup  保留本次编辑前文件的备份
:set backupext=.bak 
:set backupdir 
:set writebackup 编辑退出后备份自动删除

:set patchmode=.orig 只保留一份最原始文件，不覆盖
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;拷贝&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;vim&#34;&gt;v 可视模式，拷贝选中的区域
V 选中整行
CTRL-V 列模式，选中矩形块
Y / yy 一行
yaw 一个单词

&amp;quot;fyas 拷贝一个句子到寄存器f
&amp;quot;l3Y  拷贝3行到寄存器l
CTRL-Vjjww&amp;quot;by 宝贝一个区块到寄存器b

&amp;quot;wdaw 删除一个单词到寄存器w中

&amp;quot;fp 粘贴寄存器f中内容
:write &amp;gt;&amp;gt; logfile 直接写入
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;view file&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;vim -R file  :write 会被拒绝，不顾:write!还是会起作用
view file  同上

vim -M file 禁止修改,:write!也无效
:set modifiable 还是可以去掉禁止
:set write 同上
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;修改文件名&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;vim&#34;&gt;:saveas move.c 重命名保存文件，并切换到move.c
:file move.c 效果差不多
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;usr_08-分割窗口&#34; href=&#34;#usr_08-分割窗口&#34;&gt;&lt;/a&gt;usr_08 分割窗口&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;vim&#34;&gt;:sp :vs
:only
:new :vnew 新文件

:3sp alpha.c 
n CTRL-W + / CTRL-W - 
{n}CTRL-W _ 指定高度
CTRL-W _ 扩大到尽可能大

CTRL-W h/j/k/l
CTRL-W t/b 最顶/最低

CTRL-W H/J/K/L 移动窗口,CTRL-W K 垂直分隔时，将窗口移动到最上面并扩展到整屏宽度

vim -o/-O one.txt two.txt three.txt 
:all :vertical all 为:args中每个文件打开一个窗口
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;差异比较&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;vim&#34;&gt;vimdiff one.txt two.txt 显示文件差异
zo zc 打开关闭折叠

:edit main.c
:vertical diffsplit main.c~ 另一种diff方式，从vim内部打开比较文件

补丁方式?

查找差异
]c 跳转到下一个不同

消除差异
:diffupdate 修改后更新高亮
:dp         diff put，将另一侧的差异推过去
:do         diff obtain,将另一侧差异拉过来
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;打开的新窗口位置&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;vim&#34;&gt;命令行很多命令都可以前面加上s表示在新窗口dakia
普通模式加上CTRL-W 例如 CTRL-W CTRL-^ 新窗口轮换
&#39;splitbelow&#39; 让新窗口出现下面(默认上面)
&#39;splitright&#39;

:leftabove {cmd}        当前窗口的左上方
:aboveleft {cmd}        同上
:rightbelow {cmd}       当前窗口的右下方
:belowright {cmd}       同上
:topleft {cmd}          整个 Vim 窗口的最上面或者最左边
:botright {cmd}         整个 Vim 窗口的最下面或者最右边
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;标签页&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;vim&#34;&gt;:tabedit thatfile 标签页打开新文件
:tab split 同一缓冲区的新的标签页
:tab help gt 在新的标签页打开help
{n}gt {n}gT :tabfir :tabl 标签页跳转
:tabonly
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;usr_40-创建新的命令&#34; href=&#34;#usr_40-创建新的命令&#34;&gt;&lt;/a&gt;usr_40 创建新的命令&lt;/h2&gt;

&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;usr_43-使用文件类型&#34; href=&#34;#usr_43-使用文件类型&#34;&gt;&lt;/a&gt;usr_43 使用文件类型&lt;/h2&gt;
</description>
    </item>
    <item>
      <title>spring annotation note</title>
      <link>http://defworld.com/2013/05/23/spring-annotaion.html</link>
      <pubDate>2013-05-23 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;&lt;a href=&#34;http://www.mkyong.com/spring/spring-auto-scanning-components/&#34;&gt;http://www.mkyong.com/spring/spring-auto-scanning-components/&lt;/a&gt;&lt;/p&gt;

&lt;h1&gt;&lt;a style=&#34;display: block;&#34; name=&#34;javaconfig&#34; href=&#34;#javaconfig&#34;&gt;&lt;/a&gt;JavaConfig&lt;/h1&gt;

&lt;p&gt;参考:&lt;br /&gt;
&lt;a href=&#34;http://www.mkyong.com/spring3/spring-3-javaconfig-example/&#34;&gt;Spring 3 JavaConfig Example&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://www.mkyong.com/spring3/spring-3-javaconfig-import-example/&#34;&gt;Spring 3 JavaConfig @Import Example&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://farm8.staticflickr.com/7445/13234177294_d12d406149.jpg&#34; alt=&#34;java config&#34; /&gt;
&lt;br /&gt;
&lt;img src=&#34;http://farm4.staticflickr.com/3744/13234269634_753f991942.jpg&#34; alt=&#34;java config import&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;JavaConfig用来替代最原始的xml配置方式，将bean的声明放到class文件中&lt;/p&gt;

&lt;h1&gt;&lt;a style=&#34;display: block;&#34; name=&#34;常用annotation&#34; href=&#34;#常用annotation&#34;&gt;&lt;/a&gt;常用annotation&lt;/h1&gt;

&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;常用class声明标记&#34; href=&#34;#常用class声明标记&#34;&gt;&lt;/a&gt;常用class声明标记&lt;/h2&gt;

&lt;p&gt;参考:&lt;br /&gt;
&lt;a href=&#34;http://www.mkyong.com/spring/spring-auto-scanning-components/&#34;&gt;spring-auto-scanning-components&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://www.mkyong.com/spring/spring-filtering-components-in-auto-scanning/&#34;&gt;spring-filtering-components-in-auto-scanning&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;一般在class上声明这些组件，但需要加上自动扫描。自动扫描支持用正则指定只扫描
一部分class，或者指定不扫描一部分class.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;@Component  Indicates a auto scan component&lt;/li&gt;
&lt;li&gt;@Repository – Indicates DAO component in the persistence layer.&lt;/li&gt;
&lt;li&gt;@Service – Indicates a Service component in the business layer.&lt;/li&gt;
&lt;li&gt;@Controller – Indicates a controller component in the presentation layer.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Auto-Wiring&lt;/h3&gt;

&lt;p&gt;参考:&lt;br /&gt;
&lt;a href=&#34;http://www.mkyong.com/spring/spring-auto-wiring-beans-in-xml/&#34;&gt;Spring Auto-Wiring Beans&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://www.mkyong.com/spring/spring-properties-dependency-checking/&#34;&gt;spring-properties-dependency-checking&lt;/a&gt;&lt;/p&gt;

&lt;h4&gt;spring支持以下几种注入方式&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;no - 需手动声明&lt;/li&gt;
&lt;li&gt;byName - 通过setter方法&lt;/li&gt;
&lt;li&gt;byType - 通过setter方法&lt;/li&gt;
&lt;li&gt;constructor - 调用构造函数&lt;/li&gt;
&lt;li&gt;autodetect - 先走构造器，否则走byType&lt;/li&gt;
&lt;/ol&gt;

&lt;h4&gt;依赖检查&lt;/h4&gt;

&lt;p&gt;参考&lt;br /&gt;
&lt;a href=&#34;http://www.mkyong.com/spring/spring-dependency-checking-with-required-annotation/&#34;&gt;spring-dependency-checking-with-required-annotation&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://www.mkyong.com/spring/spring-define-custom-required-style-annotation/&#34;&gt;spring-define-custom-required-style-annotation&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;dependency-check：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;none – No dependency checking.&lt;/li&gt;
&lt;li&gt;simple – If any properties of primitive type (int, long,double…) and collection types (map, list..) have not been set, UnsatisfiedDependencyException will be thrown.&lt;/li&gt;
&lt;li&gt;objects – If any properties of object type have not been set, UnsatisfiedDependencyException will be thrown.&lt;/li&gt;
&lt;li&gt;all – If any properties of any type have not been set, an UnsatisfiedDependencyException will be thrown.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;更多时候，用@Required检查某个几个field就够了，不需要dependency-check.&lt;/p&gt;

&lt;h4&gt;@Autowired&lt;/h4&gt;

&lt;p&gt;参考:&lt;br /&gt;
&lt;a href=&#34;http://www.mkyong.com/spring/spring-auto-wiring-beans-with-autowired-annotation/&#34;&gt;Spring Auto-Wiring Beans With @Autowired Annotation&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;@Autowired can be applied on setter method, constructor or a field&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;默认如果标识了@Autowired字段找不到对应的bean，将抛出异常，可&lt;code&gt;@Autowired(required=false)&lt;/code&gt;
这样关闭掉依赖检查。&lt;br /&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;@Qualifier&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 指定装配某个名字的bean
@Autowired
@Qualifier(&amp;quot;PersonBean1&amp;quot;)
private Person person;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;插手bean创建和销毁过程&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://www.mkyong.com/spring/spring-initializingbean-and-disposablebean-example/&#34;&gt;spring-initializingbean-and-disposablebean-example&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://www.mkyong.com/spring/spring-init-method-and-destroy-method-example/&#34;&gt;Spring Init-Method And Destroy-Method Example&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://www.mkyong.com/spring/spring-postconstruct-and-predestroy-example/&#34;&gt;spring-postconstruct-and-predestroy-example&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;可继承一个接口实现创建(all bean properties have been set)和销毁(after Spring container is released the bean)时被调用的方法（不推荐），你还有两种选择：&lt;br /&gt;
1. 在xml配置时指定init-method和destroy-method
2. @PostConstruct and @PreDestroy&lt;/p&gt;
</description>
    </item>
    <item>
      <title>JMM-java内存模型</title>
      <link>http://defworld.com/2013/05/21/jmm.html</link>
      <pubDate>2013-05-21 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;参考:&lt;br /&gt;
&lt;a href=&#34;http://ifeve.com/java-memory-model-0/&#34;&gt;深入理解java内存模型系列文章&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://ifeve.com/jmm-faq/&#34;&gt;Java内存模型FAQ&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://ifeve.com/syn-jmm/&#34;&gt;同步和Java内存模型&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>tomcat源码阅读-1-准备源码</title>
      <link>http://defworld.com/2013/05/20/read-tomcat-source-1.html</link>
      <pubDate>2013-05-20 12:00:00 +0800</pubDate>
      <description>&lt;ol&gt;
&lt;li&gt;下载编译

&lt;ol&gt;
&lt;li&gt;svn co &lt;a href=&#34;http://svn.apache.org/repos/asf/tomcat/tc6.0.x/tags/TOMCAT_6_0_29/&#34;&gt;http://svn.apache.org/repos/asf/tomcat/tc6.0.x/tags/TOMCAT_6_0_29/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;cp build.properties.default build.properties，重新指定base.path&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ant download&lt;/code&gt;下载依赖到base.path指定的目录&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ant&lt;/code&gt;编译&lt;/li&gt;
&lt;li&gt;编译后的tomcat在&lt;strong&gt;output/build&lt;/strong&gt;目录&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;导入IDE-IDEA

&lt;ol&gt;
&lt;li&gt;file → import module → java module&lt;/li&gt;
&lt;li&gt;add module dpendencies &amp;ldquo;jars or derectory&amp;rdquo;

&lt;ol&gt;
&lt;li&gt;ant.jar&lt;/li&gt;
&lt;li&gt;jaxrpc.jar&lt;/li&gt;
&lt;li&gt;org.eclipse.jdt.core_3.3.1.v_780_R33x.jar&lt;/li&gt;
&lt;li&gt;wsdl4j-1.5.1.jar&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;运行&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;参考:&lt;br /&gt;
&lt;a href=&#34;http://www.cnblogs.com/huangfox/archive/2011/10/20/2218970.html&#34;&gt;Eclipse导入Tomcat源码&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>spring异常处理</title>
      <link>http://defworld.com/2013/05/19/spring-3-exception-handling.html</link>
      <pubDate>2013-05-19 12:00:00 +0800</pubDate>
      <description>&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;我经手的两个项目中异常处理如何做？&#34; href=&#34;#我经手的两个项目中异常处理如何做？&#34;&gt;&lt;/a&gt;我经手的两个项目中异常处理如何做？&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;项目一&lt;/strong&gt;&lt;br /&gt;
  所有对外接口均返回json数据，现有的异常处理是实现spring容器提供的
HandlerExceptionResolver，所有的异常均返回一个静态的错误页面。&lt;br /&gt;
&lt;strong&gt;项目二&lt;/strong&gt;&lt;br /&gt;
返回html也返回json数据，同样实现HandlerExceptionResolver，针对请求html
的情况，返回错误页面；而针对请求Json数据的情况，返回一个json数据，并告诉
调用方resultCode+resultMsg。&lt;/p&gt;

&lt;p&gt;显然项目二针对json数据设置resultcode的方法更合适&lt;/p&gt;

&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;spring提供了异常处理方案？&#34; href=&#34;#spring提供了异常处理方案？&#34;&gt;&lt;/a&gt;spring提供了异常处理方案？&lt;/h2&gt;

&lt;p&gt;首先，重温下servlet container中的异常处理如何做：&lt;br /&gt;
&lt;strong&gt;before servlet 3:&lt;/strong&gt;&lt;br /&gt;
我们用web.xml的error-page元素在error-code或exception-type两个粒度规定发生异常时
应该返回哪个页面。错误页面中可显示部分动态内容：java.servlet.error.statuts_code
和javax.servlet.error.message&lt;br /&gt;
&lt;strong&gt;serlet 3&lt;/strong&gt;:&lt;br /&gt;
可以直接映射到一个path:&lt;br /&gt;
    &amp;lt;error-page&amp;gt;
      &amp;lt;location&amp;gt;/error&amp;lt;/location&amp;gt;
    &amp;lt;/error-page&amp;gt;&lt;/p&gt;

&lt;p&gt;然后，你可以实现一个controller或者一个jsp页面来返回错误信息。不过你还是只能拿到
java.servlet.error.statuts_code和javax.servlet.error.message等最基本的信息就是了。&lt;/p&gt;

&lt;p&gt;spring提供的常用方案是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;实现HandlerExceptionResolver&lt;/li&gt;
&lt;li&gt;直接使用spring实现好的SimpleMappingExceptionResolver：定义exception class与error page的映射&lt;/li&gt;
&lt;li&gt;@ExceptionHandler在controller中定义（当前controller，父类中的会被继承）&lt;/li&gt;
&lt;li&gt;@ExceptionHandler在@ControllerAdvice class中定义(any controller)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;前两种方案会强制要求你返回一个ModelAndView对象，也就是只能定位到一个view。&lt;br /&gt;
如果需要对入参和返回值有更灵活的控制，用下面两种。比如，你不是需要返回一个view,
而是希望直接往resp body中写东西。&lt;/p&gt;

&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;standard-spring-mvc-exceptions&#34; href=&#34;#standard-spring-mvc-exceptions&#34;&gt;&lt;/a&gt;Standard Spring MVC Exceptions&lt;/h2&gt;

&lt;p&gt;在spring处理request过程中可能跑出spring mvc定义的异常，用上面的第一第二种方案将异常映射到
error page固然能处理掉。不过为了client更方便处理，你可能希望设置resp code。DefaultHandlerExceptionResolver
正是做了这件事，它被自动注册了，无需使用者关心。&lt;br /&gt;
DefaultHandlerExceptionResolver设置了resp code，不过你可能希望自定义error view(试试这两种方式：ContentNeogitatingViewResolver,
MappingJacksonJsonView)。同样的问题，你不仅需要控制error page，甚至希望自己动态生成resp body，用@ExceptionHandler方式
可以拿到目的，不过可以尝试继承ResponseEntityExceptionHandler，因为它已经帮你做了很多。&lt;/p&gt;

&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;@responsestatus&#34; href=&#34;#@responsestatus&#34;&gt;&lt;/a&gt;@ResponseStatus&lt;/h2&gt;

&lt;p&gt;ResponseStatusExceptionResolver会将设置了@ResponseStatus的状态全部放到resp中.&lt;br /&gt;
默认DispatcherServlet已经注册了ResponseStatusExceptionResolver&lt;/p&gt;

&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;总结&#34; href=&#34;#总结&#34;&gt;&lt;/a&gt;总结&lt;/h2&gt;

&lt;p&gt;故项目二的也有可改进空间：&lt;br /&gt;
1. 返回的json数据还是通过渲染vm的方式，可以替换直接返回responseEntity
2. 对其他异常的处理过于简单（也可能是业务需求即如此）
3. 没有正确设置resp code&lt;/p&gt;
</description>
    </item>
    <item>
      <title>java语言基础细节</title>
      <link>http://defworld.com/2013/05/18/a-little-things-abount-java-language.html</link>
      <pubDate>2013-05-18 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;2011年的笔记，当时是在看《细说 Java》，算是一个入门书。&lt;br /&gt;
虽然基础，但是平时工作中并不一定注意到这些细节，现在这些零碎的东西都整理起来。&lt;br /&gt;
只挑选目前看还有些价值的&lt;/p&gt;

&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;java基本数据类型&#34; href=&#34;#java基本数据类型&#34;&gt;&lt;/a&gt;java基本数据类型&lt;/h2&gt;

&lt;p&gt;基本数据类型由低到高排序：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;byte(1) short(2) ---&amp;gt;
                     int(4) long(8) float(4) double(8)
        char (2) ---&amp;gt;
boolean(1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由低到高隐式转换，高到底必须显示申明，因为数据会失真。&lt;br /&gt;
char是无符号类型，所以char short&lt;br /&gt;
boolean不能和其他类型进行相互转换&lt;br /&gt;
必要时使用BigInteger &amp;amp; BigDecimal&lt;/p&gt;

&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;值传递与引用传递&#34; href=&#34;#值传递与引用传递&#34;&gt;&lt;/a&gt;值传递与引用传递&lt;/h2&gt;

&lt;p&gt;两者其实都是值传递&lt;/p&gt;

&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;私有属性的优势&#34; href=&#34;#私有属性的优势&#34;&gt;&lt;/a&gt;私有属性的优势&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;对外暴露get/set，可实现额外的校验或其他逻辑控制&lt;/li&gt;
&lt;li&gt;隐藏内部细节，对外屏蔽内部变化&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;类加载及对象初始化时动作&#34; href=&#34;#类加载及对象初始化时动作&#34;&gt;&lt;/a&gt;类加载及对象初始化时动作&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;在类加载时（第一次使用类是），为类中的静态成员变量分配内存空间，并赋予默认值&lt;/li&gt;
&lt;li&gt;执行静态成员变量的初始化操作。前面已经指出，静态成员的初始化有两种：在声明时直接初始化与静态初始化块。两种方式会按照在类中出现的顺序（声明的顺序）来执行。A，B步只会在类加载时执行一次。&lt;/li&gt;
&lt;li&gt;如果创建了类的对象，便在堆中为类的实例分配内存空间，实例变量被初始化为默认值&lt;/li&gt;
&lt;li&gt;执行实例化变量的初始化操作。实例变量的前两种初始化方式：声明时直接初始化与初始化块，这两种初始化方法会按照在类中出现的顺序（声明的顺序）来执行。&lt;/li&gt;
&lt;li&gt;执行类的构造器。C~E在每次创建类的对象时都会执行。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;重载/重写/隐藏&#34; href=&#34;#重载/重写/隐藏&#34;&gt;&lt;/a&gt;重载/重写/隐藏&lt;/h2&gt;

&lt;h3&gt;重载&lt;/h3&gt;

&lt;p&gt;方法的重载就是方法具有相同的名称不同的参数列表，在编译期间确定，编译器可以根据参数的类型与个数加以区分，而方法的返回类型与方法抛出异常等因素的不同不作为重载的标准，因为其不能提供足够的信息。如果参数已引用传递，那么硬系那个调用的因素时引用的类型，而与引用所指向的对象类型无关。&lt;br /&gt;
编译器选择重载方法时顺序时：&lt;br /&gt;
A选择形参类型与制定的实参列表完全一致的方法&lt;br /&gt;
B如果A中的方法不存在，选择形参列表的参数类型能够兼容对应的实参列表的参数类型。&lt;br /&gt;
  如果满足这一条件的方法不止一个，那么如果A方法参数类表在类型上可以兼容对应的B方法参数列表的类型，那么将排除B方法，按照这种方法排除，如果排除以后仍然剩下多于一个的方法，那么编译器会给出错误信息，指出引用类型不明确。&lt;br /&gt;
C如果B中的方法不存在，自动封箱与拆箱操作将会执行，然后按照B继续寻找。&lt;br /&gt;
D如果C中的方法不存在，则选择具有可变形参的方法，如果方法存在，调用该方法，否则给出错误信息，指出方法不存在。&lt;/p&gt;

&lt;h3&gt;重写&lt;/h3&gt;

&lt;p&gt;方法重写的条件：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;子类与父类的方法必须都是实例方法。如果父类是实例方法而子类是静态方法，或者相反，则编译器会报错。如果子类与父类都是静态方法，那么子类隐藏父类的方法，而不是重写父类的方法。&lt;/li&gt;
&lt;li&gt;子类与父类的方法需要具有相同的方法名称、参数列表，并且子类的返回类型与父类相同或者是父类的子类。如果方法名称相同而参数列表不同（返回类型可相同也可不相同），那么只是方法的重载。如果方法名称与参数列表相同而返回类型不同（并且子类方法的返回类型不是父类的子类型），那么编译器将会报错。&lt;/li&gt;
&lt;li&gt;子类方法的访问权限不能小于父类的访问权限。&lt;/li&gt;
&lt;li&gt;子类方法不能比父类方法抛出更多的已检测异常（也称编译时异常）。&lt;/li&gt;
&lt;li&gt;父类的方法在子类中必须可见。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;隐藏&lt;/h3&gt;

&lt;p&gt;静态方法隐藏的条件:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;静态（required)&lt;/li&gt;
&lt;li&gt;相同的方法名称、参数列表、子类的返回类型和父类相同或者是父类的子类型&lt;/li&gt;
&lt;li&gt;子类方法的访问权限不能小于父类方法&lt;/li&gt;
&lt;li&gt;子类方法不恩能够比父类方法抛出更多的已检测异常&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;成员变量隐藏：&lt;br /&gt;
与静态方法类似，子类不能重写类中的成员变量，只能隐藏父类的成员变量（不论静态变量还是实例变量）。只要求子类与父类的成员变量的名字相同即可，与变量类型无关。&lt;br /&gt;
注意成员变量的继承，如果子类继承了父类的成员变量，则子类与父类共享同一个成员变量。如果是实例变量，在对象内部共享，如果是静态成员变量，在父类与子类之间共享。&lt;/p&gt;

&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;变量和方法的搜索顺序&#34; href=&#34;#变量和方法的搜索顺序&#34;&gt;&lt;/a&gt;变量和方法的搜索顺序&lt;/h2&gt;

&lt;p&gt;遵循由近及远的原则&lt;/p&gt;

&lt;h3&gt;变量的搜索顺序&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;从访问某变量所在的语句块中（最小语句块）搜索变量的声明&lt;/li&gt;
&lt;li&gt;访问该语句块的外围语句块，知道整个方法所在的语句块，方法的参数也作为搜索的对象。&lt;/li&gt;
&lt;li&gt;搜索类中声明的成员变量，如果不存在其声明，搜索从父类型中集成的成员变量。&lt;/li&gt;
&lt;li&gt;如果该类是一个内部类，那么对外围类返回步骤3进行搜索，知道顶层类为止。&lt;/li&gt;
&lt;li&gt;搜索明确静态导入的成员（即单一静态导入的成员）&lt;/li&gt;
&lt;li&gt;搜索使用星号静态导入的成员&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;方法的搜索顺序&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;当前类的类型&lt;/li&gt;
&lt;li&gt;内部类的类型&lt;/li&gt;
&lt;li&gt;明确导入的类型&lt;/li&gt;
&lt;li&gt;与当前类处在同一个包中的其他类型&lt;/li&gt;
&lt;li&gt;使用带星号导入的类型&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;泛型&#34; href=&#34;#泛型&#34;&gt;&lt;/a&gt;泛型&lt;/h2&gt;

&lt;p&gt;使用Object需要在运行时强制转型，而泛型编译期间就能确定类型，运行截断参数类型的信息将被擦除。&lt;br /&gt;
List&amp;lt;Super&amp;gt;只能接收List&amp;lt;Super&amp;gt;类型的参数，不能接收List&amp;lt;Sub&amp;gt;。用List&amp;lt;?&amp;gt;/List&amp;lt;? extends Super&amp;gt;/List&amp;lt;? super Number&amp;gt;&lt;/p&gt;

&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;引用类型&#34; href=&#34;#引用类型&#34;&gt;&lt;/a&gt;引用类型&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;强引用存在永远不会回收&lt;/li&gt;
&lt;li&gt;soft引用存在只有在内存满是才有可能被回收（看GC算法）&lt;/li&gt;
&lt;li&gt;weak reference 对象与soft引用对象不同点是：后者在GC回收时要通过算法检查是否会后，对前者总是回收，但是复杂关系的weak对象群要好几次GC的运行才会被回收。只要勇于map&lt;/li&gt;
&lt;li&gt;虚引用一般适用于执行完了finalize函数，并且为不可到达对象，但是还没有被GC回收的对象。辅助finalize进行后期回收工作。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    <item>
      <title>markdown所用图片上传自动化脚本</title>
      <link>http://defworld.com/2013/05/18/auto-up-img-to-filikr-and-get-shareurl.html</link>
      <pubDate>2013-05-18 12:00:00 +0800</pubDate>
      <description>&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;我在做一件什么事?&#34; href=&#34;#我在做一件什么事?&#34;&gt;&lt;/a&gt;我在做一件什么事?&lt;/h2&gt;

&lt;p&gt;我在写markdown笔记时，有些本地图片需要嵌入，而上传并获取外链实在是一个繁琐的
过程。这明显是可以自动化掉的过程。&lt;br /&gt;
更进一步，图片上传和获取外链自动化掉，但还需要手动拷贝替换makrdown中的图片链接，这个过程亦可自动化掉。&lt;/p&gt;

&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;思路&#34; href=&#34;#思路&#34;&gt;&lt;/a&gt;思路&lt;/h2&gt;

&lt;p&gt;调用&lt;a href=&#34;http://flikr.com/&#34;&gt;flickr&lt;/a&gt;将图片上传并获取外链&lt;/p&gt;

&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;操作步骤&#34; href=&#34;#操作步骤&#34;&gt;&lt;/a&gt;操作步骤&lt;/h2&gt;

&lt;h3&gt;flickr授权验证&lt;/h3&gt;

&lt;p&gt;我写了一个工具，方便拿到flickr授权后的access_token &amp;amp; access_secret, &lt;a href=&#34;/tools&#34;&gt;here&lt;/a&gt;&lt;br /&gt;
或者你写个脚本来拿，类似下面我用ruby实现的这段：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;require &#39;flickraw&#39;

FlickRaw.api_key = &amp;quot;933e8bb7bee8381c46a9b3cb1e321ed6&amp;quot;
FlickRaw.shared_secret=&amp;quot;99bb0541ec349ae5&amp;quot;

# authentication 
token = flickr.get_request_token
auth_url =  flickr.get_authorize_url(token[&#39;oauth_token&#39;], :perms =&amp;gt; &#39;delete&#39;)

puts &amp;quot;Open this url in your process to complete the authication process : #{auth_url}&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;flickr图片自动上传&amp;amp;获取分享外链&lt;/h3&gt;

&lt;p&gt;用ruby实现，所以若想成功运行请确保安装了ruby，且&lt;code&gt;gem install flickraw&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;require &#39;flickraw&#39;

FlickRaw.api_key = &amp;quot;933e8bb7bee8381c46a9b3cb1e321ed6&amp;quot;
FlickRaw.shared_secret=&amp;quot;99bb0541ec349ae5&amp;quot;

flickr.access_token = &amp;quot;72157633501230371-9da780bd34f&amp;quot; # !!! 填你的acess_token
flickr.access_secret = &amp;quot;f448a228f71afecd&amp;quot; # !!! 填你的acess_secret

puts &#39;photo path:&#39;
photo_path = gets.strip # 命令行输入图片路径

puts &#39;photo tilte:&#39;
photo_title = gets.strip 
if photo_title.empty?
    photo_title = File.basename(photo_path, &amp;quot;.*&amp;quot;) # 若没有输入title，默认用图片名
end

puts &#39;photo description:&#39;
photo_description = gets.strip


# 所有图片都存在这个set中
SET_TITLE=&amp;quot;markdown_imgs&amp;quot;
SET_DESCRIPTION=&amp;quot;iFlikcr应用，tiemei支持，详见defworld.com&amp;quot;

photo_id = flickr.upload_photo photo_path, :title =&amp;gt; photo_title, 
                               :description =&amp;gt; photo_description 


set = nil 

has_set = false
# !!! 换成你自己的user_id，右侧可拿到：http://www.flickr.com/services/api/explore/flickr.auth.oauth.getAccessToken
flickr.photosets.getList(:user_id =&amp;gt; &#39;79104125@N05&#39;).each do |e| 
  if e.to_hash[&#39;title&#39;] == SET_TITLE
    has_set = true
    set = e.to_hash
  end 
end
# title相同的set还不存在
if not has_set
  set = flickr.photosets.create(:title       =&amp;gt; SET_TITLE, 
                                :description =&amp;gt; SET_DESCRIPTION,
                                :primary_photo_id    =&amp;gt; photo_id)
else
  flickr.photosets.addPhoto(:photoset_id =&amp;gt; set[&#39;id&#39;], 
                            :photo_id    =&amp;gt; photo_id)
end

# 获取图片外链
info = flickr.photos.getInfo(:photo_id =&amp;gt; photo_id)
puts FlickRaw.url(info) # !!! 替换这个方法可选择外链的图片尺寸
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;演示示例：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://farm8.staticflickr.com/7401/8749136193_2d19cbb140.jpg&#34; alt=&#34;auto upload imgs &amp;amp; get share url demo&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;另，返回的share url的图片支持是可调节的:&lt;br /&gt;
&lt;img src=&#34;http://farm3.staticflickr.com/2833/8749133645_83b09f7396.jpg&#34; alt=&#34;flickr图片尺寸规则&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;对应到代码里是&lt;code&gt;puts FlickRaw.url(info)&lt;/code&gt;这行:&lt;br /&gt;
&lt;img src=&#34;http://farm8.staticflickr.com/7368/8749149989_2f285b06da.jpg&#34; alt=&#34;flickraw接口&#34; /&gt;
&lt;/p&gt;

&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;遇到的坑&#34; href=&#34;#遇到的坑&#34;&gt;&lt;/a&gt;遇到的坑&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;pi的默认时区不是CST&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime
如果你之前用date修改了时间没改时区，惊醒oauth验证会报错，
改完时区后不仅需要手动date修改时间，还需要进到root下去修改
sudo -s; date MMDDhhmmYYYY
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;tips&#34; href=&#34;#tips&#34;&gt;&lt;/a&gt;tips&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;install ruby in pi&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt-get install ruby 
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;install node.js in pi&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt-get install g++


wget http://nodejs.org/dist/v0.10.7/node-v0.10.7.tar.gz
tar -xzvf node-v0.10.7.tar.gz
cd node-v0.10.7
./configure --prefix=/usr/local/node
make 
sudo make install
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ok ! enjoy it !&lt;/p&gt;
</description>
    </item>
    <item>
      <title>树莓派搭建个人静态博客</title>
      <link>http://defworld.com/2013-05/build-your-blog-with-gor-and-pi.html</link>
      <pubDate>2013-05-12 12:00:00 +0800</pubDate>
      <description>&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;我在做一件什么事？&#34; href=&#34;#我在做一件什么事？&#34;&gt;&lt;/a&gt;我在做一件什么事？&lt;/h2&gt;

&lt;p&gt;作为一个coder，一个自己的博客是‘标配’丫&lt;br /&gt;
云主机的控制力度实在有限，自己租服务器实在没必要，毕竟只有几篇静态的博文而已。&lt;br /&gt;
用自己的笔记本或台式机搭，又略显大材小用，最近电费不便宜。&lt;br /&gt;
树莓派的静态博客实在合适不过:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;树莓派   400+
域名一年 100-
电费     忽略把，功率实在低
实用性   Mem 256M CPU armv6l 跑静态的博客妥妥的
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;整体思路&#34; href=&#34;#整体思路&#34;&gt;&lt;/a&gt;整体思路&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;准备树莓派(+电源+SD卡)&lt;/li&gt;
&lt;li&gt;准备域名(net.cn)&lt;/li&gt;
&lt;li&gt;准备家里用的ADSL网络&lt;/li&gt;
&lt;li&gt;用&lt;a href=&#34;https://www.dnspod.cn/&#34;&gt;DNSPod&lt;/a&gt;的DDNS支持，将家里路由器对外ip动态绑定
到上面准好的域名&lt;/li&gt;
&lt;li&gt;Pi的MAC地址在路由器里设置静态路由&lt;/li&gt;
&lt;li&gt;设置路由器80端口的所有tcp/udp包直接转发到树莓派的ip&lt;/li&gt;
&lt;li&gt;在树莓派上安装Nginx，并将&lt;a href=&#34;https://github.com/wendal/gor&#34;&gt;Gor&lt;/a&gt;或者
&lt;a href=&#34;http://ruhoh.com/&#34;&gt;Ruhoh&lt;/a&gt;编译好的静态博客内容放到Nginx能找到的位置&lt;/li&gt;
&lt;li&gt;start DNSPod DDNS shell，你可到这里&lt;a href=&#34;https://support.dnspod.cn/Support/api&#34;&gt;https://support.dnspod.cn/Support/api&lt;/a&gt;找合适的工具，我用&lt;a href=&#34;https://gist.github.com/chuangbo/833369&#34;&gt;https://gist.github.com/chuangbo/833369&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;start nginx&lt;/li&gt;
&lt;/ol&gt;

&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;操作步骤&#34; href=&#34;#操作步骤&#34;&gt;&lt;/a&gt;操作步骤&lt;/h2&gt;

&lt;p&gt;已经有同好做了很不错的教程:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://dqylyln.dyndns.org/2013/pi-gor.html&#34;&gt;利用GOR在Raspberry Pi上搭建博客&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://hugozhu.myalert.info/2013/02/27/%E5%9C%A8Pi%E5%92%8CGithub%E4%B8%8A%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2.html&#34;&gt;在Pi和Github上搭建自己的个人博客&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://dave.cheney.net/2012/09/25/installing-go-on-the-raspberry-pi&#34;&gt;Installing Go on the Raspberry Pi&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;我遇到的坑&#34; href=&#34;#我遇到的坑&#34;&gt;&lt;/a&gt;我遇到的坑&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;8G的SD卡装了个系统只剩200M的空间&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;原因：系统预设只有2G的空间
解决：sudo raspi-config =&amp;gt; expand-rootf 
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;到google下载go源码太耗时&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;原因：pi的配置比较低
解决：另外的电脑下载完scp到pi上
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;pi上编译的go源码test跑不通，运行go报错&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;原因：google的开发人员提交的代码没有做好测试；
      Pi是ARM平台不能用主干的代码，需要用TIP分支
解决：hg clone -u tip https://code.google.com/p/go
      hg revert -r 15749:e92503ce815b --all (我是使用15749:e92503ce815b 这个版本没问题)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;pi自带的vim不怎么好用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;原因：版本不行
解决：sudo apt-get install vim
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;安装gor提示GOPATH没有设置&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.bashrc中加上:
  export GOPATH=$HOME/workspace/go
  export PATH=$GOPATH/bin:$PATH
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;go编译好了，命令行还不能用go命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.bashrc中加上:
  export GOROOT=/path/to/your_go_root_dir
  export PATH=$GOROOT/bin:$PATH
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ok ! enjoy it!&lt;/p&gt;
</description>
    </item>
    <item>
      <title>你的第一篇博客</title>
      <link>http://defworld.com/2012/new-born.html</link>
      <pubDate>2012-12-22 12:00:00 +0800</pubDate>
      <description>&lt;h1&gt;感谢你使用Gor编写博客&lt;/h1&gt;

&lt;h2&gt;本文位于 posts/first-blog.md , 你可以任何删掉,修改这个文件&lt;/h2&gt;

&lt;p&gt;文件开头是当前文章的元数据&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;date为自动生成, 当然,你可以修改,这是你的自由&lt;/li&gt;
&lt;li&gt;permalink 可以是固定地址,也可以由gor为你自动生成&lt;/li&gt;
&lt;li&gt;categories 就是分类, 可以多个&lt;/li&gt;
&lt;li&gt;tags 同理,多个标签也是很常见的&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;请确保文件使用UTF8 without BOM编码&lt;/p&gt;

&lt;h2&gt;你可以通过执行下面的语句来新建一篇博客:&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;gor post 文章标题
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;编译你的博客,并预览之&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;gor compile #编译
gor http
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后打开你的浏览器,访问 &lt;a href=&#34;http://127.0.0.1:8080&#34;&gt;http://127.0.0.1:8080&lt;/a&gt; 来预览&lt;/p&gt;

&lt;h2&gt;你将使用Markdown来编写博客&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://wowubuntu.com/markdown/&#34;&gt;Markdown 语法中文版&lt;/a&gt; 能让你快速入门其语法&lt;/p&gt;

&lt;p&gt;相信&lt;a href=&#34;http://markdownpad.com&#34;&gt;MarkdownPad&lt;/a&gt;或&lt;a href=&#34;http://code.google.com/p/liteide/&#34;&gt;liteide&lt;/a&gt;会是你的编写博客的好帮手&lt;/p&gt;

&lt;h2&gt;如果你打算部署到github的pages上&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;申请github帐户&lt;/li&gt;
&lt;li&gt;新建一个库 username.github.com 即你的用户名命名的地址&lt;/li&gt;
&lt;li&gt;将compiled目录,作为根路径,提交上去github.com上&lt;/li&gt;
&lt;li&gt;稍等几分钟, 你即可通过 &lt;a href=&#34;http://username.github.com&#34;&gt;http://username.github.com&lt;/a&gt; 访问到&lt;/li&gt;
&lt;/ol&gt;

&lt;h2&gt;附上git教程 &lt;a href=&#34;http://gitbook.liuhui998.com/&#34;&gt;GitBook中文版&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;一般来说,你只需要几个简单的git命令就足以应付大部分需求(仅示例)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git clone git://github.com/wendal/wendal.net.git
git add -A
git commit -m &amp;quot;...&amp;quot;
git pull
git push
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;用gor编写博客将会是一件很开心的事,如果有任何意见或建议,欢迎到 &lt;a href=&#34;http://github.com/wendal/gor&#34;&gt;gor的官网&lt;/a&gt; 提交issue&lt;/h2&gt;

&lt;h1&gt;祝你使用愉快&lt;/h1&gt;
</description>
    </item>
  </channel>
</rss>